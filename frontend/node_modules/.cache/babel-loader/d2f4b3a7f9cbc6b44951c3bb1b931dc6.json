{"ast":null,"code":"\"use strict\";\n\n;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar types_1 = tslib_1.__importDefault(require(\"./types\"));\n\nvar path_1 = tslib_1.__importDefault(require(\"./path\"));\n\nvar scope_1 = tslib_1.__importDefault(require(\"./scope\"));\n\nfunction nodePathPlugin(fork) {\n  var types = fork.use(types_1.default);\n  var n = types.namedTypes;\n  var b = types.builders;\n  var isNumber = types.builtInTypes.number;\n  var isArray = types.builtInTypes.array;\n  var Path = fork.use(path_1.default);\n  var Scope = fork.use(scope_1.default);\n\n  var NodePath = function NodePath(value, parentPath, name) {\n    if (!(this instanceof NodePath)) {\n      throw new Error(\"NodePath constructor cannot be invoked without 'new'\");\n    }\n\n    Path.call(this, value, parentPath, name);\n  };\n\n  var NPp = NodePath.prototype = Object.create(Path.prototype, {\n    constructor: {\n      value: NodePath,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperties(NPp, {\n    node: {\n      get: function () {\n        Object.defineProperty(this, \"node\", {\n          configurable: true,\n          value: this._computeNode()\n        });\n        return this.node;\n      }\n    },\n    parent: {\n      get: function () {\n        Object.defineProperty(this, \"parent\", {\n          configurable: true,\n          value: this._computeParent()\n        });\n        return this.parent;\n      }\n    },\n    scope: {\n      get: function () {\n        Object.defineProperty(this, \"scope\", {\n          configurable: true,\n          value: this._computeScope()\n        });\n        return this.scope;\n      }\n    }\n  });\n\n  NPp.replace = function () {\n    delete this.node;\n    delete this.parent;\n    delete this.scope;\n    return Path.prototype.replace.apply(this, arguments);\n  };\n\n  NPp.prune = function () {\n    var remainingNodePath = this.parent;\n    this.replace();\n    return cleanUpNodesAfterPrune(remainingNodePath);\n  }; // The value of the first ancestor Path whose value is a Node.\n\n\n  NPp._computeNode = function () {\n    var value = this.value;\n\n    if (n.Node.check(value)) {\n      return value;\n    }\n\n    var pp = this.parentPath;\n    return pp && pp.node || null;\n  }; // The first ancestor Path whose value is a Node distinct from this.node.\n\n\n  NPp._computeParent = function () {\n    var value = this.value;\n    var pp = this.parentPath;\n\n    if (!n.Node.check(value)) {\n      while (pp && !n.Node.check(pp.value)) {\n        pp = pp.parentPath;\n      }\n\n      if (pp) {\n        pp = pp.parentPath;\n      }\n    }\n\n    while (pp && !n.Node.check(pp.value)) {\n      pp = pp.parentPath;\n    }\n\n    return pp || null;\n  }; // The closest enclosing scope that governs this node.\n\n\n  NPp._computeScope = function () {\n    var value = this.value;\n    var pp = this.parentPath;\n    var scope = pp && pp.scope;\n\n    if (n.Node.check(value) && Scope.isEstablishedBy(value)) {\n      scope = new Scope(this, scope);\n    }\n\n    return scope || null;\n  };\n\n  NPp.getValueProperty = function (name) {\n    return types.getFieldValue(this.value, name);\n  };\n  /**\n   * Determine whether this.node needs to be wrapped in parentheses in order\n   * for a parser to reproduce the same local AST structure.\n   *\n   * For instance, in the expression `(1 + 2) * 3`, the BinaryExpression\n   * whose operator is \"+\" needs parentheses, because `1 + 2 * 3` would\n   * parse differently.\n   *\n   * If assumeExpressionContext === true, we don't worry about edge cases\n   * like an anonymous FunctionExpression appearing lexically first in its\n   * enclosing statement and thus needing parentheses to avoid being parsed\n   * as a FunctionDeclaration with a missing name.\n   */\n\n\n  NPp.needsParens = function (assumeExpressionContext) {\n    var pp = this.parentPath;\n\n    if (!pp) {\n      return false;\n    }\n\n    var node = this.value; // Only expressions need parentheses.\n\n    if (!n.Expression.check(node)) {\n      return false;\n    } // Identifiers never need parentheses.\n\n\n    if (node.type === \"Identifier\") {\n      return false;\n    }\n\n    while (!n.Node.check(pp.value)) {\n      pp = pp.parentPath;\n\n      if (!pp) {\n        return false;\n      }\n    }\n\n    var parent = pp.value;\n\n    switch (node.type) {\n      case \"UnaryExpression\":\n      case \"SpreadElement\":\n      case \"SpreadProperty\":\n        return parent.type === \"MemberExpression\" && this.name === \"object\" && parent.object === node;\n\n      case \"BinaryExpression\":\n      case \"LogicalExpression\":\n        switch (parent.type) {\n          case \"CallExpression\":\n            return this.name === \"callee\" && parent.callee === node;\n\n          case \"UnaryExpression\":\n          case \"SpreadElement\":\n          case \"SpreadProperty\":\n            return true;\n\n          case \"MemberExpression\":\n            return this.name === \"object\" && parent.object === node;\n\n          case \"BinaryExpression\":\n          case \"LogicalExpression\":\n            {\n              var n_1 = node;\n              var po = parent.operator;\n              var pp_1 = PRECEDENCE[po];\n              var no = n_1.operator;\n              var np = PRECEDENCE[no];\n\n              if (pp_1 > np) {\n                return true;\n              }\n\n              if (pp_1 === np && this.name === \"right\") {\n                if (parent.right !== n_1) {\n                  throw new Error(\"Nodes must be equal\");\n                }\n\n                return true;\n              }\n            }\n\n          default:\n            return false;\n        }\n\n      case \"SequenceExpression\":\n        switch (parent.type) {\n          case \"ForStatement\":\n            // Although parentheses wouldn't hurt around sequence\n            // expressions in the head of for loops, traditional style\n            // dictates that e.g. i++, j++ should not be wrapped with\n            // parentheses.\n            return false;\n\n          case \"ExpressionStatement\":\n            return this.name !== \"expression\";\n\n          default:\n            // Otherwise err on the side of overparenthesization, adding\n            // explicit exceptions above if this proves overzealous.\n            return true;\n        }\n\n      case \"YieldExpression\":\n        switch (parent.type) {\n          case \"BinaryExpression\":\n          case \"LogicalExpression\":\n          case \"UnaryExpression\":\n          case \"SpreadElement\":\n          case \"SpreadProperty\":\n          case \"CallExpression\":\n          case \"MemberExpression\":\n          case \"NewExpression\":\n          case \"ConditionalExpression\":\n          case \"YieldExpression\":\n            return true;\n\n          default:\n            return false;\n        }\n\n      case \"Literal\":\n        return parent.type === \"MemberExpression\" && isNumber.check(node.value) && this.name === \"object\" && parent.object === node;\n\n      case \"AssignmentExpression\":\n      case \"ConditionalExpression\":\n        switch (parent.type) {\n          case \"UnaryExpression\":\n          case \"SpreadElement\":\n          case \"SpreadProperty\":\n          case \"BinaryExpression\":\n          case \"LogicalExpression\":\n            return true;\n\n          case \"CallExpression\":\n            return this.name === \"callee\" && parent.callee === node;\n\n          case \"ConditionalExpression\":\n            return this.name === \"test\" && parent.test === node;\n\n          case \"MemberExpression\":\n            return this.name === \"object\" && parent.object === node;\n\n          default:\n            return false;\n        }\n\n      default:\n        if (parent.type === \"NewExpression\" && this.name === \"callee\" && parent.callee === node) {\n          return containsCallExpression(node);\n        }\n\n    }\n\n    if (assumeExpressionContext !== true && !this.canBeFirstInStatement() && this.firstInStatement()) return true;\n    return false;\n  };\n\n  function isBinary(node) {\n    return n.BinaryExpression.check(node) || n.LogicalExpression.check(node);\n  } // @ts-ignore 'isUnaryLike' is declared but its value is never read. [6133]\n\n\n  function isUnaryLike(node) {\n    return n.UnaryExpression.check(node) // I considered making SpreadElement and SpreadProperty subtypes\n    // of UnaryExpression, but they're not really Expression nodes.\n    || n.SpreadElement && n.SpreadElement.check(node) || n.SpreadProperty && n.SpreadProperty.check(node);\n  }\n\n  var PRECEDENCE = {};\n  [[\"||\"], [\"&&\"], [\"|\"], [\"^\"], [\"&\"], [\"==\", \"===\", \"!=\", \"!==\"], [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"], [\">>\", \"<<\", \">>>\"], [\"+\", \"-\"], [\"*\", \"/\", \"%\"]].forEach(function (tier, i) {\n    tier.forEach(function (op) {\n      PRECEDENCE[op] = i;\n    });\n  });\n\n  function containsCallExpression(node) {\n    if (n.CallExpression.check(node)) {\n      return true;\n    }\n\n    if (isArray.check(node)) {\n      return node.some(containsCallExpression);\n    }\n\n    if (n.Node.check(node)) {\n      return types.someField(node, function (_name, child) {\n        return containsCallExpression(child);\n      });\n    }\n\n    return false;\n  }\n\n  NPp.canBeFirstInStatement = function () {\n    var node = this.node;\n    return !n.FunctionExpression.check(node) && !n.ObjectExpression.check(node);\n  };\n\n  NPp.firstInStatement = function () {\n    return firstInStatement(this);\n  };\n\n  function firstInStatement(path) {\n    for (var node, parent; path.parent; path = path.parent) {\n      node = path.node;\n      parent = path.parent.node;\n\n      if (n.BlockStatement.check(parent) && path.parent.name === \"body\" && path.name === 0) {\n        if (parent.body[0] !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n\n        return true;\n      }\n\n      if (n.ExpressionStatement.check(parent) && path.name === \"expression\") {\n        if (parent.expression !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n\n        return true;\n      }\n\n      if (n.SequenceExpression.check(parent) && path.parent.name === \"expressions\" && path.name === 0) {\n        if (parent.expressions[0] !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n\n        continue;\n      }\n\n      if (n.CallExpression.check(parent) && path.name === \"callee\") {\n        if (parent.callee !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n\n        continue;\n      }\n\n      if (n.MemberExpression.check(parent) && path.name === \"object\") {\n        if (parent.object !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n\n        continue;\n      }\n\n      if (n.ConditionalExpression.check(parent) && path.name === \"test\") {\n        if (parent.test !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n\n        continue;\n      }\n\n      if (isBinary(parent) && path.name === \"left\") {\n        if (parent.left !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n\n        continue;\n      }\n\n      if (n.UnaryExpression.check(parent) && !parent.prefix && path.name === \"argument\") {\n        if (parent.argument !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n\n        continue;\n      }\n\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * Pruning certain nodes will result in empty or incomplete nodes, here we clean those nodes up.\n   */\n\n\n  function cleanUpNodesAfterPrune(remainingNodePath) {\n    if (n.VariableDeclaration.check(remainingNodePath.node)) {\n      var declarations = remainingNodePath.get('declarations').value;\n\n      if (!declarations || declarations.length === 0) {\n        return remainingNodePath.prune();\n      }\n    } else if (n.ExpressionStatement.check(remainingNodePath.node)) {\n      if (!remainingNodePath.get('expression').value) {\n        return remainingNodePath.prune();\n      }\n    } else if (n.IfStatement.check(remainingNodePath.node)) {\n      cleanUpIfStatementAfterPrune(remainingNodePath);\n    }\n\n    return remainingNodePath;\n  }\n\n  function cleanUpIfStatementAfterPrune(ifStatement) {\n    var testExpression = ifStatement.get('test').value;\n    var alternate = ifStatement.get('alternate').value;\n    var consequent = ifStatement.get('consequent').value;\n\n    if (!consequent && !alternate) {\n      var testExpressionStatement = b.expressionStatement(testExpression);\n      ifStatement.replace(testExpressionStatement);\n    } else if (!consequent && alternate) {\n      var negatedTestExpression = b.unaryExpression('!', testExpression, true);\n\n      if (n.UnaryExpression.check(testExpression) && testExpression.operator === '!') {\n        negatedTestExpression = testExpression.argument;\n      }\n\n      ifStatement.get(\"test\").replace(negatedTestExpression);\n      ifStatement.get(\"consequent\").replace(alternate);\n      ifStatement.get(\"alternate\").replace();\n    }\n  }\n\n  return NodePath;\n}\n\nexports.default = nodePathPlugin;\nmodule.exports = exports[\"default\"];","map":{"version":3,"names":["Object","defineProperty","exports","value","tslib_1","require","types_1","__importDefault","path_1","scope_1","nodePathPlugin","fork","types","use","default","n","namedTypes","b","builders","isNumber","builtInTypes","number","isArray","array","Path","Scope","NodePath","parentPath","name","Error","call","NPp","prototype","create","constructor","enumerable","writable","configurable","defineProperties","node","get","_computeNode","parent","_computeParent","scope","_computeScope","replace","apply","arguments","prune","remainingNodePath","cleanUpNodesAfterPrune","Node","check","pp","isEstablishedBy","getValueProperty","getFieldValue","needsParens","assumeExpressionContext","Expression","type","object","callee","n_1","po","operator","pp_1","PRECEDENCE","no","np","right","test","containsCallExpression","canBeFirstInStatement","firstInStatement","isBinary","BinaryExpression","LogicalExpression","isUnaryLike","UnaryExpression","SpreadElement","SpreadProperty","forEach","tier","i","op","CallExpression","some","someField","_name","child","FunctionExpression","ObjectExpression","path","BlockStatement","body","ExpressionStatement","expression","SequenceExpression","expressions","MemberExpression","ConditionalExpression","left","prefix","argument","VariableDeclaration","declarations","length","IfStatement","cleanUpIfStatementAfterPrune","ifStatement","testExpression","alternate","consequent","testExpressionStatement","expressionStatement","negatedTestExpression","unaryExpression","module"],"sources":["C:/Users/bryan/Desktop/myrepresentatives/frontend/node_modules/ast-types/lib/node-path.js"],"sourcesContent":["\"use strict\";;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar types_1 = tslib_1.__importDefault(require(\"./types\"));\nvar path_1 = tslib_1.__importDefault(require(\"./path\"));\nvar scope_1 = tslib_1.__importDefault(require(\"./scope\"));\nfunction nodePathPlugin(fork) {\n    var types = fork.use(types_1.default);\n    var n = types.namedTypes;\n    var b = types.builders;\n    var isNumber = types.builtInTypes.number;\n    var isArray = types.builtInTypes.array;\n    var Path = fork.use(path_1.default);\n    var Scope = fork.use(scope_1.default);\n    var NodePath = function NodePath(value, parentPath, name) {\n        if (!(this instanceof NodePath)) {\n            throw new Error(\"NodePath constructor cannot be invoked without 'new'\");\n        }\n        Path.call(this, value, parentPath, name);\n    };\n    var NPp = NodePath.prototype = Object.create(Path.prototype, {\n        constructor: {\n            value: NodePath,\n            enumerable: false,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperties(NPp, {\n        node: {\n            get: function () {\n                Object.defineProperty(this, \"node\", {\n                    configurable: true,\n                    value: this._computeNode()\n                });\n                return this.node;\n            }\n        },\n        parent: {\n            get: function () {\n                Object.defineProperty(this, \"parent\", {\n                    configurable: true,\n                    value: this._computeParent()\n                });\n                return this.parent;\n            }\n        },\n        scope: {\n            get: function () {\n                Object.defineProperty(this, \"scope\", {\n                    configurable: true,\n                    value: this._computeScope()\n                });\n                return this.scope;\n            }\n        }\n    });\n    NPp.replace = function () {\n        delete this.node;\n        delete this.parent;\n        delete this.scope;\n        return Path.prototype.replace.apply(this, arguments);\n    };\n    NPp.prune = function () {\n        var remainingNodePath = this.parent;\n        this.replace();\n        return cleanUpNodesAfterPrune(remainingNodePath);\n    };\n    // The value of the first ancestor Path whose value is a Node.\n    NPp._computeNode = function () {\n        var value = this.value;\n        if (n.Node.check(value)) {\n            return value;\n        }\n        var pp = this.parentPath;\n        return pp && pp.node || null;\n    };\n    // The first ancestor Path whose value is a Node distinct from this.node.\n    NPp._computeParent = function () {\n        var value = this.value;\n        var pp = this.parentPath;\n        if (!n.Node.check(value)) {\n            while (pp && !n.Node.check(pp.value)) {\n                pp = pp.parentPath;\n            }\n            if (pp) {\n                pp = pp.parentPath;\n            }\n        }\n        while (pp && !n.Node.check(pp.value)) {\n            pp = pp.parentPath;\n        }\n        return pp || null;\n    };\n    // The closest enclosing scope that governs this node.\n    NPp._computeScope = function () {\n        var value = this.value;\n        var pp = this.parentPath;\n        var scope = pp && pp.scope;\n        if (n.Node.check(value) &&\n            Scope.isEstablishedBy(value)) {\n            scope = new Scope(this, scope);\n        }\n        return scope || null;\n    };\n    NPp.getValueProperty = function (name) {\n        return types.getFieldValue(this.value, name);\n    };\n    /**\n     * Determine whether this.node needs to be wrapped in parentheses in order\n     * for a parser to reproduce the same local AST structure.\n     *\n     * For instance, in the expression `(1 + 2) * 3`, the BinaryExpression\n     * whose operator is \"+\" needs parentheses, because `1 + 2 * 3` would\n     * parse differently.\n     *\n     * If assumeExpressionContext === true, we don't worry about edge cases\n     * like an anonymous FunctionExpression appearing lexically first in its\n     * enclosing statement and thus needing parentheses to avoid being parsed\n     * as a FunctionDeclaration with a missing name.\n     */\n    NPp.needsParens = function (assumeExpressionContext) {\n        var pp = this.parentPath;\n        if (!pp) {\n            return false;\n        }\n        var node = this.value;\n        // Only expressions need parentheses.\n        if (!n.Expression.check(node)) {\n            return false;\n        }\n        // Identifiers never need parentheses.\n        if (node.type === \"Identifier\") {\n            return false;\n        }\n        while (!n.Node.check(pp.value)) {\n            pp = pp.parentPath;\n            if (!pp) {\n                return false;\n            }\n        }\n        var parent = pp.value;\n        switch (node.type) {\n            case \"UnaryExpression\":\n            case \"SpreadElement\":\n            case \"SpreadProperty\":\n                return parent.type === \"MemberExpression\"\n                    && this.name === \"object\"\n                    && parent.object === node;\n            case \"BinaryExpression\":\n            case \"LogicalExpression\":\n                switch (parent.type) {\n                    case \"CallExpression\":\n                        return this.name === \"callee\"\n                            && parent.callee === node;\n                    case \"UnaryExpression\":\n                    case \"SpreadElement\":\n                    case \"SpreadProperty\":\n                        return true;\n                    case \"MemberExpression\":\n                        return this.name === \"object\"\n                            && parent.object === node;\n                    case \"BinaryExpression\":\n                    case \"LogicalExpression\": {\n                        var n_1 = node;\n                        var po = parent.operator;\n                        var pp_1 = PRECEDENCE[po];\n                        var no = n_1.operator;\n                        var np = PRECEDENCE[no];\n                        if (pp_1 > np) {\n                            return true;\n                        }\n                        if (pp_1 === np && this.name === \"right\") {\n                            if (parent.right !== n_1) {\n                                throw new Error(\"Nodes must be equal\");\n                            }\n                            return true;\n                        }\n                    }\n                    default:\n                        return false;\n                }\n            case \"SequenceExpression\":\n                switch (parent.type) {\n                    case \"ForStatement\":\n                        // Although parentheses wouldn't hurt around sequence\n                        // expressions in the head of for loops, traditional style\n                        // dictates that e.g. i++, j++ should not be wrapped with\n                        // parentheses.\n                        return false;\n                    case \"ExpressionStatement\":\n                        return this.name !== \"expression\";\n                    default:\n                        // Otherwise err on the side of overparenthesization, adding\n                        // explicit exceptions above if this proves overzealous.\n                        return true;\n                }\n            case \"YieldExpression\":\n                switch (parent.type) {\n                    case \"BinaryExpression\":\n                    case \"LogicalExpression\":\n                    case \"UnaryExpression\":\n                    case \"SpreadElement\":\n                    case \"SpreadProperty\":\n                    case \"CallExpression\":\n                    case \"MemberExpression\":\n                    case \"NewExpression\":\n                    case \"ConditionalExpression\":\n                    case \"YieldExpression\":\n                        return true;\n                    default:\n                        return false;\n                }\n            case \"Literal\":\n                return parent.type === \"MemberExpression\"\n                    && isNumber.check(node.value)\n                    && this.name === \"object\"\n                    && parent.object === node;\n            case \"AssignmentExpression\":\n            case \"ConditionalExpression\":\n                switch (parent.type) {\n                    case \"UnaryExpression\":\n                    case \"SpreadElement\":\n                    case \"SpreadProperty\":\n                    case \"BinaryExpression\":\n                    case \"LogicalExpression\":\n                        return true;\n                    case \"CallExpression\":\n                        return this.name === \"callee\"\n                            && parent.callee === node;\n                    case \"ConditionalExpression\":\n                        return this.name === \"test\"\n                            && parent.test === node;\n                    case \"MemberExpression\":\n                        return this.name === \"object\"\n                            && parent.object === node;\n                    default:\n                        return false;\n                }\n            default:\n                if (parent.type === \"NewExpression\" &&\n                    this.name === \"callee\" &&\n                    parent.callee === node) {\n                    return containsCallExpression(node);\n                }\n        }\n        if (assumeExpressionContext !== true &&\n            !this.canBeFirstInStatement() &&\n            this.firstInStatement())\n            return true;\n        return false;\n    };\n    function isBinary(node) {\n        return n.BinaryExpression.check(node)\n            || n.LogicalExpression.check(node);\n    }\n    // @ts-ignore 'isUnaryLike' is declared but its value is never read. [6133]\n    function isUnaryLike(node) {\n        return n.UnaryExpression.check(node)\n            // I considered making SpreadElement and SpreadProperty subtypes\n            // of UnaryExpression, but they're not really Expression nodes.\n            || (n.SpreadElement && n.SpreadElement.check(node))\n            || (n.SpreadProperty && n.SpreadProperty.check(node));\n    }\n    var PRECEDENCE = {};\n    [[\"||\"],\n        [\"&&\"],\n        [\"|\"],\n        [\"^\"],\n        [\"&\"],\n        [\"==\", \"===\", \"!=\", \"!==\"],\n        [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"],\n        [\">>\", \"<<\", \">>>\"],\n        [\"+\", \"-\"],\n        [\"*\", \"/\", \"%\"]\n    ].forEach(function (tier, i) {\n        tier.forEach(function (op) {\n            PRECEDENCE[op] = i;\n        });\n    });\n    function containsCallExpression(node) {\n        if (n.CallExpression.check(node)) {\n            return true;\n        }\n        if (isArray.check(node)) {\n            return node.some(containsCallExpression);\n        }\n        if (n.Node.check(node)) {\n            return types.someField(node, function (_name, child) {\n                return containsCallExpression(child);\n            });\n        }\n        return false;\n    }\n    NPp.canBeFirstInStatement = function () {\n        var node = this.node;\n        return !n.FunctionExpression.check(node)\n            && !n.ObjectExpression.check(node);\n    };\n    NPp.firstInStatement = function () {\n        return firstInStatement(this);\n    };\n    function firstInStatement(path) {\n        for (var node, parent; path.parent; path = path.parent) {\n            node = path.node;\n            parent = path.parent.node;\n            if (n.BlockStatement.check(parent) &&\n                path.parent.name === \"body\" &&\n                path.name === 0) {\n                if (parent.body[0] !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                return true;\n            }\n            if (n.ExpressionStatement.check(parent) &&\n                path.name === \"expression\") {\n                if (parent.expression !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                return true;\n            }\n            if (n.SequenceExpression.check(parent) &&\n                path.parent.name === \"expressions\" &&\n                path.name === 0) {\n                if (parent.expressions[0] !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                continue;\n            }\n            if (n.CallExpression.check(parent) &&\n                path.name === \"callee\") {\n                if (parent.callee !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                continue;\n            }\n            if (n.MemberExpression.check(parent) &&\n                path.name === \"object\") {\n                if (parent.object !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                continue;\n            }\n            if (n.ConditionalExpression.check(parent) &&\n                path.name === \"test\") {\n                if (parent.test !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                continue;\n            }\n            if (isBinary(parent) &&\n                path.name === \"left\") {\n                if (parent.left !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                continue;\n            }\n            if (n.UnaryExpression.check(parent) &&\n                !parent.prefix &&\n                path.name === \"argument\") {\n                if (parent.argument !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                continue;\n            }\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Pruning certain nodes will result in empty or incomplete nodes, here we clean those nodes up.\n     */\n    function cleanUpNodesAfterPrune(remainingNodePath) {\n        if (n.VariableDeclaration.check(remainingNodePath.node)) {\n            var declarations = remainingNodePath.get('declarations').value;\n            if (!declarations || declarations.length === 0) {\n                return remainingNodePath.prune();\n            }\n        }\n        else if (n.ExpressionStatement.check(remainingNodePath.node)) {\n            if (!remainingNodePath.get('expression').value) {\n                return remainingNodePath.prune();\n            }\n        }\n        else if (n.IfStatement.check(remainingNodePath.node)) {\n            cleanUpIfStatementAfterPrune(remainingNodePath);\n        }\n        return remainingNodePath;\n    }\n    function cleanUpIfStatementAfterPrune(ifStatement) {\n        var testExpression = ifStatement.get('test').value;\n        var alternate = ifStatement.get('alternate').value;\n        var consequent = ifStatement.get('consequent').value;\n        if (!consequent && !alternate) {\n            var testExpressionStatement = b.expressionStatement(testExpression);\n            ifStatement.replace(testExpressionStatement);\n        }\n        else if (!consequent && alternate) {\n            var negatedTestExpression = b.unaryExpression('!', testExpression, true);\n            if (n.UnaryExpression.check(testExpression) && testExpression.operator === '!') {\n                negatedTestExpression = testExpression.argument;\n            }\n            ifStatement.get(\"test\").replace(negatedTestExpression);\n            ifStatement.get(\"consequent\").replace(alternate);\n            ifStatement.get(\"alternate\").replace();\n        }\n    }\n    return NodePath;\n}\nexports.default = nodePathPlugin;\nmodule.exports = exports[\"default\"];\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}