{"ast":null,"code":"'use strict';\n\nvar debug = require('debug')('urllib');\n\nvar path = require('path');\n\nvar dns = require('dns');\n\nvar http = require('http');\n\nvar https = require('https');\n\nvar urlutil = require('url');\n\nvar URL = urlutil.URL;\n\nvar util = require('util');\n\nvar qs = require('qs');\n\nvar ip = require('ip');\n\nvar querystring = require('querystring');\n\nvar zlib = require('zlib');\n\nvar ua = require('default-user-agent');\n\nvar digestAuthHeader = require('digest-header');\n\nvar ms = require('humanize-ms');\n\nvar statuses = require('statuses');\n\nvar contentTypeParser = require('content-type');\n\nvar first = require('ee-first');\n\nvar pump = require('pump');\n\nvar utility = require('utility');\n\nvar FormStream = require('formstream');\n\nvar detectProxyAgent = require('./detect_proxy_agent');\n\nvar _Promise;\n\nvar _iconv;\n\nvar pkg = require('../package.json');\n\nvar USER_AGENT = exports.USER_AGENT = ua('node-urllib', pkg.version);\nvar NODE_MAJOR_VERSION = parseInt(process.versions.node.split('.')[0]); // change Agent.maxSockets to 1000\n\nexports.agent = new http.Agent();\nexports.agent.maxSockets = 1000;\nexports.httpsAgent = new https.Agent();\nexports.httpsAgent.maxSockets = 1000;\nvar LONG_STACK_DELIMITER = '\\n    --------------------\\n';\n/**\n * The default request timeout(in milliseconds).\n * @type {Number}\n * @const\n */\n\nexports.TIMEOUT = ms('5s');\nexports.TIMEOUTS = [ms('5s'), ms('5s')];\nvar REQUEST_ID = 0;\nvar MAX_VALUE = Math.pow(2, 31) - 10;\nvar isNode010 = /^v0\\.10\\.\\d+$/.test(process.version);\nvar isNode012 = /^v0\\.12\\.\\d+$/.test(process.version);\n/**\n * support data types\n * will auto decode response body\n * @type {Array}\n */\n\nvar TEXT_DATA_TYPES = ['json', 'text'];\nvar PROTO_RE = /^https?:\\/\\//i; // Keep-Alive: timeout=5, max=100\n\nvar KEEP_ALIVE_RE = /^timeout=(\\d+)/i;\nvar SOCKET_REQUEST_COUNT = '_URLLIB_SOCKET_REQUEST_COUNT';\nvar SOCKET_RESPONSE_COUNT = '_URLLIB_SOCKET_RESPONSE_COUNT';\n/**\n * Handle all http request, both http and https support well.\n *\n * @example\n *\n * ```js\n * // GET https://nodejs.org\n * urllib.request('https://nodejs.org', function(err, data, res) {});\n * // POST https://nodejs.org\n * var args = { type: 'post', data: { foo: 'bar' } };\n * urllib.request('https://nodejs.org', args, function(err, data, res) {});\n * ```\n *\n * @param {String|Object} url: the request full URL.\n * @param {Object} [args]: optional\n *   - {Object} [data]: request data, will auto be query stringify.\n *   - {Boolean} [dataAsQueryString]: force convert `data` to query string.\n *   - {String|Buffer} [content]: optional, if set content, `data` will ignore.\n *   - {ReadStream} [stream]: read stream to sent.\n *   - {WriteStream} [writeStream]: writable stream to save response data.\n *       If you use this, callback's data should be null.\n *       We will just `pipe(ws, {end: true})`.\n *   - {consumeWriteStream} [true]: consume the writeStream, invoke the callback after writeStream close.\n *   - {Array<ReadStream|Buffer|String>|Object|ReadStream|Buffer|String} [files]: optional,\n *       The files will send with `multipart/form-data` format, base on `formstream`.\n *       If `method` not set, will use `POST` method by default.\n *   - {String} [method]: optional, could be GET | POST | DELETE | PUT, default is GET\n *   - {String} [contentType]: optional, request data type, could be `json`, default is undefined\n *   - {String} [dataType]: optional, response data type, could be `text` or `json`, default is buffer\n *   - {Boolean|Function} [fixJSONCtlChars]: optional, fix the control characters (U+0000 through U+001F)\n *       before JSON parse response. Default is `false`.\n *       `fixJSONCtlChars` can be a function, will pass data to the first argument. e.g.: `data = fixJSONCtlChars(data)`\n *   - {Object} [headers]: optional, request headers\n *   - {Boolean} [keepHeaderCase]: optional, by default will convert header keys to lowercase\n *   - {Number|Array} [timeout]: request timeout(in milliseconds), default is `exports.TIMEOUTS containing connect timeout and response timeout`\n *   - {Agent} [agent]: optional, http agent. Set `false` if you does not use agent.\n *   - {Agent} [httpsAgent]: optional, https agent. Set `false` if you does not use agent.\n *   - {String} [auth]: Basic authentication i.e. 'user:password' to compute an Authorization header.\n *   - {String} [digestAuth]: Digest authentication i.e. 'user:password' to compute an Authorization header.\n *   - {String|Buffer|Array} [ca]: An array of strings or Buffers of trusted certificates.\n *       If this is omitted several well known \"root\" CAs will be used, like VeriSign.\n *       These are used to authorize connections.\n *       Notes: This is necessary only if the server uses the self-signed certificate\n *   - {Boolean} [rejectUnauthorized]: If true, the server certificate is verified against the list of supplied CAs.\n *       An 'error' event is emitted if verification fails. Default: true.\n *   - {String|Buffer} [pfx]: A string or Buffer containing the private key,\n *       certificate and CA certs of the server in PFX or PKCS12 format.\n *   - {String|Buffer} [key]: A string or Buffer containing the private key of the client in PEM format.\n *       Notes: This is necessary only if using the client certificate authentication\n *   - {String|Buffer} [cert]: A string or Buffer containing the certificate key of the client in PEM format.\n *       Notes: This is necessary only if using the client certificate authentication\n *   - {String} [passphrase]: A string of passphrase for the private key or pfx.\n *   - {String} [ciphers]: A string describing the ciphers to use or exclude.\n *   - {String} [secureProtocol]: The SSL method to use, e.g. SSLv3_method to force SSL version 3.\n *       The possible values depend on your installation of OpenSSL and are defined in the constant SSL_METHODS.\n *   - {Boolean} [followRedirect]: Follow HTTP 3xx responses as redirects. defaults to false.\n *   - {Number} [maxRedirects]: The maximum number of redirects to follow, defaults to 10.\n *   - {Function(from, to)} [formatRedirectUrl]: Format the redirect url by your self. Default is `url.resolve(from, to)`\n *   - {Function(options)} [beforeRequest]: Before request hook, you can change every thing here.\n *   - {Boolean} [streaming]: let you get the res object when request connected, default is `false`. alias `customResponse`\n *   - {Boolean} [gzip]: Accept gzip response content and auto decode it, default is `false`.\n *   - {Boolean} [timing]: Enable timing or not, default is `false`.\n *   - {Function} [lookup]: Custom DNS lookup function, default is `dns.lookup`.\n *       Require node >= 4.0.0 and only work on `http` protocol.\n *   - {Boolean} [enableProxy]: optional, enable proxy request. Default is `false`.\n *   - {String|Object} [proxy]: optional proxy agent uri or options. Default is `null`.\n *   - {String} [socketPath]: optional, unix domain socket file path.\n *   - {Function} checkAddress: optional, check request address to protect from SSRF and similar attacks.\n * @param {Function} [callback]: callback(error, data, res). If missing callback, will return a promise object.\n * @return {HttpRequest} req object.\n * @api public\n */\n\nexports.request = function request(url, args, callback) {\n  // request(url, callback)\n  if (arguments.length === 2 && typeof args === 'function') {\n    callback = args;\n    args = null;\n  }\n\n  if (typeof callback === 'function') {\n    return exports.requestWithCallback(url, args, callback);\n  } // Promise\n\n\n  if (!_Promise) {\n    _Promise = require('any-promise');\n  }\n\n  return new _Promise(function (resolve, reject) {\n    exports.requestWithCallback(url, args, makeCallback(resolve, reject));\n  });\n}; // alias to curl\n\n\nexports.curl = exports.request;\n\nfunction makeCallback(resolve, reject) {\n  return function (err, data, res) {\n    if (err) {\n      return reject(err);\n    }\n\n    resolve({\n      data: data,\n      status: res.statusCode,\n      headers: res.headers,\n      res: res\n    });\n  };\n} // yield urllib.requestThunk(url, args)\n\n\nexports.requestThunk = function requestThunk(url, args) {\n  return function (callback) {\n    exports.requestWithCallback(url, args, function (err, data, res) {\n      if (err) {\n        return callback(err);\n      }\n\n      callback(null, {\n        data: data,\n        status: res.statusCode,\n        headers: res.headers,\n        res: res\n      });\n    });\n  };\n};\n\nfunction requestWithCallback(url, args, callback) {\n  var req; // requestWithCallback(url, callback)\n\n  if (!url || typeof url !== 'string' && typeof url !== 'object') {\n    var msg = util.format('expect request url to be a string or a http request options, but got %j', url);\n    throw new Error(msg);\n  }\n\n  if (arguments.length === 2 && typeof args === 'function') {\n    callback = args;\n    args = null;\n  }\n\n  args = args || {};\n\n  if (REQUEST_ID >= MAX_VALUE) {\n    REQUEST_ID = 0;\n  }\n\n  var reqId = ++REQUEST_ID;\n  args.requestUrls = args.requestUrls || [];\n  args.timeout = args.timeout || exports.TIMEOUTS;\n  args.maxRedirects = args.maxRedirects || 10;\n  args.streaming = args.streaming || args.customResponse;\n  var requestStartTime = Date.now();\n  var parsedUrl;\n\n  if (typeof url === 'string') {\n    if (!PROTO_RE.test(url)) {\n      // Support `request('www.server.com')`\n      url = 'http://' + url;\n    }\n\n    if (URL) {\n      parsedUrl = urlutil.parse(new URL(url).href);\n    } else {\n      parsedUrl = urlutil.parse(url);\n    }\n  } else {\n    parsedUrl = url;\n  }\n\n  var reqMeta = {\n    requestId: reqId,\n    url: parsedUrl.href,\n    args: args,\n    ctx: args.ctx\n  };\n\n  if (args.emitter) {\n    args.emitter.emit('request', reqMeta);\n  }\n\n  var method = (args.type || args.method || parsedUrl.method || 'GET').toUpperCase();\n  var port = parsedUrl.port || 80;\n  var httplib = http;\n  var agent = getAgent(args.agent, exports.agent);\n  var fixJSONCtlChars = args.fixJSONCtlChars;\n\n  if (parsedUrl.protocol === 'https:') {\n    httplib = https;\n    agent = getAgent(args.httpsAgent, exports.httpsAgent);\n\n    if (!parsedUrl.port) {\n      port = 443;\n    }\n  } // request through proxy tunnel\n\n\n  var proxyTunnelAgent = detectProxyAgent(parsedUrl, args);\n\n  if (proxyTunnelAgent) {\n    agent = proxyTunnelAgent;\n  }\n\n  var lookup = args.lookup; // check address to protect from SSRF and similar attacks\n\n  if (args.checkAddress) {\n    var _lookup = lookup || dns.lookup;\n\n    lookup = function (host, dnsopts, callback) {\n      _lookup(host, dnsopts, function emitLookup(err, ip, family) {\n        // add check address logic in custom dns lookup\n        if (!err && !args.checkAddress(ip, family)) {\n          err = new Error('illegal address');\n          err.name = 'IllegalAddressError';\n          err.hostname = host;\n          err.ip = ip;\n          err.family = family;\n        }\n\n        callback(err, ip, family);\n      });\n    };\n  }\n\n  var requestSize = 0;\n  var options = {\n    host: parsedUrl.hostname || parsedUrl.host || 'localhost',\n    path: parsedUrl.path || '/',\n    method: method,\n    port: port,\n    agent: agent,\n    headers: {},\n    // default is dns.lookup\n    // https://github.com/nodejs/node/blob/master/lib/net.js#L986\n    // custom dnslookup require node >= 4.0.0 (for http), node >=8 (for https)\n    // https://github.com/nodejs/node/blob/archived-io.js-v0.12/lib/net.js#L952\n    lookup: lookup\n  };\n  var originHeaderKeys = {};\n\n  if (args.headers) {\n    // only allow enumerable and ownProperty value of args.headers\n    var names = utility.getOwnEnumerables(args.headers, true);\n\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i];\n      var key = name.toLowerCase();\n\n      if (key !== name) {\n        originHeaderKeys[key] = name;\n      }\n\n      options.headers[key] = args.headers[name];\n    }\n  }\n\n  if (args.socketPath) {\n    options.socketPath = args.socketPath;\n  }\n\n  var sslNames = ['pfx', 'key', 'passphrase', 'cert', 'ca', 'ciphers', 'rejectUnauthorized', 'secureProtocol', 'secureOptions'];\n\n  for (var i = 0; i < sslNames.length; i++) {\n    var name = sslNames[i];\n\n    if (args.hasOwnProperty(name)) {\n      options[name] = args[name];\n    }\n  } // fix rejectUnauthorized when major version < 12\n\n\n  if (NODE_MAJOR_VERSION < 12) {\n    if (options.rejectUnauthorized === false && !options.hasOwnProperty('secureOptions')) {\n      options.secureOptions = require('constants').SSL_OP_NO_TLSv1_2;\n    }\n  }\n\n  var auth = args.auth || parsedUrl.auth;\n\n  if (auth) {\n    options.auth = auth;\n  }\n\n  var body = null;\n  var dataAsQueryString = false;\n\n  if (args.files) {\n    if (!options.method || options.method === 'GET' || options.method === 'HEAD') {\n      options.method = 'POST';\n    }\n\n    var files = args.files;\n    var uploadFiles = [];\n\n    if (Array.isArray(files)) {\n      for (var i = 0; i < files.length; i++) {\n        var field = 'file' + (i === 0 ? '' : i);\n        uploadFiles.push([field, files[i]]);\n      }\n    } else {\n      if (Buffer.isBuffer(files) || typeof files.pipe === 'function' || typeof files === 'string') {\n        uploadFiles.push(['file', files]);\n      } else if (typeof files === 'object') {\n        for (var field in files) {\n          uploadFiles.push([field, files[field]]);\n        }\n      }\n    }\n\n    var form = new FormStream(); // set normal fields first\n\n    if (args.data) {\n      for (var fieldName in args.data) {\n        form.field(fieldName, args.data[fieldName]);\n      }\n    }\n\n    for (var i = 0; i < uploadFiles.length; i++) {\n      var item = uploadFiles[i];\n\n      if (Buffer.isBuffer(item[1])) {\n        form.buffer(item[0], item[1], 'bufferfile' + i);\n      } else if (typeof item[1].pipe === 'function') {\n        var filename = item[1].path || 'streamfile' + i;\n        filename = path.basename(filename);\n        form.stream(item[0], item[1], filename);\n      } else {\n        form.file(item[0], item[1]);\n      }\n    }\n\n    var formHeaders = form.headers();\n    var formHeaderNames = utility.getOwnEnumerables(formHeaders, true);\n\n    for (var i = 0; i < formHeaderNames.length; i++) {\n      var name = formHeaderNames[i];\n      options.headers[name.toLowerCase()] = formHeaders[name];\n    }\n\n    debug('set multipart headers: %j, method: %s', formHeaders, options.method);\n    args.stream = form;\n  } else {\n    body = args.content || args.data;\n    dataAsQueryString = method === 'GET' || method === 'HEAD' || args.dataAsQueryString;\n\n    if (!args.content) {\n      if (body && !(typeof body === 'string' || Buffer.isBuffer(body))) {\n        if (dataAsQueryString) {\n          // read: GET, HEAD, use query string\n          body = args.nestedQuerystring ? qs.stringify(body) : querystring.stringify(body);\n        } else {\n          var contentType = options.headers['content-type']; // auto add application/x-www-form-urlencoded when using urlencode form request\n\n          if (!contentType) {\n            if (args.contentType === 'json') {\n              contentType = 'application/json';\n            } else {\n              contentType = 'application/x-www-form-urlencoded';\n            }\n\n            options.headers['content-type'] = contentType;\n          }\n\n          if (parseContentType(contentType).type === 'application/json') {\n            body = JSON.stringify(body);\n          } else {\n            // 'application/x-www-form-urlencoded'\n            body = args.nestedQuerystring ? qs.stringify(body) : querystring.stringify(body);\n          }\n        }\n      }\n    }\n  }\n\n  if (body) {\n    // if it's a GET or HEAD request, data should be sent as query string\n    if (dataAsQueryString) {\n      options.path += (parsedUrl.query ? '&' : '?') + body;\n      body = null;\n    }\n\n    if (body) {\n      var length = body.length;\n\n      if (!Buffer.isBuffer(body)) {\n        length = Buffer.byteLength(body);\n      }\n\n      requestSize = length;\n      options.headers['content-length'] = length.toString();\n    }\n  }\n\n  if (args.dataType === 'json') {\n    if (!options.headers.accept) {\n      options.headers.accept = 'application/json';\n    }\n  }\n\n  if (typeof args.beforeRequest === 'function') {\n    // you can use this hook to change every thing.\n    args.beforeRequest(options);\n  }\n\n  var connectTimer = null;\n  var responseTimer = null;\n  var __err = null;\n  var connected = false; // socket connected or not\n\n  var keepAliveSocket = false; // request with keepalive socket\n\n  var socketHandledRequests = 0; // socket already handled request count\n\n  var socketHandledResponses = 0; // socket already handled response count\n\n  var responseSize = 0;\n  var statusCode = -1;\n  var statusMessage = null;\n  var responseAborted = false;\n  var remoteAddress = '';\n  var remotePort = '';\n  var timing = null;\n\n  if (args.timing) {\n    timing = {\n      // socket assigned\n      queuing: 0,\n      // dns lookup time\n      dnslookup: 0,\n      // socket connected\n      connected: 0,\n      // request sent\n      requestSent: 0,\n      // Time to first byte (TTFB)\n      waiting: 0,\n      contentDownload: 0\n    };\n  }\n\n  function cancelConnectTimer() {\n    if (connectTimer) {\n      clearTimeout(connectTimer);\n      connectTimer = null;\n      debug('Request#%d connect timer canceled', reqId);\n    }\n  }\n\n  function cancelResponseTimer() {\n    if (responseTimer) {\n      clearTimeout(responseTimer);\n      responseTimer = null;\n      debug('Request#%d response timer canceled', reqId);\n    }\n  }\n\n  function done(err, data, res) {\n    cancelConnectTimer();\n    cancelResponseTimer();\n\n    if (!callback) {\n      console.warn('[urllib:warn] [%s] [%s] [worker:%s] %s %s callback twice!!!', Date(), reqId, process.pid, options.method, url); // https://github.com/node-modules/urllib/pull/30\n\n      if (err) {\n        console.warn('[urllib:warn] [%s] [%s] [worker:%s] %s: %s\\nstack: %s', Date(), reqId, process.pid, err.name, err.message, err.stack);\n      }\n\n      return;\n    }\n\n    var cb = callback;\n    callback = null;\n    var headers = {};\n\n    if (res) {\n      statusCode = res.statusCode;\n      statusMessage = res.statusMessage;\n      headers = res.headers;\n    }\n\n    if (handleDigestAuth(res, cb)) {\n      return;\n    }\n\n    var response = createCallbackResponse(data, res);\n    debug('[%sms] done, %s bytes HTTP %s %s %s %s, keepAliveSocket: %s, timing: %j, socketHandledRequests: %s, socketHandledResponses: %s', response.requestUseTime, responseSize, statusCode, options.method, options.host, options.path, keepAliveSocket, timing, socketHandledRequests, socketHandledResponses);\n\n    if (err) {\n      var agentStatus = '';\n\n      if (agent && typeof agent.getCurrentStatus === 'function') {\n        // add current agent status to error message for logging and debug\n        agentStatus = ', agent status: ' + JSON.stringify(agent.getCurrentStatus());\n      }\n\n      err.message += ', ' + options.method + ' ' + url + ' ' + statusCode + ' (connected: ' + connected + ', keepalive socket: ' + keepAliveSocket + agentStatus + ', socketHandledRequests: ' + socketHandledRequests + ', socketHandledResponses: ' + socketHandledResponses + ')' + '\\nheaders: ' + JSON.stringify(headers);\n      err.data = data;\n      err.path = options.path;\n      err.status = statusCode;\n      err.headers = headers;\n      err.res = response;\n      addLongStackTrace(err, req);\n    } // only support agentkeepalive module for now\n    // agentkeepalive@4: agent.options.freeSocketTimeout\n    // agentkeepalive@3: agent.freeSocketKeepAliveTimeout\n\n\n    var freeSocketTimeout = agent && (agent.options && agent.options.freeSocketTimeout || agent.freeSocketKeepAliveTimeout);\n\n    if (agent && agent.keepAlive && freeSocketTimeout > 0 && statusCode >= 200 && headers.connection === 'keep-alive' && headers['keep-alive']) {\n      // adjust freeSocketTimeout on the socket\n      var m = KEEP_ALIVE_RE.exec(headers['keep-alive']);\n\n      if (m) {\n        var seconds = parseInt(m[1]);\n\n        if (seconds > 0) {\n          // network delay 500ms\n          var serverSocketTimeout = seconds * 1000 - 500;\n\n          if (serverSocketTimeout < freeSocketTimeout) {\n            // https://github.com/node-modules/agentkeepalive/blob/master/lib/agent.js#L127\n            // agentkeepalive@4\n            var socket = res.socket || req && req.socket;\n\n            if (agent.options && agent.options.freeSocketTimeout) {\n              socket.freeSocketTimeout = serverSocketTimeout;\n            } else {\n              socket.freeSocketKeepAliveTimeout = serverSocketTimeout;\n            }\n          }\n        }\n      }\n    }\n\n    cb(err, data, args.streaming ? res : response);\n    emitResponseEvent(err, response);\n  }\n\n  function createAndEmitResponseEvent(data, res) {\n    var response = createCallbackResponse(data, res);\n    emitResponseEvent(null, response);\n  }\n\n  function createCallbackResponse(data, res) {\n    var requestUseTime = Date.now() - requestStartTime;\n\n    if (timing) {\n      timing.contentDownload = requestUseTime;\n    }\n\n    var headers = res && res.headers || {};\n    var resStatusCode = res && res.statusCode || statusCode;\n    var resStatusMessage = res && res.statusMessage || statusMessage;\n    return {\n      status: resStatusCode,\n      statusCode: resStatusCode,\n      statusMessage: resStatusMessage,\n      headers: headers,\n      size: responseSize,\n      aborted: responseAborted,\n      rt: requestUseTime,\n      keepAliveSocket: keepAliveSocket,\n      data: data,\n      requestUrls: args.requestUrls,\n      timing: timing,\n      remoteAddress: remoteAddress,\n      remotePort: remotePort,\n      socketHandledRequests: socketHandledRequests,\n      socketHandledResponses: socketHandledResponses\n    };\n  }\n\n  function emitResponseEvent(err, response) {\n    if (args.emitter) {\n      // keep to use the same reqMeta object on request event before\n      reqMeta.url = parsedUrl.href;\n      reqMeta.socket = req && req.connection;\n      reqMeta.options = options;\n      reqMeta.size = requestSize;\n      args.emitter.emit('response', {\n        requestId: reqId,\n        error: err,\n        ctx: args.ctx,\n        req: reqMeta,\n        res: response\n      });\n    }\n  }\n\n  function handleDigestAuth(res, cb) {\n    var headers = {};\n\n    if (res && res.headers) {\n      headers = res.headers;\n    } // handle digest auth\n\n\n    if (statusCode === 401 && headers['www-authenticate'] && !options.headers.authorization && args.digestAuth) {\n      var authenticate = headers['www-authenticate'];\n\n      if (authenticate.indexOf('Digest ') >= 0) {\n        debug('Request#%d %s: got digest auth header WWW-Authenticate: %s', reqId, url, authenticate);\n        options.headers.authorization = digestAuthHeader(options.method, options.path, authenticate, args.digestAuth);\n        debug('Request#%d %s: auth with digest header: %s', reqId, url, options.headers.authorization);\n\n        if (res.headers['set-cookie']) {\n          options.headers.cookie = res.headers['set-cookie'].join(';');\n        }\n\n        args.headers = options.headers;\n        exports.requestWithCallback(url, args, cb);\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function handleRedirect(res) {\n    var err = null;\n\n    if (args.followRedirect && statuses.redirect[res.statusCode]) {\n      // handle redirect\n      args._followRedirectCount = (args._followRedirectCount || 0) + 1;\n      var location = res.headers.location;\n\n      if (!location) {\n        err = new Error('Got statusCode ' + res.statusCode + ' but cannot resolve next location from headers');\n        err.name = 'FollowRedirectError';\n      } else if (args._followRedirectCount > args.maxRedirects) {\n        err = new Error('Exceeded maxRedirects. Probably stuck in a redirect loop ' + url);\n        err.name = 'MaxRedirectError';\n      } else {\n        var newUrl = args.formatRedirectUrl ? args.formatRedirectUrl(url, location) : urlutil.resolve(url, location);\n        debug('Request#%d %s: `redirected` from %s to %s', reqId, options.path, url, newUrl); // make sure timer stop\n\n        cancelResponseTimer(); // should clean up headers.host on `location: http://other-domain/url`\n\n        if (options.headers.host && PROTO_RE.test(location)) {\n          options.headers.host = null;\n          args.headers = options.headers;\n        } // avoid done will be execute in the future change.\n\n\n        var cb = callback;\n        callback = null;\n        exports.requestWithCallback(newUrl, args, cb);\n        return {\n          redirect: true,\n          error: null\n        };\n      }\n    }\n\n    return {\n      redirect: false,\n      error: err\n    };\n  } // don't set user-agent\n\n\n  if (args.headers && (args.headers['User-Agent'] === null || args.headers['user-agent'] === null)) {\n    if (options.headers['user-agent']) {\n      delete options.headers['user-agent'];\n    }\n  } else {\n    // need to set user-agent\n    var hasAgentHeader = options.headers['user-agent'];\n\n    if (!hasAgentHeader) {\n      options.headers['user-agent'] = USER_AGENT;\n    }\n  }\n\n  if (args.gzip) {\n    var isAcceptEncodingNull = args.headers && (args.headers['Accept-Encoding'] === null || args.headers['accept-encoding'] === null);\n\n    if (!isAcceptEncodingNull) {\n      var hasAcceptEncodingHeader = options.headers['accept-encoding'];\n\n      if (!hasAcceptEncodingHeader) {\n        options.headers['accept-encoding'] = 'gzip, deflate';\n      }\n    }\n  }\n\n  function decodeContent(res, body, cb) {\n    var encoding = res.headers['content-encoding'];\n\n    if (body.length === 0 || !encoding) {\n      return cb(null, body, encoding);\n    }\n\n    encoding = encoding.toLowerCase();\n\n    switch (encoding) {\n      case 'gzip':\n      case 'deflate':\n        debug('unzip %d length body', body.length);\n        zlib.unzip(body, function (err, data) {\n          if (err && err.name === 'Error') {\n            err.name = 'UnzipError';\n          }\n\n          cb(err, data);\n        });\n        break;\n\n      default:\n        cb(null, body, encoding);\n    }\n  }\n\n  var writeStream = args.writeStream;\n  var isWriteStreamClose = false;\n  debug('Request#%d %s %s with headers %j, options.path: %s', reqId, method, url, options.headers, options.path);\n  args.requestUrls.push(parsedUrl.href);\n\n  function onResponse(res) {\n    socketHandledResponses = res.socket[SOCKET_RESPONSE_COUNT] = (res.socket[SOCKET_RESPONSE_COUNT] || 0) + 1;\n\n    if (timing) {\n      timing.waiting = Date.now() - requestStartTime;\n    }\n\n    debug('Request#%d %s `req response` event emit: status %d, headers: %j', reqId, url, res.statusCode, res.headers);\n\n    if (args.streaming) {\n      var result = handleRedirect(res);\n\n      if (result.redirect) {\n        res.resume();\n        createAndEmitResponseEvent(null, res);\n        return;\n      }\n\n      if (result.error) {\n        res.resume();\n        return done(result.error, null, res);\n      }\n\n      return done(null, null, res);\n    }\n\n    res.on('error', function () {\n      debug('Request#%d %s: `res error` event emit, total size %d, socket handled %s requests and %s responses', reqId, url, responseSize, socketHandledRequests, socketHandledResponses);\n    });\n    res.on('aborted', function () {\n      responseAborted = true;\n      debug('Request#%d %s: `res aborted` event emit, total size %d', reqId, url, responseSize);\n    });\n\n    if (writeStream) {\n      // If there's a writable stream to recieve the response data, just pipe the\n      // response stream to that writable stream and call the callback when it has\n      // finished writing.\n      //\n      // NOTE that when the response stream `res` emits an 'end' event it just\n      // means that it has finished piping data to another stream. In the\n      // meanwhile that writable stream may still writing data to the disk until\n      // it emits a 'close' event.\n      //\n      // That means that we should not apply callback until the 'close' of the\n      // writable stream is emited.\n      //\n      // See also:\n      // - https://github.com/TBEDP/urllib/commit/959ac3365821e0e028c231a5e8efca6af410eabb\n      // - http://nodejs.org/api/stream.html#stream_event_end\n      // - http://nodejs.org/api/stream.html#stream_event_close_1\n      var result = handleRedirect(res);\n\n      if (result.redirect) {\n        res.resume();\n        createAndEmitResponseEvent(null, res);\n        return;\n      }\n\n      if (result.error) {\n        res.resume(); // end ths stream first\n\n        writeStream.end();\n        done(result.error, null, res);\n        return;\n      } // you can set consumeWriteStream false that only wait response end\n\n\n      if (args.consumeWriteStream === false) {\n        res.on('end', done.bind(null, null, null, res));\n        pump(res, writeStream, function (err) {\n          if (isWriteStreamClose) {\n            return;\n          }\n\n          isWriteStreamClose = true;\n          debug('Request#%d %s: writeStream close, error: %s', reqId, url, err);\n        });\n        return;\n      } // node 0.10, 0.12: only emit res aborted, writeStream close not fired\n\n\n      if (isNode010 || isNode012) {\n        first([[writeStream, 'close'], [res, 'aborted']], function (_, stream, event) {\n          debug('Request#%d %s: writeStream or res %s event emitted', reqId, url, event);\n          done(__err || null, null, res);\n        });\n        res.pipe(writeStream);\n        return;\n      }\n\n      debug('Request#%d %s: pump res to writeStream', reqId, url);\n      pump(res, writeStream, function (err) {\n        debug('Request#%d %s: writeStream close event emitted, error: %s, isWriteStreamClose: %s', reqId, url, err, isWriteStreamClose);\n\n        if (isWriteStreamClose) {\n          return;\n        }\n\n        isWriteStreamClose = true;\n        done(__err || err, null, res);\n      });\n      return;\n    } // Otherwise, just concat those buffers.\n    //\n    // NOTE that the `chunk` is not a String but a Buffer. It means that if\n    // you simply concat two chunk with `+` you're actually converting both\n    // Buffers into Strings before concating them. It'll cause problems when\n    // dealing with multi-byte characters.\n    //\n    // The solution is to store each chunk in an array and concat them with\n    // 'buffer-concat' when all chunks is recieved.\n    //\n    // See also:\n    // http://cnodejs.org/topic/4faf65852e8fb5bc65113403\n\n\n    var chunks = [];\n    res.on('data', function (chunk) {\n      debug('Request#%d %s: `res data` event emit, size %d', reqId, url, chunk.length);\n      responseSize += chunk.length;\n      chunks.push(chunk);\n    });\n    var isEmitted = false;\n\n    function handleResponseCloseAndEnd(event) {\n      debug('Request#%d %s: `res %s` event emit, total size %d, socket handled %s requests and %s responses', reqId, url, event, responseSize, socketHandledRequests, socketHandledResponses);\n\n      if (isEmitted) {\n        return;\n      }\n\n      isEmitted = true;\n      var body = Buffer.concat(chunks, responseSize);\n      debug('Request#%d %s: _dumped: %s', reqId, url, res._dumped);\n\n      if (__err) {\n        // req.abort() after `res data` event emit.\n        return done(__err, body, res);\n      }\n\n      var result = handleRedirect(res);\n\n      if (result.error) {\n        return done(result.error, body, res);\n      }\n\n      if (result.redirect) {\n        createAndEmitResponseEvent(null, res);\n        return;\n      }\n\n      decodeContent(res, body, function (err, data, encoding) {\n        if (err) {\n          return done(err, body, res);\n        } // if body not decode, dont touch it\n\n\n        if (!encoding && TEXT_DATA_TYPES.indexOf(args.dataType) >= 0) {\n          // try to decode charset\n          try {\n            data = decodeBodyByCharset(data, res);\n          } catch (e) {\n            debug('decodeBodyByCharset error: %s', e); // if error, dont touch it\n\n            return done(null, data, res);\n          }\n\n          if (args.dataType === 'json') {\n            if (responseSize === 0) {\n              data = null;\n            } else {\n              var r = parseJSON(data, fixJSONCtlChars);\n\n              if (r.error) {\n                err = r.error;\n              } else {\n                data = r.data;\n              }\n            }\n          }\n        }\n\n        if (responseAborted) {\n          // err = new Error('Remote socket was terminated before `response.end()` was called');\n          // err.name = 'RemoteSocketClosedError';\n          debug('Request#%d %s: Remote socket was terminated before `response.end()` was called', reqId, url);\n        }\n\n        done(err, data, res);\n      });\n    } // node >= 14 only emit close if req abort\n\n\n    res.on('close', function () {\n      handleResponseCloseAndEnd('close');\n    });\n    res.on('end', function () {\n      handleResponseCloseAndEnd('end');\n    });\n  }\n\n  var connectTimeout, responseTimeout;\n\n  if (Array.isArray(args.timeout)) {\n    connectTimeout = ms(args.timeout[0]);\n    responseTimeout = ms(args.timeout[1]);\n  } else {\n    // set both timeout equal\n    connectTimeout = responseTimeout = ms(args.timeout);\n  }\n\n  debug('ConnectTimeout: %d, ResponseTimeout: %d', connectTimeout, responseTimeout);\n\n  function startConnectTimer() {\n    debug('Connect timer ticking, timeout: %d', connectTimeout);\n    connectTimer = setTimeout(function () {\n      connectTimer = null;\n\n      if (statusCode === -1) {\n        statusCode = -2;\n      }\n\n      var msg = 'Connect timeout for ' + connectTimeout + 'ms';\n      var errorName = 'ConnectionTimeoutError';\n\n      if (!req.socket) {\n        errorName = 'SocketAssignTimeoutError';\n        msg += ', working sockets is full';\n      }\n\n      __err = new Error(msg);\n      __err.name = errorName;\n      __err.requestId = reqId;\n      debug('ConnectTimeout: Request#%d %s %s: %s, connected: %s', reqId, url, __err.name, msg, connected);\n      abortRequest();\n    }, connectTimeout);\n  }\n\n  function startResposneTimer() {\n    debug('Response timer ticking, timeout: %d', responseTimeout);\n    responseTimer = setTimeout(function () {\n      responseTimer = null;\n      var msg = 'Response timeout for ' + responseTimeout + 'ms';\n      var errorName = 'ResponseTimeoutError';\n      __err = new Error(msg);\n      __err.name = errorName;\n      __err.requestId = reqId;\n      debug('ResponseTimeout: Request#%d %s %s: %s, connected: %s', reqId, url, __err.name, msg, connected);\n      abortRequest();\n    }, responseTimeout);\n  }\n\n  if (args.checkAddress) {\n    var hostname = parsedUrl.hostname; // if request hostname is ip, custom lookup wont excute\n\n    var family = null;\n\n    if (ip.isV4Format(hostname)) {\n      family = 4;\n    } else if (ip.isV6Format(hostname)) {\n      family = 6;\n    }\n\n    if (family) {\n      if (!args.checkAddress(hostname, family)) {\n        var err = new Error('illegal address');\n        err.name = 'IllegalAddressError';\n        err.hostname = hostname;\n        err.ip = hostname;\n        err.family = family;\n        return done(err);\n      }\n    }\n  } // request headers checker will throw error\n\n\n  try {\n    var finalOptions = options; // restore origin header key\n\n    if (args.keepHeaderCase) {\n      var originKeys = Object.keys(originHeaderKeys);\n\n      if (originKeys.length) {\n        var finalHeaders = {};\n        var names = utility.getOwnEnumerables(options.headers, true);\n\n        for (var i = 0; i < names.length; i++) {\n          var name = names[i];\n          finalHeaders[originHeaderKeys[name] || name] = options.headers[name];\n        }\n\n        finalOptions = Object.assign({}, options);\n        finalOptions.headers = finalHeaders;\n      }\n    }\n\n    req = httplib.request(finalOptions, onResponse);\n\n    if (args.trace) {\n      req._callSite = {};\n      Error.captureStackTrace(req._callSite, requestWithCallback);\n    }\n  } catch (err) {\n    return done(err);\n  } // environment detection: browser or nodejs\n\n\n  if (typeof window === 'undefined') {\n    // start connect timer just after `request` return, and just in nodejs environment\n    startConnectTimer();\n  }\n\n  var isRequestAborted = false;\n\n  function abortRequest() {\n    if (isRequestAborted) {\n      return;\n    }\n\n    isRequestAborted = true;\n    debug('Request#%d %s abort, connected: %s', reqId, url, connected); // it wont case error event when req haven't been assigned a socket yet.\n\n    if (!req.socket) {\n      __err.noSocket = true;\n      done(__err);\n    }\n\n    req.abort();\n  }\n\n  if (timing) {\n    // request sent\n    req.on('finish', function () {\n      timing.requestSent = Date.now() - requestStartTime;\n    });\n  }\n\n  req.once('socket', function (socket) {\n    if (timing) {\n      // socket queuing time\n      timing.queuing = Date.now() - requestStartTime;\n    } // https://github.com/nodejs/node/blob/master/lib/net.js#L377\n    // https://github.com/nodejs/node/blob/v0.10.40-release/lib/net.js#L352\n    // should use socket.socket on 0.10.x\n\n\n    if (isNode010 && socket.socket) {\n      socket = socket.socket;\n    }\n\n    var orginalSocketTimeout = getSocketTimeout(socket);\n\n    if (orginalSocketTimeout && orginalSocketTimeout < responseTimeout) {\n      // make sure socket live longer than the response timer\n      var socketTimeout = responseTimeout + 500;\n      debug('Request#%d socket.timeout(%s) < responseTimeout(%s), reset socket timeout to %s', reqId, orginalSocketTimeout, responseTimeout, socketTimeout);\n      socket.setTimeout(socketTimeout);\n    }\n\n    socketHandledRequests = socket[SOCKET_REQUEST_COUNT] = (socket[SOCKET_REQUEST_COUNT] || 0) + 1;\n\n    if (socket[SOCKET_RESPONSE_COUNT]) {\n      socketHandledResponses = socket[SOCKET_RESPONSE_COUNT];\n    }\n\n    var readyState = socket.readyState;\n\n    if (readyState === 'opening') {\n      socket.once('lookup', function (err, ip, addressType) {\n        debug('Request#%d %s lookup: %s, %s, %s', reqId, url, err, ip, addressType);\n\n        if (timing) {\n          timing.dnslookup = Date.now() - requestStartTime;\n        }\n\n        if (ip) {\n          remoteAddress = ip;\n        }\n      });\n      socket.once('connect', function () {\n        if (timing) {\n          // socket connected\n          timing.connected = Date.now() - requestStartTime;\n        } // cancel socket timer at first and start tick for TTFB\n\n\n        cancelConnectTimer();\n        startResposneTimer();\n        debug('Request#%d %s new socket connected', reqId, url);\n        connected = true;\n\n        if (!remoteAddress) {\n          remoteAddress = socket.remoteAddress;\n        }\n\n        remotePort = socket.remotePort;\n      });\n      return;\n    }\n\n    debug('Request#%d %s reuse socket connected, readyState: %s', reqId, url, readyState);\n    connected = true;\n    keepAliveSocket = true;\n\n    if (!remoteAddress) {\n      remoteAddress = socket.remoteAddress;\n    }\n\n    remotePort = socket.remotePort; // reuse socket, timer should be canceled.\n\n    cancelConnectTimer();\n    startResposneTimer();\n  });\n\n  if (writeStream) {\n    writeStream.once('error', function (err) {\n      err.message += ' (writeStream \"error\")';\n      __err = err;\n      debug('Request#%d %s `writeStream error` event emit, %s: %s', reqId, url, err.name, err.message);\n      abortRequest();\n    });\n  }\n\n  var isRequestError = false;\n\n  function handleRequestError(err) {\n    if (isRequestError || !err) {\n      return;\n    }\n\n    isRequestError = true;\n\n    if (err.name === 'Error') {\n      err.name = connected ? 'ResponseError' : 'RequestError';\n    }\n\n    debug('Request#%d %s `req error` event emit, %s: %s', reqId, url, err.name, err.message);\n    done(__err || err);\n  }\n\n  if (args.stream) {\n    debug('Request#%d pump args.stream to req', reqId);\n    pump(args.stream, req, handleRequestError);\n  } else {\n    req.end(body);\n  } // when stream already consumed, req's `finish` event is emitted and pump will ignore error after pipe finished\n  // but if server response timeout later, we will abort the request and emit an error in req\n  // so we must always manually listen to req's `error` event here to ensure this error is handled\n\n\n  req.on('error', handleRequestError);\n  req.requestId = reqId;\n  return req;\n}\n\nexports.requestWithCallback = requestWithCallback;\nvar JSONCtlCharsMap = {\n  '\"': '\\\\\"',\n  // \\u0022\n  '\\\\': '\\\\\\\\',\n  // \\u005c\n  '\\b': '\\\\b',\n  // \\u0008\n  '\\f': '\\\\f',\n  // \\u000c\n  '\\n': '\\\\n',\n  // \\u000a\n  '\\r': '\\\\r',\n  // \\u000d\n  '\\t': '\\\\t' // \\u0009\n\n};\nvar JSONCtlCharsRE = /[\\u0000-\\u001F\\u005C]/g;\n\nfunction _replaceOneChar(c) {\n  return JSONCtlCharsMap[c] || '\\\\u' + (c.charCodeAt(0) + 0x10000).toString(16).substr(1);\n}\n\nfunction replaceJSONCtlChars(str) {\n  return str.replace(JSONCtlCharsRE, _replaceOneChar);\n}\n\nfunction parseJSON(data, fixJSONCtlChars) {\n  var result = {\n    error: null,\n    data: null\n  };\n\n  if (fixJSONCtlChars) {\n    if (typeof fixJSONCtlChars === 'function') {\n      data = fixJSONCtlChars(data);\n    } else {\n      // https://github.com/node-modules/urllib/pull/77\n      // remote the control characters (U+0000 through U+001F)\n      data = replaceJSONCtlChars(data);\n    }\n  }\n\n  try {\n    result.data = JSON.parse(data);\n  } catch (err) {\n    if (err.name === 'SyntaxError') {\n      err.name = 'JSONResponseFormatError';\n    }\n\n    if (data.length > 1024) {\n      // show 0~512 ... -512~end data\n      err.message += ' (data json format: ' + JSON.stringify(data.slice(0, 512)) + ' ...skip... ' + JSON.stringify(data.slice(data.length - 512)) + ')';\n    } else {\n      err.message += ' (data json format: ' + JSON.stringify(data) + ')';\n    }\n\n    result.error = err;\n  }\n\n  return result;\n}\n/**\n * decode response body by parse `content-type`'s charset\n * @param {Buffer} data\n * @param {Http(s)Response} res\n * @return {String}\n */\n\n\nfunction decodeBodyByCharset(data, res) {\n  var type = res.headers['content-type'];\n\n  if (!type) {\n    return data.toString();\n  }\n\n  var type = parseContentType(type);\n  var charset = type.parameters.charset || 'utf-8';\n\n  if (!Buffer.isEncoding(charset)) {\n    if (!_iconv) {\n      _iconv = require('iconv-lite');\n    }\n\n    return _iconv.decode(data, charset);\n  }\n\n  return data.toString(charset);\n}\n\nfunction getAgent(agent, defaultAgent) {\n  return agent === undefined ? defaultAgent : agent;\n}\n\nfunction parseContentType(str) {\n  try {\n    return contentTypeParser.parse(str);\n  } catch (err) {\n    // ignore content-type error, tread as default\n    return {\n      parameters: {}\n    };\n  }\n}\n\nfunction addLongStackTrace(err, req) {\n  if (!req) {\n    return;\n  }\n\n  var callSiteStack = req._callSite && req._callSite.stack;\n\n  if (!callSiteStack || typeof callSiteStack !== 'string') {\n    return;\n  }\n\n  if (err._longStack) {\n    return;\n  }\n\n  var index = callSiteStack.indexOf('\\n');\n\n  if (index !== -1) {\n    err._longStack = true;\n    err.stack += LONG_STACK_DELIMITER + callSiteStack.substr(index + 1);\n  }\n} // node 8 don't has timeout attribute on socket\n// https://github.com/nodejs/node/pull/21204/files#diff-e6ef024c3775d787c38487a6309e491dR408\n\n\nfunction getSocketTimeout(socket) {\n  return socket.timeout || socket._idleTimeout;\n}","map":{"version":3,"names":["debug","require","path","dns","http","https","urlutil","URL","util","qs","ip","querystring","zlib","ua","digestAuthHeader","ms","statuses","contentTypeParser","first","pump","utility","FormStream","detectProxyAgent","_Promise","_iconv","pkg","USER_AGENT","exports","version","NODE_MAJOR_VERSION","parseInt","process","versions","node","split","agent","Agent","maxSockets","httpsAgent","LONG_STACK_DELIMITER","TIMEOUT","TIMEOUTS","REQUEST_ID","MAX_VALUE","Math","pow","isNode010","test","isNode012","TEXT_DATA_TYPES","PROTO_RE","KEEP_ALIVE_RE","SOCKET_REQUEST_COUNT","SOCKET_RESPONSE_COUNT","request","url","args","callback","arguments","length","requestWithCallback","resolve","reject","makeCallback","curl","err","data","res","status","statusCode","headers","requestThunk","req","msg","format","Error","reqId","requestUrls","timeout","maxRedirects","streaming","customResponse","requestStartTime","Date","now","parsedUrl","parse","href","reqMeta","requestId","ctx","emitter","emit","method","type","toUpperCase","port","httplib","getAgent","fixJSONCtlChars","protocol","proxyTunnelAgent","lookup","checkAddress","_lookup","host","dnsopts","emitLookup","family","name","hostname","requestSize","options","originHeaderKeys","names","getOwnEnumerables","i","key","toLowerCase","socketPath","sslNames","hasOwnProperty","rejectUnauthorized","secureOptions","SSL_OP_NO_TLSv1_2","auth","body","dataAsQueryString","files","uploadFiles","Array","isArray","field","push","Buffer","isBuffer","pipe","form","fieldName","item","buffer","filename","basename","stream","file","formHeaders","formHeaderNames","content","nestedQuerystring","stringify","contentType","parseContentType","JSON","query","byteLength","toString","dataType","accept","beforeRequest","connectTimer","responseTimer","__err","connected","keepAliveSocket","socketHandledRequests","socketHandledResponses","responseSize","statusMessage","responseAborted","remoteAddress","remotePort","timing","queuing","dnslookup","requestSent","waiting","contentDownload","cancelConnectTimer","clearTimeout","cancelResponseTimer","done","console","warn","pid","message","stack","cb","handleDigestAuth","response","createCallbackResponse","requestUseTime","agentStatus","getCurrentStatus","addLongStackTrace","freeSocketTimeout","freeSocketKeepAliveTimeout","keepAlive","connection","m","exec","seconds","serverSocketTimeout","socket","emitResponseEvent","createAndEmitResponseEvent","resStatusCode","resStatusMessage","size","aborted","rt","error","authorization","digestAuth","authenticate","indexOf","cookie","join","handleRedirect","followRedirect","redirect","_followRedirectCount","location","newUrl","formatRedirectUrl","hasAgentHeader","gzip","isAcceptEncodingNull","hasAcceptEncodingHeader","decodeContent","encoding","unzip","writeStream","isWriteStreamClose","onResponse","result","resume","on","end","consumeWriteStream","bind","_","event","chunks","chunk","isEmitted","handleResponseCloseAndEnd","concat","_dumped","decodeBodyByCharset","e","r","parseJSON","connectTimeout","responseTimeout","startConnectTimer","setTimeout","errorName","abortRequest","startResposneTimer","isV4Format","isV6Format","finalOptions","keepHeaderCase","originKeys","Object","keys","finalHeaders","assign","trace","_callSite","captureStackTrace","window","isRequestAborted","noSocket","abort","once","orginalSocketTimeout","getSocketTimeout","socketTimeout","readyState","addressType","isRequestError","handleRequestError","JSONCtlCharsMap","JSONCtlCharsRE","_replaceOneChar","c","charCodeAt","substr","replaceJSONCtlChars","str","replace","slice","charset","parameters","isEncoding","decode","defaultAgent","undefined","callSiteStack","_longStack","index","_idleTimeout"],"sources":["C:/Users/bryan/Desktop/myrepresentatives/frontend/node_modules/urllib/lib/urllib.js"],"sourcesContent":["'use strict';\n\nvar debug = require('debug')('urllib');\nvar path = require('path');\nvar dns = require('dns');\nvar http = require('http');\nvar https = require('https');\nvar urlutil = require('url');\nvar URL = urlutil.URL;\nvar util = require('util');\nvar qs = require('qs');\nvar ip = require('ip');\nvar querystring = require('querystring');\nvar zlib = require('zlib');\nvar ua = require('default-user-agent');\nvar digestAuthHeader = require('digest-header');\nvar ms = require('humanize-ms');\nvar statuses = require('statuses');\nvar contentTypeParser = require('content-type');\nvar first = require('ee-first');\nvar pump = require('pump');\nvar utility = require('utility');\nvar FormStream = require('formstream');\nvar detectProxyAgent = require('./detect_proxy_agent');\n\nvar _Promise;\nvar _iconv;\n\nvar pkg = require('../package.json');\n\nvar USER_AGENT = exports.USER_AGENT = ua('node-urllib', pkg.version);\nvar NODE_MAJOR_VERSION = parseInt(process.versions.node.split('.')[0]);\n\n// change Agent.maxSockets to 1000\nexports.agent = new http.Agent();\nexports.agent.maxSockets = 1000;\n\nexports.httpsAgent = new https.Agent();\nexports.httpsAgent.maxSockets = 1000;\n\nvar LONG_STACK_DELIMITER = '\\n    --------------------\\n';\n\n/**\n * The default request timeout(in milliseconds).\n * @type {Number}\n * @const\n */\n\nexports.TIMEOUT = ms('5s');\nexports.TIMEOUTS = [ms('5s'), ms('5s')];\n\nvar REQUEST_ID = 0;\nvar MAX_VALUE = Math.pow(2, 31) - 10;\nvar isNode010 = /^v0\\.10\\.\\d+$/.test(process.version);\nvar isNode012 = /^v0\\.12\\.\\d+$/.test(process.version);\n\n/**\n * support data types\n * will auto decode response body\n * @type {Array}\n */\nvar TEXT_DATA_TYPES = [\n  'json',\n  'text'\n];\n\nvar PROTO_RE = /^https?:\\/\\//i;\n\n// Keep-Alive: timeout=5, max=100\nvar KEEP_ALIVE_RE = /^timeout=(\\d+)/i;\n\nvar SOCKET_REQUEST_COUNT = '_URLLIB_SOCKET_REQUEST_COUNT';\nvar SOCKET_RESPONSE_COUNT = '_URLLIB_SOCKET_RESPONSE_COUNT';\n\n/**\n * Handle all http request, both http and https support well.\n *\n * @example\n *\n * ```js\n * // GET https://nodejs.org\n * urllib.request('https://nodejs.org', function(err, data, res) {});\n * // POST https://nodejs.org\n * var args = { type: 'post', data: { foo: 'bar' } };\n * urllib.request('https://nodejs.org', args, function(err, data, res) {});\n * ```\n *\n * @param {String|Object} url: the request full URL.\n * @param {Object} [args]: optional\n *   - {Object} [data]: request data, will auto be query stringify.\n *   - {Boolean} [dataAsQueryString]: force convert `data` to query string.\n *   - {String|Buffer} [content]: optional, if set content, `data` will ignore.\n *   - {ReadStream} [stream]: read stream to sent.\n *   - {WriteStream} [writeStream]: writable stream to save response data.\n *       If you use this, callback's data should be null.\n *       We will just `pipe(ws, {end: true})`.\n *   - {consumeWriteStream} [true]: consume the writeStream, invoke the callback after writeStream close.\n *   - {Array<ReadStream|Buffer|String>|Object|ReadStream|Buffer|String} [files]: optional,\n *       The files will send with `multipart/form-data` format, base on `formstream`.\n *       If `method` not set, will use `POST` method by default.\n *   - {String} [method]: optional, could be GET | POST | DELETE | PUT, default is GET\n *   - {String} [contentType]: optional, request data type, could be `json`, default is undefined\n *   - {String} [dataType]: optional, response data type, could be `text` or `json`, default is buffer\n *   - {Boolean|Function} [fixJSONCtlChars]: optional, fix the control characters (U+0000 through U+001F)\n *       before JSON parse response. Default is `false`.\n *       `fixJSONCtlChars` can be a function, will pass data to the first argument. e.g.: `data = fixJSONCtlChars(data)`\n *   - {Object} [headers]: optional, request headers\n *   - {Boolean} [keepHeaderCase]: optional, by default will convert header keys to lowercase\n *   - {Number|Array} [timeout]: request timeout(in milliseconds), default is `exports.TIMEOUTS containing connect timeout and response timeout`\n *   - {Agent} [agent]: optional, http agent. Set `false` if you does not use agent.\n *   - {Agent} [httpsAgent]: optional, https agent. Set `false` if you does not use agent.\n *   - {String} [auth]: Basic authentication i.e. 'user:password' to compute an Authorization header.\n *   - {String} [digestAuth]: Digest authentication i.e. 'user:password' to compute an Authorization header.\n *   - {String|Buffer|Array} [ca]: An array of strings or Buffers of trusted certificates.\n *       If this is omitted several well known \"root\" CAs will be used, like VeriSign.\n *       These are used to authorize connections.\n *       Notes: This is necessary only if the server uses the self-signed certificate\n *   - {Boolean} [rejectUnauthorized]: If true, the server certificate is verified against the list of supplied CAs.\n *       An 'error' event is emitted if verification fails. Default: true.\n *   - {String|Buffer} [pfx]: A string or Buffer containing the private key,\n *       certificate and CA certs of the server in PFX or PKCS12 format.\n *   - {String|Buffer} [key]: A string or Buffer containing the private key of the client in PEM format.\n *       Notes: This is necessary only if using the client certificate authentication\n *   - {String|Buffer} [cert]: A string or Buffer containing the certificate key of the client in PEM format.\n *       Notes: This is necessary only if using the client certificate authentication\n *   - {String} [passphrase]: A string of passphrase for the private key or pfx.\n *   - {String} [ciphers]: A string describing the ciphers to use or exclude.\n *   - {String} [secureProtocol]: The SSL method to use, e.g. SSLv3_method to force SSL version 3.\n *       The possible values depend on your installation of OpenSSL and are defined in the constant SSL_METHODS.\n *   - {Boolean} [followRedirect]: Follow HTTP 3xx responses as redirects. defaults to false.\n *   - {Number} [maxRedirects]: The maximum number of redirects to follow, defaults to 10.\n *   - {Function(from, to)} [formatRedirectUrl]: Format the redirect url by your self. Default is `url.resolve(from, to)`\n *   - {Function(options)} [beforeRequest]: Before request hook, you can change every thing here.\n *   - {Boolean} [streaming]: let you get the res object when request connected, default is `false`. alias `customResponse`\n *   - {Boolean} [gzip]: Accept gzip response content and auto decode it, default is `false`.\n *   - {Boolean} [timing]: Enable timing or not, default is `false`.\n *   - {Function} [lookup]: Custom DNS lookup function, default is `dns.lookup`.\n *       Require node >= 4.0.0 and only work on `http` protocol.\n *   - {Boolean} [enableProxy]: optional, enable proxy request. Default is `false`.\n *   - {String|Object} [proxy]: optional proxy agent uri or options. Default is `null`.\n *   - {String} [socketPath]: optional, unix domain socket file path.\n *   - {Function} checkAddress: optional, check request address to protect from SSRF and similar attacks.\n * @param {Function} [callback]: callback(error, data, res). If missing callback, will return a promise object.\n * @return {HttpRequest} req object.\n * @api public\n */\nexports.request = function request(url, args, callback) {\n  // request(url, callback)\n  if (arguments.length === 2 && typeof args === 'function') {\n    callback = args;\n    args = null;\n  }\n  if (typeof callback === 'function') {\n    return exports.requestWithCallback(url, args, callback);\n  }\n\n  // Promise\n  if (!_Promise) {\n    _Promise = require('any-promise');\n  }\n  return new _Promise(function (resolve, reject) {\n    exports.requestWithCallback(url, args, makeCallback(resolve, reject));\n  });\n};\n\n// alias to curl\nexports.curl = exports.request;\n\nfunction makeCallback(resolve, reject) {\n  return function (err, data, res) {\n    if (err) {\n      return reject(err);\n    }\n    resolve({\n      data: data,\n      status: res.statusCode,\n      headers: res.headers,\n      res: res\n    });\n  };\n}\n\n// yield urllib.requestThunk(url, args)\nexports.requestThunk = function requestThunk(url, args) {\n  return function (callback) {\n    exports.requestWithCallback(url, args, function (err, data, res) {\n      if (err) {\n        return callback(err);\n      }\n      callback(null, {\n        data: data,\n        status: res.statusCode,\n        headers: res.headers,\n        res: res\n      });\n    });\n  };\n};\n\nfunction requestWithCallback(url, args, callback) {\n  var req;\n  // requestWithCallback(url, callback)\n  if (!url || (typeof url !== 'string' && typeof url !== 'object')) {\n    var msg = util.format('expect request url to be a string or a http request options, but got %j', url);\n    throw new Error(msg);\n  }\n\n  if (arguments.length === 2 && typeof args === 'function') {\n    callback = args;\n    args = null;\n  }\n\n  args = args || {};\n  if (REQUEST_ID >= MAX_VALUE) {\n    REQUEST_ID = 0;\n  }\n  var reqId = ++REQUEST_ID;\n\n  args.requestUrls = args.requestUrls || [];\n\n  args.timeout = args.timeout || exports.TIMEOUTS;\n  args.maxRedirects = args.maxRedirects || 10;\n  args.streaming = args.streaming || args.customResponse;\n  var requestStartTime = Date.now();\n  var parsedUrl;\n\n  if (typeof url === 'string') {\n    if (!PROTO_RE.test(url)) {\n      // Support `request('www.server.com')`\n      url = 'http://' + url;\n    }\n    if (URL) {\n      parsedUrl = urlutil.parse(new URL(url).href);\n    } else {\n      parsedUrl = urlutil.parse(url);\n    }\n  } else {\n    parsedUrl = url;\n  }\n\n  var reqMeta = {\n    requestId: reqId,\n    url: parsedUrl.href,\n    args: args,\n    ctx: args.ctx,\n  };\n  if (args.emitter) {\n    args.emitter.emit('request', reqMeta);\n  }\n\n  var method = (args.type || args.method || parsedUrl.method || 'GET').toUpperCase();\n  var port = parsedUrl.port || 80;\n  var httplib = http;\n  var agent = getAgent(args.agent, exports.agent);\n  var fixJSONCtlChars = args.fixJSONCtlChars;\n\n  if (parsedUrl.protocol === 'https:') {\n    httplib = https;\n    agent = getAgent(args.httpsAgent, exports.httpsAgent);\n\n    if (!parsedUrl.port) {\n      port = 443;\n    }\n  }\n\n  // request through proxy tunnel\n  var proxyTunnelAgent = detectProxyAgent(parsedUrl, args);\n  if (proxyTunnelAgent) {\n    agent = proxyTunnelAgent;\n  }\n\n  var lookup = args.lookup;\n  // check address to protect from SSRF and similar attacks\n  if (args.checkAddress) {\n    var _lookup = lookup || dns.lookup;\n    lookup = function(host, dnsopts, callback) {\n      _lookup(host, dnsopts, function emitLookup(err, ip, family) {\n        // add check address logic in custom dns lookup\n        if (!err && !args.checkAddress(ip, family)) {\n          err = new Error('illegal address');\n          err.name = 'IllegalAddressError';\n          err.hostname = host;\n          err.ip = ip;\n          err.family = family;\n        }\n        callback(err, ip, family);\n      });\n    };\n  }\n\n  var requestSize = 0;\n  var options = {\n    host: parsedUrl.hostname || parsedUrl.host || 'localhost',\n    path: parsedUrl.path || '/',\n    method: method,\n    port: port,\n    agent: agent,\n    headers: {},\n    // default is dns.lookup\n    // https://github.com/nodejs/node/blob/master/lib/net.js#L986\n    // custom dnslookup require node >= 4.0.0 (for http), node >=8 (for https)\n    // https://github.com/nodejs/node/blob/archived-io.js-v0.12/lib/net.js#L952\n    lookup: lookup,\n  };\n\n  var originHeaderKeys = {};\n  if (args.headers) {\n    // only allow enumerable and ownProperty value of args.headers\n    var names = utility.getOwnEnumerables(args.headers, true);\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i];\n      var key = name.toLowerCase();\n      if (key !== name) {\n        originHeaderKeys[key] = name;\n      }\n      options.headers[key] = args.headers[name];\n    }\n  }\n  if (args.socketPath) {\n    options.socketPath = args.socketPath;\n  }\n\n  var sslNames = [\n    'pfx',\n    'key',\n    'passphrase',\n    'cert',\n    'ca',\n    'ciphers',\n    'rejectUnauthorized',\n    'secureProtocol',\n    'secureOptions',\n  ];\n  for (var i = 0; i < sslNames.length; i++) {\n    var name = sslNames[i];\n    if (args.hasOwnProperty(name)) {\n      options[name] = args[name];\n    }\n  }\n\n  // fix rejectUnauthorized when major version < 12\n  if (NODE_MAJOR_VERSION < 12) {\n    if (options.rejectUnauthorized === false && !options.hasOwnProperty('secureOptions')) {\n      options.secureOptions = require('constants').SSL_OP_NO_TLSv1_2;\n    }\n  }\n\n  var auth = args.auth || parsedUrl.auth;\n  if (auth) {\n    options.auth = auth;\n  }\n\n  var body = null;\n  var dataAsQueryString = false;\n\n  if (args.files) {\n    if (!options.method || options.method === 'GET' || options.method === 'HEAD') {\n      options.method = 'POST';\n    }\n    var files = args.files;\n    var uploadFiles = [];\n    if (Array.isArray(files)) {\n      for (var i = 0; i < files.length; i++) {\n        var field = 'file' + (i === 0 ? '' : i);\n        uploadFiles.push([ field, files[i] ]);\n      }\n    } else {\n      if (Buffer.isBuffer(files) || typeof files.pipe === 'function' || typeof files === 'string') {\n        uploadFiles.push([ 'file', files ]);\n      } else if (typeof files === 'object') {\n        for (var field in files) {\n          uploadFiles.push([ field, files[field] ]);\n        }\n      }\n    }\n    var form = new FormStream();\n    // set normal fields first\n    if (args.data) {\n      for (var fieldName in args.data) {\n        form.field(fieldName, args.data[fieldName]);\n      }\n    }\n\n    for (var i = 0; i < uploadFiles.length; i++) {\n      var item = uploadFiles[i];\n      if (Buffer.isBuffer(item[1])) {\n        form.buffer(item[0], item[1], 'bufferfile' + i);\n      } else if (typeof item[1].pipe === 'function') {\n        var filename = item[1].path || ('streamfile' + i);\n        filename = path.basename(filename);\n        form.stream(item[0], item[1], filename);\n      } else {\n        form.file(item[0], item[1]);\n      }\n    }\n\n    var formHeaders = form.headers();\n    var formHeaderNames = utility.getOwnEnumerables(formHeaders, true);\n    for (var i = 0; i < formHeaderNames.length; i++) {\n      var name = formHeaderNames[i];\n      options.headers[name.toLowerCase()] = formHeaders[name];\n    }\n    debug('set multipart headers: %j, method: %s', formHeaders, options.method);\n    args.stream = form;\n  } else {\n    body = args.content || args.data;\n    dataAsQueryString = method === 'GET' || method === 'HEAD' || args.dataAsQueryString;\n    if (!args.content) {\n      if (body && !(typeof body === 'string' || Buffer.isBuffer(body))) {\n        if (dataAsQueryString) {\n          // read: GET, HEAD, use query string\n          body = args.nestedQuerystring ? qs.stringify(body) : querystring.stringify(body);\n        } else {\n          var contentType = options.headers['content-type'];\n          // auto add application/x-www-form-urlencoded when using urlencode form request\n          if (!contentType) {\n            if (args.contentType === 'json') {\n              contentType = 'application/json';\n            } else {\n              contentType = 'application/x-www-form-urlencoded';\n            }\n            options.headers['content-type'] = contentType;\n          }\n\n          if (parseContentType(contentType).type === 'application/json') {\n            body = JSON.stringify(body);\n          } else {\n            // 'application/x-www-form-urlencoded'\n            body = args.nestedQuerystring ? qs.stringify(body) : querystring.stringify(body);\n          }\n        }\n      }\n    }\n  }\n\n  if (body) {\n    // if it's a GET or HEAD request, data should be sent as query string\n    if (dataAsQueryString) {\n      options.path += (parsedUrl.query ? '&' : '?') + body;\n      body = null;\n    }\n\n    if (body) {\n      var length = body.length;\n      if (!Buffer.isBuffer(body)) {\n        length = Buffer.byteLength(body);\n      }\n      requestSize = length;\n\n      options.headers['content-length'] = length.toString();\n    }\n  }\n\n  if (args.dataType === 'json') {\n    if (!options.headers.accept) {\n      options.headers.accept = 'application/json';\n    }\n  }\n\n  if (typeof args.beforeRequest === 'function') {\n    // you can use this hook to change every thing.\n    args.beforeRequest(options);\n  }\n\n  var connectTimer = null;\n  var responseTimer = null;\n  var __err = null;\n  var connected = false; // socket connected or not\n  var keepAliveSocket = false; // request with keepalive socket\n  var socketHandledRequests = 0; // socket already handled request count\n  var socketHandledResponses = 0; // socket already handled response count\n  var responseSize = 0;\n  var statusCode = -1;\n  var statusMessage = null;\n  var responseAborted = false;\n  var remoteAddress = '';\n  var remotePort = '';\n  var timing = null;\n  if (args.timing) {\n    timing = {\n      // socket assigned\n      queuing: 0,\n      // dns lookup time\n      dnslookup: 0,\n      // socket connected\n      connected: 0,\n      // request sent\n      requestSent: 0,\n      // Time to first byte (TTFB)\n      waiting: 0,\n      contentDownload: 0,\n    };\n  }\n\n  function cancelConnectTimer() {\n    if (connectTimer) {\n      clearTimeout(connectTimer);\n      connectTimer = null;\n      debug('Request#%d connect timer canceled', reqId);\n    }\n  }\n  function cancelResponseTimer() {\n    if (responseTimer) {\n      clearTimeout(responseTimer);\n      responseTimer = null;\n      debug('Request#%d response timer canceled', reqId);\n    }\n  }\n\n  function done(err, data, res) {\n    cancelConnectTimer();\n    cancelResponseTimer();\n    if (!callback) {\n      console.warn('[urllib:warn] [%s] [%s] [worker:%s] %s %s callback twice!!!',\n        Date(), reqId, process.pid, options.method, url);\n      // https://github.com/node-modules/urllib/pull/30\n      if (err) {\n        console.warn('[urllib:warn] [%s] [%s] [worker:%s] %s: %s\\nstack: %s',\n          Date(), reqId, process.pid, err.name, err.message, err.stack);\n      }\n      return;\n    }\n\n    var cb = callback;\n    callback = null;\n    var headers = {};\n    if (res) {\n      statusCode = res.statusCode;\n      statusMessage = res.statusMessage;\n      headers = res.headers;\n    }\n\n    if (handleDigestAuth(res, cb)) {\n      return;\n    }\n\n    var response = createCallbackResponse(data, res);\n\n    debug('[%sms] done, %s bytes HTTP %s %s %s %s, keepAliveSocket: %s, timing: %j, socketHandledRequests: %s, socketHandledResponses: %s',\n      response.requestUseTime, responseSize, statusCode, options.method, options.host, options.path,\n      keepAliveSocket, timing, socketHandledRequests, socketHandledResponses);\n\n    if (err) {\n      var agentStatus = '';\n      if (agent && typeof agent.getCurrentStatus === 'function') {\n        // add current agent status to error message for logging and debug\n        agentStatus = ', agent status: ' + JSON.stringify(agent.getCurrentStatus());\n      }\n      err.message += ', ' + options.method + ' ' + url + ' ' + statusCode\n        + ' (connected: ' + connected + ', keepalive socket: ' + keepAliveSocket + agentStatus\n        + ', socketHandledRequests: ' + socketHandledRequests\n        + ', socketHandledResponses: ' + socketHandledResponses + ')'\n        + '\\nheaders: ' + JSON.stringify(headers);\n      err.data = data;\n      err.path = options.path;\n      err.status = statusCode;\n      err.headers = headers;\n      err.res = response;\n      addLongStackTrace(err, req);\n    }\n\n    // only support agentkeepalive module for now\n    // agentkeepalive@4: agent.options.freeSocketTimeout\n    // agentkeepalive@3: agent.freeSocketKeepAliveTimeout\n    var freeSocketTimeout = agent && (agent.options && agent.options.freeSocketTimeout || agent.freeSocketKeepAliveTimeout);\n    if (agent && agent.keepAlive && freeSocketTimeout > 0 &&\n        statusCode >= 200 && headers.connection === 'keep-alive' && headers['keep-alive']) {\n      // adjust freeSocketTimeout on the socket\n      var m = KEEP_ALIVE_RE.exec(headers['keep-alive']);\n      if (m) {\n        var seconds = parseInt(m[1]);\n        if (seconds > 0) {\n          // network delay 500ms\n          var serverSocketTimeout = seconds * 1000 - 500;\n          if (serverSocketTimeout < freeSocketTimeout) {\n            // https://github.com/node-modules/agentkeepalive/blob/master/lib/agent.js#L127\n            // agentkeepalive@4\n            var socket = res.socket || (req && req.socket);\n            if (agent.options && agent.options.freeSocketTimeout) {\n              socket.freeSocketTimeout = serverSocketTimeout;\n            } else {\n              socket.freeSocketKeepAliveTimeout = serverSocketTimeout;\n            }\n          }\n        }\n      }\n    }\n\n    cb(err, data, args.streaming ? res : response);\n\n    emitResponseEvent(err, response);\n  }\n\n  function createAndEmitResponseEvent(data, res) {\n    var response = createCallbackResponse(data, res);\n    emitResponseEvent(null, response);\n  }\n\n  function createCallbackResponse(data, res) {\n    var requestUseTime = Date.now() - requestStartTime;\n    if (timing) {\n      timing.contentDownload = requestUseTime;\n    }\n\n    var headers = res && res.headers || {};\n    var resStatusCode = res && res.statusCode || statusCode;\n    var resStatusMessage = res && res.statusMessage || statusMessage;\n\n    return {\n      status: resStatusCode,\n      statusCode: resStatusCode,\n      statusMessage: resStatusMessage,\n      headers: headers,\n      size: responseSize,\n      aborted: responseAborted,\n      rt: requestUseTime,\n      keepAliveSocket: keepAliveSocket,\n      data: data,\n      requestUrls: args.requestUrls,\n      timing: timing,\n      remoteAddress: remoteAddress,\n      remotePort: remotePort,\n      socketHandledRequests: socketHandledRequests,\n      socketHandledResponses: socketHandledResponses,\n    };\n  }\n\n  function emitResponseEvent(err, response) {\n    if (args.emitter) {\n      // keep to use the same reqMeta object on request event before\n      reqMeta.url = parsedUrl.href;\n      reqMeta.socket = req && req.connection;\n      reqMeta.options = options;\n      reqMeta.size = requestSize;\n\n      args.emitter.emit('response', {\n        requestId: reqId,\n        error: err,\n        ctx: args.ctx,\n        req: reqMeta,\n        res: response,\n      });\n    }\n  }\n\n  function handleDigestAuth(res, cb) {\n    var headers = {};\n    if (res && res.headers) {\n      headers = res.headers;\n    }\n    // handle digest auth\n    if (statusCode === 401 && headers['www-authenticate']\n        && !options.headers.authorization && args.digestAuth) {\n      var authenticate = headers['www-authenticate'];\n      if (authenticate.indexOf('Digest ') >= 0) {\n        debug('Request#%d %s: got digest auth header WWW-Authenticate: %s', reqId, url, authenticate);\n        options.headers.authorization = digestAuthHeader(options.method, options.path, authenticate, args.digestAuth);\n        debug('Request#%d %s: auth with digest header: %s', reqId, url, options.headers.authorization);\n        if (res.headers['set-cookie']) {\n          options.headers.cookie = res.headers['set-cookie'].join(';');\n        }\n        args.headers = options.headers;\n        exports.requestWithCallback(url, args, cb);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function handleRedirect(res) {\n    var err = null;\n    if (args.followRedirect && statuses.redirect[res.statusCode]) {  // handle redirect\n      args._followRedirectCount = (args._followRedirectCount || 0) + 1;\n      var location = res.headers.location;\n      if (!location) {\n        err = new Error('Got statusCode ' + res.statusCode + ' but cannot resolve next location from headers');\n        err.name = 'FollowRedirectError';\n      } else if (args._followRedirectCount > args.maxRedirects) {\n        err = new Error('Exceeded maxRedirects. Probably stuck in a redirect loop ' + url);\n        err.name = 'MaxRedirectError';\n      } else {\n        var newUrl = args.formatRedirectUrl ? args.formatRedirectUrl(url, location) : urlutil.resolve(url, location);\n        debug('Request#%d %s: `redirected` from %s to %s', reqId, options.path, url, newUrl);\n        // make sure timer stop\n        cancelResponseTimer();\n        // should clean up headers.host on `location: http://other-domain/url`\n        if (options.headers.host && PROTO_RE.test(location)) {\n          options.headers.host = null;\n          args.headers = options.headers;\n        }\n        // avoid done will be execute in the future change.\n        var cb = callback;\n        callback = null;\n        exports.requestWithCallback(newUrl, args, cb);\n        return {\n          redirect: true,\n          error: null\n        };\n      }\n    }\n    return {\n      redirect: false,\n      error: err\n    };\n  }\n\n  // don't set user-agent\n  if (args.headers && (args.headers['User-Agent'] === null || args.headers['user-agent'] === null)) {\n    if (options.headers['user-agent']) {\n      delete options.headers['user-agent'];\n    }\n  } else {\n    // need to set user-agent\n    var hasAgentHeader = options.headers['user-agent'];\n    if (!hasAgentHeader) {\n      options.headers['user-agent'] = USER_AGENT;\n    }\n  }\n\n  if (args.gzip) {\n    var isAcceptEncodingNull = (args.headers && (args.headers['Accept-Encoding'] === null || args.headers['accept-encoding'] === null));\n    if (!isAcceptEncodingNull) {\n      var hasAcceptEncodingHeader = options.headers['accept-encoding'];\n      if (!hasAcceptEncodingHeader) {\n        options.headers['accept-encoding'] = 'gzip, deflate';\n      }\n    }\n  }\n\n  function decodeContent(res, body, cb) {\n    var encoding = res.headers['content-encoding'];\n    if (body.length === 0 || !encoding) {\n      return cb(null, body, encoding);\n    }\n\n    encoding = encoding.toLowerCase();\n    switch (encoding) {\n      case 'gzip':\n      case 'deflate':\n        debug('unzip %d length body', body.length);\n        zlib.unzip(body, function(err, data) {\n          if (err && err.name === 'Error') {\n            err.name = 'UnzipError';\n          }\n          cb(err, data);\n        });\n        break;\n      default:\n        cb(null, body, encoding);\n    }\n  }\n\n  var writeStream = args.writeStream;\n  var isWriteStreamClose = false;\n\n  debug('Request#%d %s %s with headers %j, options.path: %s',\n    reqId, method, url, options.headers, options.path);\n\n  args.requestUrls.push(parsedUrl.href);\n\n  function onResponse(res) {\n    socketHandledResponses = res.socket[SOCKET_RESPONSE_COUNT] = (res.socket[SOCKET_RESPONSE_COUNT] || 0) + 1;\n    if (timing) {\n      timing.waiting = Date.now() - requestStartTime;\n    }\n    debug('Request#%d %s `req response` event emit: status %d, headers: %j',\n      reqId, url, res.statusCode, res.headers);\n\n    if (args.streaming) {\n      var result = handleRedirect(res);\n      if (result.redirect) {\n        res.resume();\n        createAndEmitResponseEvent(null, res);\n        return;\n      }\n      if (result.error) {\n        res.resume();\n        return done(result.error, null, res);\n      }\n\n      return done(null, null, res);\n    }\n\n    res.on('error', function () {\n      debug('Request#%d %s: `res error` event emit, total size %d, socket handled %s requests and %s responses',\n        reqId, url, responseSize, socketHandledRequests, socketHandledResponses);\n    });\n\n    res.on('aborted', function () {\n      responseAborted = true;\n      debug('Request#%d %s: `res aborted` event emit, total size %d',\n        reqId, url, responseSize);\n    });\n\n    if (writeStream) {\n      // If there's a writable stream to recieve the response data, just pipe the\n      // response stream to that writable stream and call the callback when it has\n      // finished writing.\n      //\n      // NOTE that when the response stream `res` emits an 'end' event it just\n      // means that it has finished piping data to another stream. In the\n      // meanwhile that writable stream may still writing data to the disk until\n      // it emits a 'close' event.\n      //\n      // That means that we should not apply callback until the 'close' of the\n      // writable stream is emited.\n      //\n      // See also:\n      // - https://github.com/TBEDP/urllib/commit/959ac3365821e0e028c231a5e8efca6af410eabb\n      // - http://nodejs.org/api/stream.html#stream_event_end\n      // - http://nodejs.org/api/stream.html#stream_event_close_1\n      var result = handleRedirect(res);\n      if (result.redirect) {\n        res.resume();\n        createAndEmitResponseEvent(null, res);\n        return;\n      }\n      if (result.error) {\n        res.resume();\n        // end ths stream first\n        writeStream.end();\n        done(result.error, null, res);\n        return;\n      }\n\n      // you can set consumeWriteStream false that only wait response end\n      if (args.consumeWriteStream === false) {\n        res.on('end', done.bind(null, null, null, res));\n        pump(res, writeStream, function(err) {\n          if (isWriteStreamClose) {\n            return;\n          }\n          isWriteStreamClose = true;\n          debug('Request#%d %s: writeStream close, error: %s', reqId, url, err);\n        });\n        return;\n      }\n\n      // node 0.10, 0.12: only emit res aborted, writeStream close not fired\n      if (isNode010 || isNode012) {\n        first([\n          [ writeStream, 'close' ],\n          [ res, 'aborted' ],\n        ], function(_, stream, event) {\n          debug('Request#%d %s: writeStream or res %s event emitted', reqId, url, event);\n          done(__err || null, null, res);\n        });\n        res.pipe(writeStream);\n        return;\n      }\n\n      debug('Request#%d %s: pump res to writeStream', reqId, url);\n      pump(res, writeStream, function(err) {\n        debug('Request#%d %s: writeStream close event emitted, error: %s, isWriteStreamClose: %s',\n          reqId, url, err, isWriteStreamClose);\n        if (isWriteStreamClose) {\n          return;\n        }\n        isWriteStreamClose = true;\n        done(__err || err, null, res);\n      });\n      return;\n    }\n\n    // Otherwise, just concat those buffers.\n    //\n    // NOTE that the `chunk` is not a String but a Buffer. It means that if\n    // you simply concat two chunk with `+` you're actually converting both\n    // Buffers into Strings before concating them. It'll cause problems when\n    // dealing with multi-byte characters.\n    //\n    // The solution is to store each chunk in an array and concat them with\n    // 'buffer-concat' when all chunks is recieved.\n    //\n    // See also:\n    // http://cnodejs.org/topic/4faf65852e8fb5bc65113403\n\n    var chunks = [];\n\n    res.on('data', function (chunk) {\n      debug('Request#%d %s: `res data` event emit, size %d', reqId, url, chunk.length);\n      responseSize += chunk.length;\n      chunks.push(chunk);\n    });\n\n    var isEmitted = false;\n    function handleResponseCloseAndEnd(event) {\n      debug('Request#%d %s: `res %s` event emit, total size %d, socket handled %s requests and %s responses',\n        reqId, url, event, responseSize, socketHandledRequests, socketHandledResponses);\n      if (isEmitted) {\n        return;\n      }\n      isEmitted = true;\n\n      var body = Buffer.concat(chunks, responseSize);\n      debug('Request#%d %s: _dumped: %s',\n        reqId, url, res._dumped);\n\n      if (__err) {\n        // req.abort() after `res data` event emit.\n        return done(__err, body, res);\n      }\n\n      var result = handleRedirect(res);\n      if (result.error) {\n        return done(result.error, body, res);\n      }\n      if (result.redirect) {\n        createAndEmitResponseEvent(null, res);\n        return;\n      }\n\n      decodeContent(res, body, function (err, data, encoding) {\n        if (err) {\n          return done(err, body, res);\n        }\n        // if body not decode, dont touch it\n        if (!encoding && TEXT_DATA_TYPES.indexOf(args.dataType) >= 0) {\n          // try to decode charset\n          try {\n            data = decodeBodyByCharset(data, res);\n          } catch (e) {\n            debug('decodeBodyByCharset error: %s', e);\n            // if error, dont touch it\n            return done(null, data, res);\n          }\n\n          if (args.dataType === 'json') {\n            if (responseSize === 0) {\n              data = null;\n            } else {\n              var r = parseJSON(data, fixJSONCtlChars);\n              if (r.error) {\n                err = r.error;\n              } else {\n                data = r.data;\n              }\n            }\n          }\n        }\n\n        if (responseAborted) {\n          // err = new Error('Remote socket was terminated before `response.end()` was called');\n          // err.name = 'RemoteSocketClosedError';\n          debug('Request#%d %s: Remote socket was terminated before `response.end()` was called', reqId, url);\n        }\n\n        done(err, data, res);\n      });\n    }\n\n    // node >= 14 only emit close if req abort\n    res.on('close', function () {\n      handleResponseCloseAndEnd('close');\n    });\n    res.on('end', function () {\n      handleResponseCloseAndEnd('end');\n    });\n  }\n\n  var connectTimeout, responseTimeout;\n  if (Array.isArray(args.timeout)) {\n    connectTimeout = ms(args.timeout[0]);\n    responseTimeout = ms(args.timeout[1]);\n  } else {  // set both timeout equal\n    connectTimeout = responseTimeout = ms(args.timeout);\n  }\n  debug('ConnectTimeout: %d, ResponseTimeout: %d', connectTimeout, responseTimeout);\n\n  function startConnectTimer() {\n    debug('Connect timer ticking, timeout: %d', connectTimeout);\n    connectTimer = setTimeout(function () {\n      connectTimer = null;\n      if (statusCode === -1) {\n        statusCode = -2;\n      }\n      var msg = 'Connect timeout for ' + connectTimeout + 'ms';\n      var errorName = 'ConnectionTimeoutError';\n      if (!req.socket) {\n        errorName = 'SocketAssignTimeoutError';\n        msg += ', working sockets is full';\n      }\n      __err = new Error(msg);\n      __err.name = errorName;\n      __err.requestId = reqId;\n      debug('ConnectTimeout: Request#%d %s %s: %s, connected: %s', reqId, url, __err.name, msg, connected);\n      abortRequest();\n    }, connectTimeout);\n  }\n\n  function startResposneTimer() {\n    debug('Response timer ticking, timeout: %d', responseTimeout);\n    responseTimer = setTimeout(function () {\n      responseTimer = null;\n      var msg = 'Response timeout for ' + responseTimeout + 'ms';\n      var errorName = 'ResponseTimeoutError';\n      __err = new Error(msg);\n      __err.name = errorName;\n      __err.requestId = reqId;\n      debug('ResponseTimeout: Request#%d %s %s: %s, connected: %s', reqId, url, __err.name, msg, connected);\n      abortRequest();\n    }, responseTimeout);\n  }\n\n  if (args.checkAddress) {\n    var hostname = parsedUrl.hostname;\n    // if request hostname is ip, custom lookup wont excute\n    var family = null;\n    if (ip.isV4Format(hostname)) {\n      family = 4;\n    } else if (ip.isV6Format(hostname)) {\n      family = 6;\n    }\n    if (family) {\n      if (!args.checkAddress(hostname, family)) {\n        var err = new Error('illegal address');\n        err.name = 'IllegalAddressError';\n        err.hostname = hostname;\n        err.ip = hostname;\n        err.family = family;\n        return done(err);\n      }\n    }\n  }\n\n  // request headers checker will throw error\n  try {\n    var finalOptions = options;\n\n    // restore origin header key\n    if (args.keepHeaderCase) {\n      var originKeys = Object.keys(originHeaderKeys);\n      if (originKeys.length) {\n        var finalHeaders = {};\n        var names = utility.getOwnEnumerables(options.headers, true);\n        for (var i = 0; i < names.length; i++) {\n          var name = names[i];\n          finalHeaders[originHeaderKeys[name] || name] = options.headers[name];\n        }\n\n        finalOptions = Object.assign({}, options);\n        finalOptions.headers = finalHeaders;\n      }\n    }\n\n    req = httplib.request(finalOptions, onResponse);\n    if (args.trace) {\n      req._callSite = {};\n      Error.captureStackTrace(req._callSite, requestWithCallback);\n    }\n  } catch (err) {\n    return done(err);\n  }\n\n  // environment detection: browser or nodejs\n  if (typeof(window) === 'undefined') {\n    // start connect timer just after `request` return, and just in nodejs environment\n    startConnectTimer();\n  }\n\n  var isRequestAborted = false;\n  function abortRequest() {\n    if (isRequestAborted) {\n      return;\n    }\n    isRequestAborted = true;\n\n    debug('Request#%d %s abort, connected: %s', reqId, url, connected);\n    // it wont case error event when req haven't been assigned a socket yet.\n    if (!req.socket) {\n      __err.noSocket = true;\n      done(__err);\n    }\n    req.abort();\n  }\n\n  if (timing) {\n    // request sent\n    req.on('finish', function() {\n      timing.requestSent = Date.now() - requestStartTime;\n    });\n  }\n\n  req.once('socket', function (socket) {\n    if (timing) {\n      // socket queuing time\n      timing.queuing = Date.now() - requestStartTime;\n    }\n\n    // https://github.com/nodejs/node/blob/master/lib/net.js#L377\n    // https://github.com/nodejs/node/blob/v0.10.40-release/lib/net.js#L352\n    // should use socket.socket on 0.10.x\n    if (isNode010 && socket.socket) {\n      socket = socket.socket;\n    }\n\n    var orginalSocketTimeout = getSocketTimeout(socket);\n    if (orginalSocketTimeout && orginalSocketTimeout < responseTimeout) {\n      // make sure socket live longer than the response timer\n      var socketTimeout = responseTimeout + 500;\n      debug('Request#%d socket.timeout(%s) < responseTimeout(%s), reset socket timeout to %s',\n        reqId, orginalSocketTimeout, responseTimeout, socketTimeout);\n      socket.setTimeout(socketTimeout);\n    }\n\n    socketHandledRequests = socket[SOCKET_REQUEST_COUNT] = (socket[SOCKET_REQUEST_COUNT] || 0) + 1;\n    if (socket[SOCKET_RESPONSE_COUNT]) {\n      socketHandledResponses = socket[SOCKET_RESPONSE_COUNT];\n    }\n\n    var readyState = socket.readyState;\n    if (readyState === 'opening') {\n      socket.once('lookup', function(err, ip, addressType) {\n        debug('Request#%d %s lookup: %s, %s, %s', reqId, url, err, ip, addressType);\n        if (timing) {\n          timing.dnslookup = Date.now() - requestStartTime;\n        }\n        if (ip) {\n          remoteAddress = ip;\n        }\n      });\n      socket.once('connect', function() {\n        if (timing) {\n          // socket connected\n          timing.connected = Date.now() - requestStartTime;\n        }\n\n        // cancel socket timer at first and start tick for TTFB\n        cancelConnectTimer();\n        startResposneTimer();\n\n        debug('Request#%d %s new socket connected', reqId, url);\n        connected = true;\n        if (!remoteAddress) {\n          remoteAddress = socket.remoteAddress;\n        }\n        remotePort = socket.remotePort;\n      });\n      return;\n    }\n\n    debug('Request#%d %s reuse socket connected, readyState: %s', reqId, url, readyState);\n    connected = true;\n    keepAliveSocket = true;\n    if (!remoteAddress) {\n      remoteAddress = socket.remoteAddress;\n    }\n    remotePort = socket.remotePort;\n\n    // reuse socket, timer should be canceled.\n    cancelConnectTimer();\n    startResposneTimer();\n  });\n\n  if (writeStream) {\n    writeStream.once('error', function(err) {\n      err.message += ' (writeStream \"error\")';\n      __err = err;\n      debug('Request#%d %s `writeStream error` event emit, %s: %s', reqId, url, err.name, err.message);\n      abortRequest();\n    });\n  }\n\n  var isRequestError = false;\n  function handleRequestError(err) {\n    if (isRequestError || !err) {\n      return;\n    }\n    isRequestError = true;\n\n    if (err.name === 'Error') {\n      err.name = connected ? 'ResponseError' : 'RequestError';\n    }\n    debug('Request#%d %s `req error` event emit, %s: %s', reqId, url, err.name, err.message);\n    done(__err || err);\n  }\n  if (args.stream) {\n    debug('Request#%d pump args.stream to req', reqId);\n    pump(args.stream, req, handleRequestError);\n  } else {\n    req.end(body);\n  }\n  // when stream already consumed, req's `finish` event is emitted and pump will ignore error after pipe finished\n  // but if server response timeout later, we will abort the request and emit an error in req\n  // so we must always manually listen to req's `error` event here to ensure this error is handled\n  req.on('error', handleRequestError);\n  req.requestId = reqId;\n  return req;\n}\n\nexports.requestWithCallback = requestWithCallback;\n\nvar JSONCtlCharsMap = {\n  '\"': '\\\\\"',       // \\u0022\n  '\\\\': '\\\\\\\\',     // \\u005c\n  '\\b': '\\\\b',      // \\u0008\n  '\\f': '\\\\f',      // \\u000c\n  '\\n': '\\\\n',      // \\u000a\n  '\\r': '\\\\r',      // \\u000d\n  '\\t': '\\\\t'       // \\u0009\n};\nvar JSONCtlCharsRE = /[\\u0000-\\u001F\\u005C]/g;\n\nfunction _replaceOneChar(c) {\n  return JSONCtlCharsMap[c] || '\\\\u' + (c.charCodeAt(0) + 0x10000).toString(16).substr(1);\n}\n\nfunction replaceJSONCtlChars(str) {\n  return str.replace(JSONCtlCharsRE, _replaceOneChar);\n}\n\nfunction parseJSON(data, fixJSONCtlChars) {\n  var result = {\n    error: null,\n    data: null\n  };\n  if (fixJSONCtlChars) {\n    if (typeof fixJSONCtlChars === 'function') {\n      data = fixJSONCtlChars(data);\n    } else {\n      // https://github.com/node-modules/urllib/pull/77\n      // remote the control characters (U+0000 through U+001F)\n      data = replaceJSONCtlChars(data);\n    }\n  }\n  try {\n    result.data = JSON.parse(data);\n  } catch (err) {\n    if (err.name === 'SyntaxError') {\n      err.name = 'JSONResponseFormatError';\n    }\n    if (data.length > 1024) {\n      // show 0~512 ... -512~end data\n      err.message += ' (data json format: ' +\n        JSON.stringify(data.slice(0, 512)) + ' ...skip... ' + JSON.stringify(data.slice(data.length - 512)) + ')';\n    } else {\n      err.message += ' (data json format: ' + JSON.stringify(data) + ')';\n    }\n    result.error = err;\n  }\n  return result;\n}\n\n\n/**\n * decode response body by parse `content-type`'s charset\n * @param {Buffer} data\n * @param {Http(s)Response} res\n * @return {String}\n */\nfunction decodeBodyByCharset(data, res) {\n  var type = res.headers['content-type'];\n  if (!type) {\n    return data.toString();\n  }\n\n  var type = parseContentType(type);\n  var charset = type.parameters.charset || 'utf-8';\n\n  if (!Buffer.isEncoding(charset)) {\n    if (!_iconv) {\n      _iconv = require('iconv-lite');\n    }\n    return _iconv.decode(data, charset);\n  }\n\n  return data.toString(charset);\n}\n\nfunction getAgent(agent, defaultAgent) {\n  return agent === undefined ? defaultAgent : agent;\n}\n\nfunction parseContentType(str) {\n  try {\n    return contentTypeParser.parse(str);\n  } catch (err) {\n    // ignore content-type error, tread as default\n    return { parameters: {} };\n  }\n}\n\nfunction addLongStackTrace(err, req) {\n  if (!req) {\n    return;\n  }\n  var callSiteStack = req._callSite && req._callSite.stack;\n  if (!callSiteStack || typeof callSiteStack !== 'string') {\n    return;\n  }\n  if (err._longStack) {\n    return;\n  }\n  var index = callSiteStack.indexOf('\\n');\n  if (index !== -1) {\n    err._longStack = true;\n    err.stack += LONG_STACK_DELIMITER + callSiteStack.substr(index + 1);\n  }\n}\n\n// node 8 don't has timeout attribute on socket\n// https://github.com/nodejs/node/pull/21204/files#diff-e6ef024c3775d787c38487a6309e491dR408\nfunction getSocketTimeout(socket) {\n  return socket.timeout || socket._idleTimeout;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}