{"ast":null,"code":"\"use strict\";\n\n;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar types_1 = tslib_1.__importDefault(require(\"./types\"));\n\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction scopePlugin(fork) {\n  var types = fork.use(types_1.default);\n  var Type = types.Type;\n  var namedTypes = types.namedTypes;\n  var Node = namedTypes.Node;\n  var Expression = namedTypes.Expression;\n  var isArray = types.builtInTypes.array;\n  var b = types.builders;\n\n  var Scope = function Scope(path, parentScope) {\n    if (!(this instanceof Scope)) {\n      throw new Error(\"Scope constructor cannot be invoked without 'new'\");\n    }\n\n    ScopeType.assert(path.value);\n    var depth;\n\n    if (parentScope) {\n      if (!(parentScope instanceof Scope)) {\n        throw new Error(\"\");\n      }\n\n      depth = parentScope.depth + 1;\n    } else {\n      parentScope = null;\n      depth = 0;\n    }\n\n    Object.defineProperties(this, {\n      path: {\n        value: path\n      },\n      node: {\n        value: path.value\n      },\n      isGlobal: {\n        value: !parentScope,\n        enumerable: true\n      },\n      depth: {\n        value: depth\n      },\n      parent: {\n        value: parentScope\n      },\n      bindings: {\n        value: {}\n      },\n      types: {\n        value: {}\n      }\n    });\n  };\n\n  var scopeTypes = [// Program nodes introduce global scopes.\n  namedTypes.Program, // Function is the supertype of FunctionExpression,\n  // FunctionDeclaration, ArrowExpression, etc.\n  namedTypes.Function, // In case you didn't know, the caught parameter shadows any variable\n  // of the same name in an outer scope.\n  namedTypes.CatchClause];\n  var ScopeType = Type.or.apply(Type, scopeTypes);\n\n  Scope.isEstablishedBy = function (node) {\n    return ScopeType.check(node);\n  };\n\n  var Sp = Scope.prototype; // Will be overridden after an instance lazily calls scanScope.\n\n  Sp.didScan = false;\n\n  Sp.declares = function (name) {\n    this.scan();\n    return hasOwn.call(this.bindings, name);\n  };\n\n  Sp.declaresType = function (name) {\n    this.scan();\n    return hasOwn.call(this.types, name);\n  };\n\n  Sp.declareTemporary = function (prefix) {\n    if (prefix) {\n      if (!/^[a-z$_]/i.test(prefix)) {\n        throw new Error(\"\");\n      }\n    } else {\n      prefix = \"t$\";\n    } // Include this.depth in the name to make sure the name does not\n    // collide with any variables in nested/enclosing scopes.\n\n\n    prefix += this.depth.toString(36) + \"$\";\n    this.scan();\n    var index = 0;\n\n    while (this.declares(prefix + index)) {\n      ++index;\n    }\n\n    var name = prefix + index;\n    return this.bindings[name] = types.builders.identifier(name);\n  };\n\n  Sp.injectTemporary = function (identifier, init) {\n    identifier || (identifier = this.declareTemporary());\n    var bodyPath = this.path.get(\"body\");\n\n    if (namedTypes.BlockStatement.check(bodyPath.value)) {\n      bodyPath = bodyPath.get(\"body\");\n    }\n\n    bodyPath.unshift(b.variableDeclaration(\"var\", [b.variableDeclarator(identifier, init || null)]));\n    return identifier;\n  };\n\n  Sp.scan = function (force) {\n    if (force || !this.didScan) {\n      for (var name in this.bindings) {\n        // Empty out this.bindings, just in cases.\n        delete this.bindings[name];\n      }\n\n      scanScope(this.path, this.bindings, this.types);\n      this.didScan = true;\n    }\n  };\n\n  Sp.getBindings = function () {\n    this.scan();\n    return this.bindings;\n  };\n\n  Sp.getTypes = function () {\n    this.scan();\n    return this.types;\n  };\n\n  function scanScope(path, bindings, scopeTypes) {\n    var node = path.value;\n    ScopeType.assert(node);\n\n    if (namedTypes.CatchClause.check(node)) {\n      // A catch clause establishes a new scope but the only variable\n      // bound in that scope is the catch parameter. Any other\n      // declarations create bindings in the outer scope.\n      var param = path.get(\"param\");\n\n      if (param.value) {\n        addPattern(param, bindings);\n      }\n    } else {\n      recursiveScanScope(path, bindings, scopeTypes);\n    }\n  }\n\n  function recursiveScanScope(path, bindings, scopeTypes) {\n    var node = path.value;\n\n    if (path.parent && namedTypes.FunctionExpression.check(path.parent.node) && path.parent.node.id) {\n      addPattern(path.parent.get(\"id\"), bindings);\n    }\n\n    if (!node) {// None of the remaining cases matter if node is falsy.\n    } else if (isArray.check(node)) {\n      path.each(function (childPath) {\n        recursiveScanChild(childPath, bindings, scopeTypes);\n      });\n    } else if (namedTypes.Function.check(node)) {\n      path.get(\"params\").each(function (paramPath) {\n        addPattern(paramPath, bindings);\n      });\n      recursiveScanChild(path.get(\"body\"), bindings, scopeTypes);\n    } else if (namedTypes.TypeAlias && namedTypes.TypeAlias.check(node) || namedTypes.InterfaceDeclaration && namedTypes.InterfaceDeclaration.check(node) || namedTypes.TSTypeAliasDeclaration && namedTypes.TSTypeAliasDeclaration.check(node) || namedTypes.TSInterfaceDeclaration && namedTypes.TSInterfaceDeclaration.check(node)) {\n      addTypePattern(path.get(\"id\"), scopeTypes);\n    } else if (namedTypes.VariableDeclarator.check(node)) {\n      addPattern(path.get(\"id\"), bindings);\n      recursiveScanChild(path.get(\"init\"), bindings, scopeTypes);\n    } else if (node.type === \"ImportSpecifier\" || node.type === \"ImportNamespaceSpecifier\" || node.type === \"ImportDefaultSpecifier\") {\n      addPattern( // Esprima used to use the .name field to refer to the local\n      // binding identifier for ImportSpecifier nodes, but .id for\n      // ImportNamespaceSpecifier and ImportDefaultSpecifier nodes.\n      // ESTree/Acorn/ESpree use .local for all three node types.\n      path.get(node.local ? \"local\" : node.name ? \"name\" : \"id\"), bindings);\n    } else if (Node.check(node) && !Expression.check(node)) {\n      types.eachField(node, function (name, child) {\n        var childPath = path.get(name);\n\n        if (!pathHasValue(childPath, child)) {\n          throw new Error(\"\");\n        }\n\n        recursiveScanChild(childPath, bindings, scopeTypes);\n      });\n    }\n  }\n\n  function pathHasValue(path, value) {\n    if (path.value === value) {\n      return true;\n    } // Empty arrays are probably produced by defaults.emptyArray, in which\n    // case is makes sense to regard them as equivalent, if not ===.\n\n\n    if (Array.isArray(path.value) && path.value.length === 0 && Array.isArray(value) && value.length === 0) {\n      return true;\n    }\n\n    return false;\n  }\n\n  function recursiveScanChild(path, bindings, scopeTypes) {\n    var node = path.value;\n\n    if (!node || Expression.check(node)) {// Ignore falsy values and Expressions.\n    } else if (namedTypes.FunctionDeclaration.check(node) && node.id !== null) {\n      addPattern(path.get(\"id\"), bindings);\n    } else if (namedTypes.ClassDeclaration && namedTypes.ClassDeclaration.check(node)) {\n      addPattern(path.get(\"id\"), bindings);\n    } else if (ScopeType.check(node)) {\n      if (namedTypes.CatchClause.check(node) && // TODO Broaden this to accept any pattern.\n      namedTypes.Identifier.check(node.param)) {\n        var catchParamName = node.param.name;\n        var hadBinding = hasOwn.call(bindings, catchParamName); // Any declarations that occur inside the catch body that do\n        // not have the same name as the catch parameter should count\n        // as bindings in the outer scope.\n\n        recursiveScanScope(path.get(\"body\"), bindings, scopeTypes); // If a new binding matching the catch parameter name was\n        // created while scanning the catch body, ignore it because it\n        // actually refers to the catch parameter and not the outer\n        // scope that we're currently scanning.\n\n        if (!hadBinding) {\n          delete bindings[catchParamName];\n        }\n      }\n    } else {\n      recursiveScanScope(path, bindings, scopeTypes);\n    }\n  }\n\n  function addPattern(patternPath, bindings) {\n    var pattern = patternPath.value;\n    namedTypes.Pattern.assert(pattern);\n\n    if (namedTypes.Identifier.check(pattern)) {\n      if (hasOwn.call(bindings, pattern.name)) {\n        bindings[pattern.name].push(patternPath);\n      } else {\n        bindings[pattern.name] = [patternPath];\n      }\n    } else if (namedTypes.AssignmentPattern && namedTypes.AssignmentPattern.check(pattern)) {\n      addPattern(patternPath.get('left'), bindings);\n    } else if (namedTypes.ObjectPattern && namedTypes.ObjectPattern.check(pattern)) {\n      patternPath.get('properties').each(function (propertyPath) {\n        var property = propertyPath.value;\n\n        if (namedTypes.Pattern.check(property)) {\n          addPattern(propertyPath, bindings);\n        } else if (namedTypes.Property.check(property)) {\n          addPattern(propertyPath.get('value'), bindings);\n        } else if (namedTypes.SpreadProperty && namedTypes.SpreadProperty.check(property)) {\n          addPattern(propertyPath.get('argument'), bindings);\n        }\n      });\n    } else if (namedTypes.ArrayPattern && namedTypes.ArrayPattern.check(pattern)) {\n      patternPath.get('elements').each(function (elementPath) {\n        var element = elementPath.value;\n\n        if (namedTypes.Pattern.check(element)) {\n          addPattern(elementPath, bindings);\n        } else if (namedTypes.SpreadElement && namedTypes.SpreadElement.check(element)) {\n          addPattern(elementPath.get(\"argument\"), bindings);\n        }\n      });\n    } else if (namedTypes.PropertyPattern && namedTypes.PropertyPattern.check(pattern)) {\n      addPattern(patternPath.get('pattern'), bindings);\n    } else if (namedTypes.SpreadElementPattern && namedTypes.SpreadElementPattern.check(pattern) || namedTypes.SpreadPropertyPattern && namedTypes.SpreadPropertyPattern.check(pattern)) {\n      addPattern(patternPath.get('argument'), bindings);\n    }\n  }\n\n  function addTypePattern(patternPath, types) {\n    var pattern = patternPath.value;\n    namedTypes.Pattern.assert(pattern);\n\n    if (namedTypes.Identifier.check(pattern)) {\n      if (hasOwn.call(types, pattern.name)) {\n        types[pattern.name].push(patternPath);\n      } else {\n        types[pattern.name] = [patternPath];\n      }\n    }\n  }\n\n  Sp.lookup = function (name) {\n    for (var scope = this; scope; scope = scope.parent) if (scope.declares(name)) break;\n\n    return scope;\n  };\n\n  Sp.lookupType = function (name) {\n    for (var scope = this; scope; scope = scope.parent) if (scope.declaresType(name)) break;\n\n    return scope;\n  };\n\n  Sp.getGlobalScope = function () {\n    var scope = this;\n\n    while (!scope.isGlobal) scope = scope.parent;\n\n    return scope;\n  };\n\n  return Scope;\n}\n\nexports.default = scopePlugin;\nmodule.exports = exports[\"default\"];","map":{"version":3,"names":["Object","defineProperty","exports","value","tslib_1","require","types_1","__importDefault","hasOwn","prototype","hasOwnProperty","scopePlugin","fork","types","use","default","Type","namedTypes","Node","Expression","isArray","builtInTypes","array","b","builders","Scope","path","parentScope","Error","ScopeType","assert","depth","defineProperties","node","isGlobal","enumerable","parent","bindings","scopeTypes","Program","Function","CatchClause","or","apply","isEstablishedBy","check","Sp","didScan","declares","name","scan","call","declaresType","declareTemporary","prefix","test","toString","index","identifier","injectTemporary","init","bodyPath","get","BlockStatement","unshift","variableDeclaration","variableDeclarator","force","scanScope","getBindings","getTypes","param","addPattern","recursiveScanScope","FunctionExpression","id","each","childPath","recursiveScanChild","paramPath","TypeAlias","InterfaceDeclaration","TSTypeAliasDeclaration","TSInterfaceDeclaration","addTypePattern","VariableDeclarator","type","local","eachField","child","pathHasValue","Array","length","FunctionDeclaration","ClassDeclaration","Identifier","catchParamName","hadBinding","patternPath","pattern","Pattern","push","AssignmentPattern","ObjectPattern","propertyPath","property","Property","SpreadProperty","ArrayPattern","elementPath","element","SpreadElement","PropertyPattern","SpreadElementPattern","SpreadPropertyPattern","lookup","scope","lookupType","getGlobalScope","module"],"sources":["C:/Users/bryan/Desktop/myrepresentatives/frontend/node_modules/ast-types/lib/scope.js"],"sourcesContent":["\"use strict\";;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar types_1 = tslib_1.__importDefault(require(\"./types\"));\nvar hasOwn = Object.prototype.hasOwnProperty;\nfunction scopePlugin(fork) {\n    var types = fork.use(types_1.default);\n    var Type = types.Type;\n    var namedTypes = types.namedTypes;\n    var Node = namedTypes.Node;\n    var Expression = namedTypes.Expression;\n    var isArray = types.builtInTypes.array;\n    var b = types.builders;\n    var Scope = function Scope(path, parentScope) {\n        if (!(this instanceof Scope)) {\n            throw new Error(\"Scope constructor cannot be invoked without 'new'\");\n        }\n        ScopeType.assert(path.value);\n        var depth;\n        if (parentScope) {\n            if (!(parentScope instanceof Scope)) {\n                throw new Error(\"\");\n            }\n            depth = parentScope.depth + 1;\n        }\n        else {\n            parentScope = null;\n            depth = 0;\n        }\n        Object.defineProperties(this, {\n            path: { value: path },\n            node: { value: path.value },\n            isGlobal: { value: !parentScope, enumerable: true },\n            depth: { value: depth },\n            parent: { value: parentScope },\n            bindings: { value: {} },\n            types: { value: {} },\n        });\n    };\n    var scopeTypes = [\n        // Program nodes introduce global scopes.\n        namedTypes.Program,\n        // Function is the supertype of FunctionExpression,\n        // FunctionDeclaration, ArrowExpression, etc.\n        namedTypes.Function,\n        // In case you didn't know, the caught parameter shadows any variable\n        // of the same name in an outer scope.\n        namedTypes.CatchClause\n    ];\n    var ScopeType = Type.or.apply(Type, scopeTypes);\n    Scope.isEstablishedBy = function (node) {\n        return ScopeType.check(node);\n    };\n    var Sp = Scope.prototype;\n    // Will be overridden after an instance lazily calls scanScope.\n    Sp.didScan = false;\n    Sp.declares = function (name) {\n        this.scan();\n        return hasOwn.call(this.bindings, name);\n    };\n    Sp.declaresType = function (name) {\n        this.scan();\n        return hasOwn.call(this.types, name);\n    };\n    Sp.declareTemporary = function (prefix) {\n        if (prefix) {\n            if (!/^[a-z$_]/i.test(prefix)) {\n                throw new Error(\"\");\n            }\n        }\n        else {\n            prefix = \"t$\";\n        }\n        // Include this.depth in the name to make sure the name does not\n        // collide with any variables in nested/enclosing scopes.\n        prefix += this.depth.toString(36) + \"$\";\n        this.scan();\n        var index = 0;\n        while (this.declares(prefix + index)) {\n            ++index;\n        }\n        var name = prefix + index;\n        return this.bindings[name] = types.builders.identifier(name);\n    };\n    Sp.injectTemporary = function (identifier, init) {\n        identifier || (identifier = this.declareTemporary());\n        var bodyPath = this.path.get(\"body\");\n        if (namedTypes.BlockStatement.check(bodyPath.value)) {\n            bodyPath = bodyPath.get(\"body\");\n        }\n        bodyPath.unshift(b.variableDeclaration(\"var\", [b.variableDeclarator(identifier, init || null)]));\n        return identifier;\n    };\n    Sp.scan = function (force) {\n        if (force || !this.didScan) {\n            for (var name in this.bindings) {\n                // Empty out this.bindings, just in cases.\n                delete this.bindings[name];\n            }\n            scanScope(this.path, this.bindings, this.types);\n            this.didScan = true;\n        }\n    };\n    Sp.getBindings = function () {\n        this.scan();\n        return this.bindings;\n    };\n    Sp.getTypes = function () {\n        this.scan();\n        return this.types;\n    };\n    function scanScope(path, bindings, scopeTypes) {\n        var node = path.value;\n        ScopeType.assert(node);\n        if (namedTypes.CatchClause.check(node)) {\n            // A catch clause establishes a new scope but the only variable\n            // bound in that scope is the catch parameter. Any other\n            // declarations create bindings in the outer scope.\n            var param = path.get(\"param\");\n            if (param.value) {\n                addPattern(param, bindings);\n            }\n        }\n        else {\n            recursiveScanScope(path, bindings, scopeTypes);\n        }\n    }\n    function recursiveScanScope(path, bindings, scopeTypes) {\n        var node = path.value;\n        if (path.parent &&\n            namedTypes.FunctionExpression.check(path.parent.node) &&\n            path.parent.node.id) {\n            addPattern(path.parent.get(\"id\"), bindings);\n        }\n        if (!node) {\n            // None of the remaining cases matter if node is falsy.\n        }\n        else if (isArray.check(node)) {\n            path.each(function (childPath) {\n                recursiveScanChild(childPath, bindings, scopeTypes);\n            });\n        }\n        else if (namedTypes.Function.check(node)) {\n            path.get(\"params\").each(function (paramPath) {\n                addPattern(paramPath, bindings);\n            });\n            recursiveScanChild(path.get(\"body\"), bindings, scopeTypes);\n        }\n        else if ((namedTypes.TypeAlias && namedTypes.TypeAlias.check(node)) ||\n            (namedTypes.InterfaceDeclaration && namedTypes.InterfaceDeclaration.check(node)) ||\n            (namedTypes.TSTypeAliasDeclaration && namedTypes.TSTypeAliasDeclaration.check(node)) ||\n            (namedTypes.TSInterfaceDeclaration && namedTypes.TSInterfaceDeclaration.check(node))) {\n            addTypePattern(path.get(\"id\"), scopeTypes);\n        }\n        else if (namedTypes.VariableDeclarator.check(node)) {\n            addPattern(path.get(\"id\"), bindings);\n            recursiveScanChild(path.get(\"init\"), bindings, scopeTypes);\n        }\n        else if (node.type === \"ImportSpecifier\" ||\n            node.type === \"ImportNamespaceSpecifier\" ||\n            node.type === \"ImportDefaultSpecifier\") {\n            addPattern(\n            // Esprima used to use the .name field to refer to the local\n            // binding identifier for ImportSpecifier nodes, but .id for\n            // ImportNamespaceSpecifier and ImportDefaultSpecifier nodes.\n            // ESTree/Acorn/ESpree use .local for all three node types.\n            path.get(node.local ? \"local\" :\n                node.name ? \"name\" : \"id\"), bindings);\n        }\n        else if (Node.check(node) && !Expression.check(node)) {\n            types.eachField(node, function (name, child) {\n                var childPath = path.get(name);\n                if (!pathHasValue(childPath, child)) {\n                    throw new Error(\"\");\n                }\n                recursiveScanChild(childPath, bindings, scopeTypes);\n            });\n        }\n    }\n    function pathHasValue(path, value) {\n        if (path.value === value) {\n            return true;\n        }\n        // Empty arrays are probably produced by defaults.emptyArray, in which\n        // case is makes sense to regard them as equivalent, if not ===.\n        if (Array.isArray(path.value) &&\n            path.value.length === 0 &&\n            Array.isArray(value) &&\n            value.length === 0) {\n            return true;\n        }\n        return false;\n    }\n    function recursiveScanChild(path, bindings, scopeTypes) {\n        var node = path.value;\n        if (!node || Expression.check(node)) {\n            // Ignore falsy values and Expressions.\n        }\n        else if (namedTypes.FunctionDeclaration.check(node) &&\n            node.id !== null) {\n            addPattern(path.get(\"id\"), bindings);\n        }\n        else if (namedTypes.ClassDeclaration &&\n            namedTypes.ClassDeclaration.check(node)) {\n            addPattern(path.get(\"id\"), bindings);\n        }\n        else if (ScopeType.check(node)) {\n            if (namedTypes.CatchClause.check(node) &&\n                // TODO Broaden this to accept any pattern.\n                namedTypes.Identifier.check(node.param)) {\n                var catchParamName = node.param.name;\n                var hadBinding = hasOwn.call(bindings, catchParamName);\n                // Any declarations that occur inside the catch body that do\n                // not have the same name as the catch parameter should count\n                // as bindings in the outer scope.\n                recursiveScanScope(path.get(\"body\"), bindings, scopeTypes);\n                // If a new binding matching the catch parameter name was\n                // created while scanning the catch body, ignore it because it\n                // actually refers to the catch parameter and not the outer\n                // scope that we're currently scanning.\n                if (!hadBinding) {\n                    delete bindings[catchParamName];\n                }\n            }\n        }\n        else {\n            recursiveScanScope(path, bindings, scopeTypes);\n        }\n    }\n    function addPattern(patternPath, bindings) {\n        var pattern = patternPath.value;\n        namedTypes.Pattern.assert(pattern);\n        if (namedTypes.Identifier.check(pattern)) {\n            if (hasOwn.call(bindings, pattern.name)) {\n                bindings[pattern.name].push(patternPath);\n            }\n            else {\n                bindings[pattern.name] = [patternPath];\n            }\n        }\n        else if (namedTypes.AssignmentPattern &&\n            namedTypes.AssignmentPattern.check(pattern)) {\n            addPattern(patternPath.get('left'), bindings);\n        }\n        else if (namedTypes.ObjectPattern &&\n            namedTypes.ObjectPattern.check(pattern)) {\n            patternPath.get('properties').each(function (propertyPath) {\n                var property = propertyPath.value;\n                if (namedTypes.Pattern.check(property)) {\n                    addPattern(propertyPath, bindings);\n                }\n                else if (namedTypes.Property.check(property)) {\n                    addPattern(propertyPath.get('value'), bindings);\n                }\n                else if (namedTypes.SpreadProperty &&\n                    namedTypes.SpreadProperty.check(property)) {\n                    addPattern(propertyPath.get('argument'), bindings);\n                }\n            });\n        }\n        else if (namedTypes.ArrayPattern &&\n            namedTypes.ArrayPattern.check(pattern)) {\n            patternPath.get('elements').each(function (elementPath) {\n                var element = elementPath.value;\n                if (namedTypes.Pattern.check(element)) {\n                    addPattern(elementPath, bindings);\n                }\n                else if (namedTypes.SpreadElement &&\n                    namedTypes.SpreadElement.check(element)) {\n                    addPattern(elementPath.get(\"argument\"), bindings);\n                }\n            });\n        }\n        else if (namedTypes.PropertyPattern &&\n            namedTypes.PropertyPattern.check(pattern)) {\n            addPattern(patternPath.get('pattern'), bindings);\n        }\n        else if ((namedTypes.SpreadElementPattern &&\n            namedTypes.SpreadElementPattern.check(pattern)) ||\n            (namedTypes.SpreadPropertyPattern &&\n                namedTypes.SpreadPropertyPattern.check(pattern))) {\n            addPattern(patternPath.get('argument'), bindings);\n        }\n    }\n    function addTypePattern(patternPath, types) {\n        var pattern = patternPath.value;\n        namedTypes.Pattern.assert(pattern);\n        if (namedTypes.Identifier.check(pattern)) {\n            if (hasOwn.call(types, pattern.name)) {\n                types[pattern.name].push(patternPath);\n            }\n            else {\n                types[pattern.name] = [patternPath];\n            }\n        }\n    }\n    Sp.lookup = function (name) {\n        for (var scope = this; scope; scope = scope.parent)\n            if (scope.declares(name))\n                break;\n        return scope;\n    };\n    Sp.lookupType = function (name) {\n        for (var scope = this; scope; scope = scope.parent)\n            if (scope.declaresType(name))\n                break;\n        return scope;\n    };\n    Sp.getGlobalScope = function () {\n        var scope = this;\n        while (!scope.isGlobal)\n            scope = scope.parent;\n        return scope;\n    };\n    return Scope;\n}\nexports.default = scopePlugin;\nmodule.exports = exports[\"default\"];\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}