{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst once_1 = __importDefault(require(\"@tootallnate/once\"));\n\nconst ftp_1 = __importDefault(require(\"ftp\"));\n\nconst path_1 = require(\"path\");\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst notfound_1 = __importDefault(require(\"./notfound\"));\n\nconst notmodified_1 = __importDefault(require(\"./notmodified\"));\n\nconst debug = debug_1.default('get-uri:ftp');\n/**\n * Returns a Readable stream from an \"ftp:\" URI.\n */\n\nfunction get(parsed, opts) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const {\n      cache\n    } = opts;\n    const filepath = parsed.pathname;\n    let lastModified = null;\n\n    if (!filepath) {\n      throw new TypeError('No \"pathname\"!');\n    }\n\n    const client = new ftp_1.default();\n    client.once('greeting', greeting => {\n      debug('FTP greeting: %o', greeting);\n    });\n\n    function onend() {\n      // close the FTP client socket connection\n      client.end();\n    }\n\n    try {\n      opts.host = parsed.hostname || parsed.host || 'localhost';\n      opts.port = parseInt(parsed.port || '0', 10) || 21;\n      opts.debug = debug;\n\n      if (parsed.auth) {\n        const [user, password] = parsed.auth.split(':');\n        opts.user = user;\n        opts.password = password;\n      } // await cb(_ => client.connect(opts, _));\n\n\n      const readyPromise = once_1.default(client, 'ready');\n      client.connect(opts);\n      yield readyPromise; // first we have to figure out the Last Modified date.\n      // try the MDTM command first, which is an optional extension command.\n\n      try {\n        lastModified = yield new Promise((resolve, reject) => {\n          client.lastMod(filepath, (err, res) => {\n            return err ? reject(err) : resolve(res);\n          });\n        });\n      } catch (err) {\n        // handle the \"file not found\" error code\n        if (err.code === 550) {\n          throw new notfound_1.default();\n        }\n      }\n\n      if (!lastModified) {\n        // Try to get the last modified date via the LIST command (uses\n        // more bandwidth, but is more compatible with older FTP servers\n        const list = yield new Promise((resolve, reject) => {\n          client.list(path_1.dirname(filepath), (err, res) => {\n            return err ? reject(err) : resolve(res);\n          });\n        }); // attempt to find the \"entry\" with a matching \"name\"\n\n        const name = path_1.basename(filepath);\n        const entry = list.find(e => e.name === name);\n\n        if (entry) {\n          lastModified = entry.date;\n        }\n      }\n\n      if (lastModified) {\n        if (isNotModified()) {\n          throw new notmodified_1.default();\n        }\n      } else {\n        throw new notfound_1.default();\n      } // XXX: a small timeout seemed necessary otherwise FTP servers\n      // were returning empty sockets for the file occasionally\n      // setTimeout(client.get.bind(client, filepath, onfile), 10);\n\n\n      const rs = yield new Promise((resolve, reject) => {\n        client.get(filepath, (err, res) => {\n          return err ? reject(err) : resolve(res);\n        });\n      });\n      rs.once('end', onend);\n      rs.lastModified = lastModified;\n      return rs;\n    } catch (err) {\n      client.destroy();\n      throw err;\n    } // called when `lastModified` is set, and a \"cache\" stream was provided\n\n\n    function isNotModified() {\n      if (cache && cache.lastModified && lastModified) {\n        return +cache.lastModified === +lastModified;\n      }\n\n      return false;\n    }\n  });\n}\n\nexports.default = get;","map":{"version":3,"mappings":"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","names":["debug","debug_1","get","parsed","opts","cache","filepath","pathname","lastModified","TypeError","client","ftp_1","once","greeting","onend","end","host","hostname","port","parseInt","auth","user","password","split","readyPromise","once_1","connect","Promise","resolve","reject","lastMod","err","res","code","notfound_1","list","path_1","name","entry","find","e","date","isNotModified","notmodified_1","rs","destroy","exports"],"sources":["../src/ftp.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}