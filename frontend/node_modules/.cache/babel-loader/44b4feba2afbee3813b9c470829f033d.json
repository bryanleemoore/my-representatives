{"ast":null,"code":"'use strict'; // The Resolver is currently experimental and might be exposed to users in the future.\n\nconst pa = require('path');\n\nconst fs = require('fs');\n\nconst {\n  VMError\n} = require('./bridge');\n\nconst {\n  VMScript\n} = require('./script'); // This should match. Note that '\\', '%' are invalid characters\n// 1. name/.*\n// 2. @scope/name/.*\n\n\nconst EXPORTS_PATTERN = /^((?:@[^/\\\\%]+\\/)?[^/\\\\%]+)(\\/.*)?$/; // See https://tc39.es/ecma262/#integer-index\n\nfunction isArrayIndex(key) {\n  const keyNum = +key;\n  if (`${keyNum}` !== key) return false;\n  return keyNum >= 0 && keyNum < 0xFFFFFFFF;\n}\n\nclass Resolver {\n  constructor(builtinModules, globalPaths, hostRequire) {\n    this.builtinModules = builtinModules;\n    this.globalPaths = globalPaths;\n    this.hostRequire = hostRequire;\n  }\n\n  init(vm) {}\n\n  pathResolve(path) {\n    return pa.resolve(path);\n  }\n\n  pathIsRelative(path) {\n    if (path === '' || path[0] !== '.') return false;\n    if (path.length === 1) return true;\n    const idx = path[1] === '.' ? 2 : 1;\n    if (path.length <= idx) return false;\n    return path[idx] === '/' || path[idx] === pa.sep;\n  }\n\n  pathIsAbsolute(path) {\n    return pa.isAbsolute(path);\n  }\n\n  pathConcat() {\n    return pa.join(...arguments);\n  }\n\n  pathBasename(path) {\n    return pa.basename(path);\n  }\n\n  pathDirname(path) {\n    return pa.dirname(path);\n  }\n\n  lookupPaths(mod, id) {\n    if (typeof id === 'string') throw new Error('Id is not a string');\n    if (this.pathIsRelative(id)) return [mod.path || '.'];\n    return [...mod.paths, ...this.globalPaths];\n  }\n\n  getBuiltinModulesList() {\n    return Object.getOwnPropertyNames(this.builtinModules);\n  }\n\n  loadBuiltinModule(vm, id) {\n    const handler = this.builtinModules[id];\n    return handler && handler(this, vm, id);\n  }\n\n  loadJS(vm, mod, filename) {\n    throw new VMError(`Access denied to require '${filename}'`, 'EDENIED');\n  }\n\n  loadJSON(vm, mod, filename) {\n    throw new VMError(`Access denied to require '${filename}'`, 'EDENIED');\n  }\n\n  loadNode(vm, mod, filename) {\n    throw new VMError(`Access denied to require '${filename}'`, 'EDENIED');\n  }\n\n  registerModule(mod, filename, path, parent, direct) {}\n\n  resolve(mod, x, options, ext, direct) {\n    if (typeof x !== 'string') throw new Error('Id is not a string');\n\n    if (x.startsWith('node:') || this.builtinModules[x]) {\n      // a. return the core module\n      // b. STOP\n      return x;\n    }\n\n    return this.resolveFull(mod, x, options, ext, direct);\n  }\n\n  resolveFull(mod, x, options, ext, direct) {\n    // 7. THROW \"not found\"\n    throw new VMError(`Cannot find module '${x}'`, 'ENOTFOUND');\n  } // NODE_MODULES_PATHS(START)\n\n\n  genLookupPaths(path) {\n    // 1. let PARTS = path split(START)\n    // 2. let I = count of PARTS - 1\n    // 3. let DIRS = []\n    const dirs = []; // 4. while I >= 0,\n\n    while (true) {\n      const name = this.pathBasename(path); // a. if PARTS[I] = \"node_modules\" CONTINUE\n\n      if (name !== 'node_modules') {\n        // b. DIR = path join(PARTS[0 .. I] + \"node_modules\")\n        // c. DIRS = DIR + DIRS // Note: this seems wrong. Should be DIRS + DIR\n        dirs.push(this.pathConcat(path, 'node_modules'));\n      }\n\n      const dir = this.pathDirname(path);\n      if (dir == path) break; // d. let I = I - 1\n\n      path = dir;\n    }\n\n    return dirs; // This is done later on\n    // 5. return DIRS + GLOBAL_FOLDERS\n  }\n\n}\n\nclass DefaultResolver extends Resolver {\n  constructor(builtinModules, checkPath, globalPaths, pathContext, customResolver, hostRequire, compiler) {\n    super(builtinModules, globalPaths, hostRequire);\n    this.checkPath = checkPath;\n    this.pathContext = pathContext;\n    this.customResolver = customResolver;\n    this.compiler = compiler;\n    this.packageCache = {\n      __proto__: null\n    };\n    this.scriptCache = {\n      __proto__: null\n    };\n  }\n\n  isPathAllowed(path) {\n    return this.checkPath(path);\n  }\n\n  pathTestIsDirectory(path) {\n    try {\n      const stat = fs.statSync(path, {\n        __proto__: null,\n        throwIfNoEntry: false\n      });\n      return stat && stat.isDirectory();\n    } catch (e) {\n      return false;\n    }\n  }\n\n  pathTestIsFile(path) {\n    try {\n      const stat = fs.statSync(path, {\n        __proto__: null,\n        throwIfNoEntry: false\n      });\n      return stat && stat.isFile();\n    } catch (e) {\n      return false;\n    }\n  }\n\n  readFile(path) {\n    return fs.readFileSync(path, {\n      encoding: 'utf8'\n    });\n  }\n\n  readFileWhenExists(path) {\n    return this.pathTestIsFile(path) ? this.readFile(path) : undefined;\n  }\n\n  readScript(filename) {\n    let script = this.scriptCache[filename];\n\n    if (!script) {\n      script = new VMScript(this.readFile(filename), {\n        filename,\n        compiler: this.compiler\n      });\n      this.scriptCache[filename] = script;\n    }\n\n    return script;\n  }\n\n  checkAccess(mod, filename) {\n    if (!this.isPathAllowed(filename)) {\n      throw new VMError(`Module '${filename}' is not allowed to be required. The path is outside the border!`, 'EDENIED');\n    }\n  }\n\n  loadJS(vm, mod, filename) {\n    filename = this.pathResolve(filename);\n    this.checkAccess(mod, filename);\n\n    if (this.pathContext(filename, 'js') === 'sandbox') {\n      const script = this.readScript(filename);\n      vm.run(script, {\n        filename,\n        strict: true,\n        module: mod,\n        wrapper: 'none',\n        dirname: mod.path\n      });\n    } else {\n      const m = this.hostRequire(filename);\n      mod.exports = vm.readonly(m);\n    }\n  }\n\n  loadJSON(vm, mod, filename) {\n    filename = this.pathResolve(filename);\n    this.checkAccess(mod, filename);\n    const json = this.readFile(filename);\n    mod.exports = vm._jsonParse(json);\n  }\n\n  loadNode(vm, mod, filename) {\n    filename = this.pathResolve(filename);\n    this.checkAccess(mod, filename);\n    if (this.pathContext(filename, 'node') === 'sandbox') throw new VMError('Native modules can be required only with context set to \\'host\\'.');\n    const m = this.hostRequire(filename);\n    mod.exports = vm.readonly(m);\n  } // require(X) from module at path Y\n\n\n  resolveFull(mod, x, options, ext, direct) {\n    // Note: core module handled by caller\n    const extList = Object.getOwnPropertyNames(ext);\n    const path = mod.path || '.'; // 5. LOAD_PACKAGE_SELF(X, dirname(Y))\n\n    let f = this.loadPackageSelf(x, path, extList);\n    if (f) return f; // 4. If X begins with '#'\n\n    if (x[0] === '#') {\n      // a. LOAD_PACKAGE_IMPORTS(X, dirname(Y))\n      f = this.loadPackageImports(x, path, extList);\n      if (f) return f;\n    } // 2. If X begins with '/'\n\n\n    if (this.pathIsAbsolute(x)) {\n      // a. set Y to be the filesystem root\n      f = this.loadAsFileOrDirecotry(x, extList);\n      if (f) return f; // c. THROW \"not found\"\n\n      throw new VMError(`Cannot find module '${x}'`, 'ENOTFOUND'); // 3. If X begins with './' or '/' or '../'\n    } else if (this.pathIsRelative(x)) {\n      if (typeof options === 'object' && options !== null) {\n        const paths = options.paths;\n\n        if (Array.isArray(paths)) {\n          for (let i = 0; i < paths.length; i++) {\n            // a. LOAD_AS_FILE(Y + X)\n            // b. LOAD_AS_DIRECTORY(Y + X)\n            f = this.loadAsFileOrDirecotry(this.pathConcat(paths[i], x), extList);\n            if (f) return f;\n          }\n        } else if (paths === undefined) {\n          // a. LOAD_AS_FILE(Y + X)\n          // b. LOAD_AS_DIRECTORY(Y + X)\n          f = this.loadAsFileOrDirecotry(this.pathConcat(path, x), extList);\n          if (f) return f;\n        } else {\n          throw new VMError('Invalid options.paths option.');\n        }\n      } else {\n        // a. LOAD_AS_FILE(Y + X)\n        // b. LOAD_AS_DIRECTORY(Y + X)\n        f = this.loadAsFileOrDirecotry(this.pathConcat(path, x), extList);\n        if (f) return f;\n      } // c. THROW \"not found\"\n\n\n      throw new VMError(`Cannot find module '${x}'`, 'ENOTFOUND');\n    }\n\n    let dirs;\n\n    if (typeof options === 'object' && options !== null) {\n      const paths = options.paths;\n\n      if (Array.isArray(paths)) {\n        dirs = [];\n\n        for (let i = 0; i < paths.length; i++) {\n          const lookups = this.genLookupPaths(paths[i]);\n\n          for (let j = 0; j < lookups.length; j++) {\n            if (!dirs.includes(lookups[j])) dirs.push(lookups[j]);\n          }\n\n          if (i === 0) {\n            const globalPaths = this.globalPaths;\n\n            for (let j = 0; j < globalPaths.length; j++) {\n              if (!dirs.includes(globalPaths[j])) dirs.push(globalPaths[j]);\n            }\n          }\n        }\n      } else if (paths === undefined) {\n        dirs = [...mod.paths, ...this.globalPaths];\n      } else {\n        throw new VMError('Invalid options.paths option.');\n      }\n    } else {\n      dirs = [...mod.paths, ...this.globalPaths];\n    } // 6. LOAD_NODE_MODULES(X, dirname(Y))\n\n\n    f = this.loadNodeModules(x, dirs, extList);\n    if (f) return f;\n    f = this.customResolver(this, x, path, extList);\n    if (f) return f;\n    return super.resolveFull(mod, x, options, ext, direct);\n  }\n\n  loadAsFileOrDirecotry(x, extList) {\n    // a. LOAD_AS_FILE(X)\n    const f = this.loadAsFile(x, extList);\n    if (f) return f; // b. LOAD_AS_DIRECTORY(X)\n\n    return this.loadAsDirectory(x, extList);\n  }\n\n  tryFile(x) {\n    x = this.pathResolve(x);\n    return this.isPathAllowed(x) && this.pathTestIsFile(x) ? x : undefined;\n  }\n\n  tryWithExtension(x, extList) {\n    for (let i = 0; i < extList.length; i++) {\n      const ext = extList[i];\n      if (ext !== this.pathBasename(ext)) continue;\n      const f = this.tryFile(x + ext);\n      if (f) return f;\n    }\n\n    return undefined;\n  }\n\n  readPackage(path) {\n    const packagePath = this.pathResolve(this.pathConcat(path, 'package.json'));\n    const cache = this.packageCache[packagePath];\n    if (cache !== undefined) return cache;\n    if (!this.isPathAllowed(packagePath)) return undefined;\n    const content = this.readFileWhenExists(packagePath);\n\n    if (!content) {\n      this.packageCache[packagePath] = false;\n      return false;\n    }\n\n    let parsed;\n\n    try {\n      parsed = JSON.parse(content);\n    } catch (e) {\n      e.path = packagePath;\n      e.message = 'Error parsing ' + packagePath + ': ' + e.message;\n      throw e;\n    }\n\n    const filtered = {\n      name: parsed.name,\n      main: parsed.main,\n      exports: parsed.exports,\n      imports: parsed.imports,\n      type: parsed.type\n    };\n    this.packageCache[packagePath] = filtered;\n    return filtered;\n  }\n\n  readPackageScope(path) {\n    while (true) {\n      const dir = this.pathDirname(path);\n      if (dir === path) break;\n      const basename = this.pathBasename(dir);\n      if (basename === 'node_modules') break;\n      const pack = this.readPackage(dir);\n      if (pack) return {\n        data: pack,\n        scope: dir\n      };\n      path = dir;\n    }\n\n    return {\n      data: undefined,\n      scope: undefined\n    };\n  } // LOAD_AS_FILE(X)\n\n\n  loadAsFile(x, extList) {\n    // 1. If X is a file, load X as its file extension format. STOP\n    const f = this.tryFile(x);\n    if (f) return f; // 2. If X.js is a file, load X.js as JavaScript text. STOP\n    // 3. If X.json is a file, parse X.json to a JavaScript Object. STOP\n    // 4. If X.node is a file, load X.node as binary addon. STOP\n\n    return this.tryWithExtension(x, extList);\n  } // LOAD_INDEX(X)\n\n\n  loadIndex(x, extList) {\n    // 1. If X/index.js is a file, load X/index.js as JavaScript text. STOP\n    // 2. If X/index.json is a file, parse X/index.json to a JavaScript object. STOP\n    // 3. If X/index.node is a file, load X/index.node as binary addon. STOP\n    return this.tryWithExtension(this.pathConcat(x, 'index'), extList);\n  } // LOAD_AS_DIRECTORY(X)\n\n\n  loadAsPackage(x, pack, extList) {\n    // 1. If X/package.json is a file,\n    // already done.\n    if (pack) {\n      // a. Parse X/package.json, and look for \"main\" field.\n      // b. If \"main\" is a falsy value, GOTO 2.\n      if (typeof pack.main === 'string') {\n        // c. let M = X + (json main field)\n        const m = this.pathConcat(x, pack.main); // d. LOAD_AS_FILE(M)\n\n        let f = this.loadAsFile(m, extList);\n        if (f) return f; // e. LOAD_INDEX(M)\n\n        f = this.loadIndex(m, extList);\n        if (f) return f; // f. LOAD_INDEX(X) DEPRECATED\n\n        f = this.loadIndex(x, extList);\n        if (f) return f; // g. THROW \"not found\"\n\n        throw new VMError(`Cannot find module '${x}'`, 'ENOTFOUND');\n      }\n    } // 2. LOAD_INDEX(X)\n\n\n    return this.loadIndex(x, extList);\n  } // LOAD_AS_DIRECTORY(X)\n\n\n  loadAsDirectory(x, extList) {\n    // 1. If X/package.json is a file,\n    const pack = this.readPackage(x);\n    return this.loadAsPackage(x, pack, extList);\n  } // LOAD_NODE_MODULES(X, START)\n\n\n  loadNodeModules(x, dirs, extList) {\n    // 1. let DIRS = NODE_MODULES_PATHS(START)\n    // This step is already done.\n    // 2. for each DIR in DIRS:\n    for (let i = 0; i < dirs.length; i++) {\n      const dir = dirs[i]; // a. LOAD_PACKAGE_EXPORTS(X, DIR)\n\n      let f = this.loadPackageExports(x, dir, extList);\n      if (f) return f; // b. LOAD_AS_FILE(DIR/X)\n\n      f = this.loadAsFile(dir + '/' + x, extList);\n      if (f) return f; // c. LOAD_AS_DIRECTORY(DIR/X)\n\n      f = this.loadAsDirectory(dir + '/' + x, extList);\n      if (f) return f;\n    }\n\n    return undefined;\n  } // LOAD_PACKAGE_IMPORTS(X, DIR)\n\n\n  loadPackageImports(x, dir, extList) {\n    // 1. Find the closest package scope SCOPE to DIR.\n    const {\n      data,\n      scope\n    } = this.readPackageScope(dir); // 2. If no scope was found, return.\n\n    if (!data) return undefined; // 3. If the SCOPE/package.json \"imports\" is null or undefined, return.\n\n    if (typeof data.imports !== 'object' || data.imports === null || Array.isArray(data.imports)) return undefined; // 4. let MATCH = PACKAGE_IMPORTS_RESOLVE(X, pathToFileURL(SCOPE),\n    //   [\"node\", \"require\"]) defined in the ESM resolver.\n    // PACKAGE_IMPORTS_RESOLVE(specifier, parentURL, conditions)\n    // 1. Assert: specifier begins with \"#\".\n    // 2. If specifier is exactly equal to \"#\" or starts with \"#/\", then\n\n    if (x === '#' || x.startsWith('#/')) {\n      // a. Throw an Invalid Module Specifier error.\n      throw new VMError(`Invalid module specifier '${x}'`, 'ERR_INVALID_MODULE_SPECIFIER');\n    } // 3. Let packageURL be the result of LOOKUP_PACKAGE_SCOPE(parentURL).\n    // Note: packageURL === parentURL === scope\n    // 4. If packageURL is not null, then\n    // Always true\n    // a. Let pjson be the result of READ_PACKAGE_JSON(packageURL).\n    // pjson === data\n    // b. If pjson.imports is a non-null Object, then\n    // Already tested\n    // x. Let resolved be the result of PACKAGE_IMPORTS_EXPORTS_RESOLVE( specifier, pjson.imports, packageURL, true, conditions).\n\n\n    const match = this.packageImportsExportsResolve(x, data.imports, scope, true, ['node', 'require'], extList); // y. If resolved is not null or undefined, return resolved.\n\n    if (!match) {\n      // 5. Throw a Package Import Not Defined error.\n      throw new VMError(`Package import not defined for '${x}'`, 'ERR_PACKAGE_IMPORT_NOT_DEFINED');\n    } // END PACKAGE_IMPORTS_RESOLVE\n    // 5. RESOLVE_ESM_MATCH(MATCH).\n\n\n    return this.resolveEsmMatch(match, x, extList);\n  } // LOAD_PACKAGE_EXPORTS(X, DIR)\n\n\n  loadPackageExports(x, dir, extList) {\n    // 1. Try to interpret X as a combination of NAME and SUBPATH where the name\n    //    may have a @scope/ prefix and the subpath begins with a slash (`/`).\n    const res = x.match(EXPORTS_PATTERN); // 2. If X does not match this pattern or DIR/NAME/package.json is not a file,\n    //    return.\n\n    if (!res) return undefined;\n    const scope = this.pathConcat(dir, res[1]);\n    const pack = this.readPackage(scope);\n    if (!pack) return undefined; // 3. Parse DIR/NAME/package.json, and look for \"exports\" field.\n    // 4. If \"exports\" is null or undefined, return.\n\n    if (!pack.exports) return undefined; // 5. let MATCH = PACKAGE_EXPORTS_RESOLVE(pathToFileURL(DIR/NAME), \".\" + SUBPATH,\n    //    `package.json` \"exports\", [\"node\", \"require\"]) defined in the ESM resolver.\n\n    const match = this.packageExportsResolve(scope, '.' + (res[2] || ''), pack.exports, ['node', 'require'], extList); // 6. RESOLVE_ESM_MATCH(MATCH)\n\n    return this.resolveEsmMatch(match, x, extList);\n  } // LOAD_PACKAGE_SELF(X, DIR)\n\n\n  loadPackageSelf(x, dir, extList) {\n    // 1. Find the closest package scope SCOPE to DIR.\n    const {\n      data,\n      scope\n    } = this.readPackageScope(dir); // 2. If no scope was found, return.\n\n    if (!data) return undefined; // 3. If the SCOPE/package.json \"exports\" is null or undefined, return.\n\n    if (!data.exports) return undefined; // 4. If the SCOPE/package.json \"name\" is not the first segment of X, return.\n\n    if (x !== data.name && !x.startsWith(data.name + '/')) return undefined; // 5. let MATCH = PACKAGE_EXPORTS_RESOLVE(pathToFileURL(SCOPE),\n    //    \".\" + X.slice(\"name\".length), `package.json` \"exports\", [\"node\", \"require\"])\n    //    defined in the ESM resolver.\n\n    const match = this.packageExportsResolve(scope, '.' + x.slice(data.name.length), data.exports, ['node', 'require'], extList); // 6. RESOLVE_ESM_MATCH(MATCH)\n\n    return this.resolveEsmMatch(match, x, extList);\n  } // RESOLVE_ESM_MATCH(MATCH)\n\n\n  resolveEsmMatch(match, x, extList) {\n    // 1. let { RESOLVED, EXACT } = MATCH\n    const resolved = match;\n    const exact = true; // 2. let RESOLVED_PATH = fileURLToPath(RESOLVED)\n\n    const resolvedPath = resolved;\n    let f; // 3. If EXACT is true,\n\n    if (exact) {\n      // a. If the file at RESOLVED_PATH exists, load RESOLVED_PATH as its extension\n      // format. STOP\n      f = this.tryFile(resolvedPath); // 4. Otherwise, if EXACT is false,\n    } else {\n      // a. LOAD_AS_FILE(RESOLVED_PATH)\n      // b. LOAD_AS_DIRECTORY(RESOLVED_PATH)\n      f = this.loadAsFileOrDirecotry(resolvedPath, extList);\n    }\n\n    if (f) return f; // 5. THROW \"not found\"\n\n    throw new VMError(`Cannot find module '${x}'`, 'ENOTFOUND');\n  } // PACKAGE_EXPORTS_RESOLVE(packageURL, subpath, exports, conditions)\n\n\n  packageExportsResolve(packageURL, subpath, rexports, conditions, extList) {\n    // 1. If exports is an Object with both a key starting with \".\" and a key not starting with \".\", throw an Invalid Package Configuration error.\n    let hasDots = false;\n\n    if (typeof rexports === 'object' && !Array.isArray(rexports)) {\n      const keys = Object.getOwnPropertyNames(rexports);\n\n      if (keys.length > 0) {\n        hasDots = keys[0][0] === '.';\n\n        for (let i = 0; i < keys.length; i++) {\n          if (hasDots !== (keys[i][0] === '.')) {\n            throw new VMError('Invalid package configuration', 'ERR_INVALID_PACKAGE_CONFIGURATION');\n          }\n        }\n      }\n    } // 2. If subpath is equal to \".\", then\n\n\n    if (subpath === '.') {\n      // a. Let mainExport be undefined.\n      let mainExport = undefined; // b. If exports is a String or Array, or an Object containing no keys starting with \".\", then\n\n      if (typeof rexports === 'string' || Array.isArray(rexports) || !hasDots) {\n        // x. Set mainExport to exports.\n        mainExport = rexports; // c. Otherwise if exports is an Object containing a \".\" property, then\n      } else if (hasDots) {\n        // x. Set mainExport to exports[\".\"].\n        mainExport = rexports['.'];\n      } // d. If mainExport is not undefined, then\n\n\n      if (mainExport) {\n        // x. Let resolved be the result of PACKAGE_TARGET_RESOLVE( packageURL, mainExport, \"\", false, false, conditions).\n        const resolved = this.packageTargetResolve(packageURL, mainExport, '', false, false, conditions, extList); // y. If resolved is not null or undefined, return resolved.\n\n        if (resolved) return resolved;\n      } // 3. Otherwise, if exports is an Object and all keys of exports start with \".\", then\n\n    } else if (hasDots) {\n      // a. Let matchKey be the string \"./\" concatenated with subpath.\n      // Note: Here subpath starts already with './'\n      // b. Let resolved be the result of PACKAGE_IMPORTS_EXPORTS_RESOLVE( matchKey, exports, packageURL, false, conditions).\n      const resolved = this.packageImportsExportsResolve(subpath, rexports, packageURL, false, conditions, extList); // c. If resolved is not null or undefined, return resolved.\n\n      if (resolved) return resolved;\n    } // 4. Throw a Package Path Not Exported error.\n\n\n    throw new VMError(`Package path '${subpath}' is not exported`, 'ERR_PACKAGE_PATH_NOT_EXPORTED');\n  } // PACKAGE_IMPORTS_EXPORTS_RESOLVE(matchKey, matchObj, packageURL, isImports, conditions)\n\n\n  packageImportsExportsResolve(matchKey, matchObj, packageURL, isImports, conditions, extList) {\n    // 1. If matchKey is a key of matchObj and does not contain \"*\", then\n    let target = matchObj[matchKey];\n\n    if (target && matchKey.indexOf('*') === -1) {\n      // a. Let target be the value of matchObj[matchKey].\n      // b. Return the result of PACKAGE_TARGET_RESOLVE(packageURL, target, \"\", false, isImports, conditions).\n      return this.packageTargetResolve(packageURL, target, '', false, isImports, conditions, extList);\n    } // 2. Let expansionKeys be the list of keys of matchObj containing only a single \"*\",\n    //    sorted by the sorting function PATTERN_KEY_COMPARE which orders in descending order of specificity.\n\n\n    const expansionKeys = Object.getOwnPropertyNames(matchObj);\n    let bestKey = '';\n    let bestSubpath; // 3. For each key expansionKey in expansionKeys, do\n\n    for (let i = 0; i < expansionKeys.length; i++) {\n      const expansionKey = expansionKeys[i];\n      if (matchKey.length < expansionKey.length) continue; // a. Let patternBase be the substring of expansionKey up to but excluding the first \"*\" character.\n\n      const star = expansionKey.indexOf('*');\n      if (star === -1) continue; // Note: expansionKeys was not filtered\n\n      const patternBase = expansionKey.slice(0, star); // b. If matchKey starts with but is not equal to patternBase, then\n\n      if (matchKey.startsWith(patternBase) && expansionKey.indexOf('*', star + 1) === -1) {\n        // Note: expansionKeys was not filtered\n        // 1. Let patternTrailer be the substring of expansionKey from the index after the first \"*\" character.\n        const patternTrailer = expansionKey.slice(star + 1); // 2. If patternTrailer has zero length, or if matchKey ends with patternTrailer and the length of matchKey is greater than or\n        //    equal to the length of expansionKey, then\n\n        if (matchKey.endsWith(patternTrailer) && this.patternKeyCompare(bestKey, expansionKey) === 1) {\n          // Note: expansionKeys was not sorted\n          // a. Let target be the value of matchObj[expansionKey].\n          target = matchObj[expansionKey]; // b. Let subpath be the substring of matchKey starting at the index of the length of patternBase up to the length of\n          //    matchKey minus the length of patternTrailer.\n\n          bestKey = expansionKey;\n          bestSubpath = matchKey.slice(patternBase.length, matchKey.length - patternTrailer.length);\n        }\n      }\n    }\n\n    if (bestSubpath) {\n      // Note: expansionKeys was not sorted\n      // c. Return the result of PACKAGE_TARGET_RESOLVE(packageURL, target, subpath, true, isImports, conditions).\n      return this.packageTargetResolve(packageURL, target, bestSubpath, true, isImports, conditions, extList);\n    } // 4. Return null.\n\n\n    return null;\n  } // PATTERN_KEY_COMPARE(keyA, keyB)\n\n\n  patternKeyCompare(keyA, keyB) {\n    // 1. Assert: keyA ends with \"/\" or contains only a single \"*\".\n    // 2. Assert: keyB ends with \"/\" or contains only a single \"*\".\n    // 3. Let baseLengthA be the index of \"*\" in keyA plus one, if keyA contains \"*\", or the length of keyA otherwise.\n    const baseAStar = keyA.indexOf('*');\n    const baseLengthA = baseAStar === -1 ? keyA.length : baseAStar + 1; // 4. Let baseLengthB be the index of \"*\" in keyB plus one, if keyB contains \"*\", or the length of keyB otherwise.\n\n    const baseBStar = keyB.indexOf('*');\n    const baseLengthB = baseBStar === -1 ? keyB.length : baseBStar + 1; // 5. If baseLengthA is greater than baseLengthB, return -1.\n\n    if (baseLengthA > baseLengthB) return -1; // 6. If baseLengthB is greater than baseLengthA, return 1.\n\n    if (baseLengthB > baseLengthA) return 1; // 7. If keyA does not contain \"*\", return 1.\n\n    if (baseAStar === -1) return 1; // 8. If keyB does not contain \"*\", return -1.\n\n    if (baseBStar === -1) return -1; // 9. If the length of keyA is greater than the length of keyB, return -1.\n\n    if (keyA.length > keyB.length) return -1; // 10. If the length of keyB is greater than the length of keyA, return 1.\n\n    if (keyB.length > keyA.length) return 1; // 11. Return 0.\n\n    return 0;\n  } // PACKAGE_TARGET_RESOLVE(packageURL, target, subpath, pattern, internal, conditions)\n\n\n  packageTargetResolve(packageURL, target, subpath, pattern, internal, conditions, extList) {\n    // 1. If target is a String, then\n    if (typeof target === 'string') {\n      // a. If pattern is false, subpath has non-zero length and target does not end with \"/\", throw an Invalid Module Specifier error.\n      if (!pattern && subpath.length > 0 && !target.endsWith('/')) {\n        throw new VMError(`Invalid package specifier '${subpath}'`, 'ERR_INVALID_MODULE_SPECIFIER');\n      } // b. If target does not start with \"./\", then\n\n\n      if (!target.startsWith('./')) {\n        // 1. If internal is true and target does not start with \"../\" or \"/\" and is not a valid URL, then\n        if (internal && !target.startsWith('../') && !target.startsWith('/')) {\n          let isURL = false;\n\n          try {\n            // eslint-disable-next-line no-new\n            new URL(target);\n            isURL = true;\n          } catch (e) {}\n\n          if (!isURL) {\n            // a. If pattern is true, then\n            if (pattern) {\n              // 1. Return PACKAGE_RESOLVE(target with every instance of \"*\" replaced by subpath, packageURL + \"/\").\n              return this.packageResolve(target.replace(/\\*/g, subpath), packageURL, conditions, extList);\n            } // b. Return PACKAGE_RESOLVE(target + subpath, packageURL + \"/\").\n\n\n            return this.packageResolve(this.pathConcat(target, subpath), packageURL, conditions, extList);\n          }\n        } // Otherwise, throw an Invalid Package Target error.\n\n\n        throw new VMError(`Invalid package target for '${subpath}'`, 'ERR_INVALID_PACKAGE_TARGET');\n      }\n\n      target = decodeURI(target); // c. If target split on \"/\" or \"\\\" contains any \".\", \"..\" or \"node_modules\" segments after the first segment, case insensitive\n      //    and including percent encoded variants, throw an Invalid Package Target error.\n\n      if (target.split(/[/\\\\]/).slice(1).findIndex(x => x === '.' || x === '..' || x.toLowerCase() === 'node_modules') !== -1) {\n        throw new VMError(`Invalid package target for '${subpath}'`, 'ERR_INVALID_PACKAGE_TARGET');\n      } // d. Let resolvedTarget be the URL resolution of the concatenation of packageURL and target.\n\n\n      const resolvedTarget = this.pathConcat(packageURL, target); // e. Assert: resolvedTarget is contained in packageURL.\n\n      subpath = decodeURI(subpath); // f. If subpath split on \"/\" or \"\\\" contains any \".\", \"..\" or \"node_modules\" segments, case insensitive and including percent\n      //    encoded variants, throw an Invalid Module Specifier error.\n\n      if (subpath.split(/[/\\\\]/).findIndex(x => x === '.' || x === '..' || x.toLowerCase() === 'node_modules') !== -1) {\n        throw new VMError(`Invalid package specifier '${subpath}'`, 'ERR_INVALID_MODULE_SPECIFIER');\n      } // g. If pattern is true, then\n\n\n      if (pattern) {\n        // 1. Return the URL resolution of resolvedTarget with every instance of \"*\" replaced with subpath.\n        return resolvedTarget.replace(/\\*/g, subpath);\n      } // h. Otherwise,\n      // 1. Return the URL resolution of the concatenation of subpath and resolvedTarget.\n\n\n      return this.pathConcat(resolvedTarget, subpath); // 3. Otherwise, if target is an Array, then\n    } else if (Array.isArray(target)) {\n      // a. If target.length is zero, return null.\n      if (target.length === 0) return null;\n      let lastException = undefined; // b. For each item targetValue in target, do\n\n      for (let i = 0; i < target.length; i++) {\n        const targetValue = target[i]; // 1. Let resolved be the result of PACKAGE_TARGET_RESOLVE( packageURL, targetValue, subpath, pattern, internal, conditions),\n        //    continuing the loop on any Invalid Package Target error.\n\n        let resolved;\n\n        try {\n          resolved = this.packageTargetResolve(packageURL, targetValue, subpath, pattern, internal, conditions, extList);\n        } catch (e) {\n          if (e.code !== 'ERR_INVALID_PACKAGE_TARGET') throw e;\n          lastException = e;\n          continue;\n        } // 2. If resolved is undefined, continue the loop.\n        // 3. Return resolved.\n\n\n        if (resolved !== undefined) return resolved;\n\n        if (resolved === null) {\n          lastException = null;\n        }\n      } // c. Return or throw the last fallback resolution null return or error.\n\n\n      if (lastException === undefined || lastException === null) return lastException;\n      throw lastException; // 2. Otherwise, if target is a non-null Object, then\n    } else if (typeof target === 'object' && target !== null) {\n      const keys = Object.getOwnPropertyNames(target); // a. If exports contains any index property keys, as defined in ECMA-262 6.1.7 Array Index, throw an Invalid Package Configuration error.\n\n      for (let i = 0; i < keys.length; i++) {\n        const p = keys[i];\n        if (isArrayIndex(p)) throw new VMError(`Invalid package configuration for '${subpath}'`, 'ERR_INVALID_PACKAGE_CONFIGURATION');\n      } // b. For each property p of target, in object insertion order as,\n\n\n      for (let i = 0; i < keys.length; i++) {\n        const p = keys[i]; // 1. If p equals \"default\" or conditions contains an entry for p, then\n\n        if (p === 'default' || conditions.includes(p)) {\n          // a. Let targetValue be the value of the p property in target.\n          const targetValue = target[p]; // b. Let resolved be the result of PACKAGE_TARGET_RESOLVE( packageURL, targetValue, subpath, pattern, internal, conditions).\n\n          const resolved = this.packageTargetResolve(packageURL, targetValue, subpath, pattern, internal, conditions, extList); // c. If resolved is equal to undefined, continue the loop.\n          // d. Return resolved.\n\n          if (resolved !== undefined) return resolved;\n        }\n      } // c. Return undefined.\n\n\n      return undefined; // 4. Otherwise, if target is null, return null.\n    } else if (target == null) {\n      return null;\n    } // Otherwise throw an Invalid Package Target error.\n\n\n    throw new VMError(`Invalid package target for '${subpath}'`, 'ERR_INVALID_PACKAGE_TARGET');\n  } // PACKAGE_RESOLVE(packageSpecifier, parentURL)\n\n\n  packageResolve(packageSpecifier, parentURL, conditions, extList) {\n    // 1. Let packageName be undefined.\n    let packageName = undefined; // 2. If packageSpecifier is an empty string, then\n\n    if (packageSpecifier === '') {\n      // a. Throw an Invalid Module Specifier error.\n      throw new VMError(`Invalid package specifier '${packageSpecifier}'`, 'ERR_INVALID_MODULE_SPECIFIER');\n    } // 3. If packageSpecifier is a Node.js builtin module name, then\n\n\n    if (this.builtinModules[packageSpecifier]) {\n      // a. Return the string \"node:\" concatenated with packageSpecifier.\n      return 'node:' + packageSpecifier;\n    }\n\n    let idx = packageSpecifier.indexOf('/'); // 5. Otherwise,\n\n    if (packageSpecifier[0] === '@') {\n      // a. If packageSpecifier does not contain a \"/\" separator, then\n      if (idx === -1) {\n        // x. Throw an Invalid Module Specifier error.\n        throw new VMError(`Invalid package specifier '${packageSpecifier}'`, 'ERR_INVALID_MODULE_SPECIFIER');\n      } // b. Set packageName to the substring of packageSpecifier until the second \"/\" separator or the end of the string.\n\n\n      idx = packageSpecifier.indexOf('/', idx + 1);\n    } // else\n    // 4. If packageSpecifier does not start with \"@\", then\n    // a. Set packageName to the substring of packageSpecifier until the first \"/\" separator or the end of the string.\n\n\n    packageName = idx === -1 ? packageSpecifier : packageSpecifier.slice(0, idx); // 6. If packageName starts with \".\" or contains \"\\\" or \"%\", then\n\n    if (idx !== 0 && (packageName[0] === '.' || packageName.indexOf('\\\\') >= 0 || packageName.indexOf('%') >= 0)) {\n      // a. Throw an Invalid Module Specifier error.\n      throw new VMError(`Invalid package specifier '${packageSpecifier}'`, 'ERR_INVALID_MODULE_SPECIFIER');\n    } // 7. Let packageSubpath be \".\" concatenated with the substring of packageSpecifier from the position at the length of packageName.\n\n\n    const packageSubpath = '.' + packageSpecifier.slice(packageName.length); // 8. If packageSubpath ends in \"/\", then\n\n    if (packageSubpath[packageSubpath.length - 1] === '/') {\n      // a. Throw an Invalid Module Specifier error.\n      throw new VMError(`Invalid package specifier '${packageSpecifier}'`, 'ERR_INVALID_MODULE_SPECIFIER');\n    } // 9. Let selfUrl be the result of PACKAGE_SELF_RESOLVE(packageName, packageSubpath, parentURL).\n\n\n    const selfUrl = this.packageSelfResolve(packageName, packageSubpath, parentURL); // 10. If selfUrl is not undefined, return selfUrl.\n\n    if (selfUrl) return selfUrl; // 11. While parentURL is not the file system root,\n\n    let packageURL;\n\n    while (true) {\n      // a. Let packageURL be the URL resolution of \"node_modules/\" concatenated with packageSpecifier, relative to parentURL.\n      packageURL = this.pathResolve(this.pathConcat(parentURL, 'node_modules', packageSpecifier)); // b. Set parentURL to the parent folder URL of parentURL.\n\n      const parentParentURL = this.pathDirname(parentURL); // c. If the folder at packageURL does not exist, then\n\n      if (this.isPathAllowed(packageURL) && this.pathTestIsDirectory(packageURL)) break; // 1. Continue the next loop iteration.\n\n      if (parentParentURL === parentURL) {\n        // 12. Throw a Module Not Found error.\n        throw new VMError(`Cannot find module '${packageSpecifier}'`, 'ENOTFOUND');\n      }\n\n      parentURL = parentParentURL;\n    } // d. Let pjson be the result of READ_PACKAGE_JSON(packageURL).\n\n\n    const pack = this.readPackage(packageURL); // e. If pjson is not null and pjson.exports is not null or undefined, then\n\n    if (pack && pack.exports) {\n      // 1. Return the result of PACKAGE_EXPORTS_RESOLVE(packageURL, packageSubpath, pjson.exports, defaultConditions).\n      return this.packageExportsResolve(packageURL, packageSubpath, pack.exports, conditions, extList);\n    } // f. Otherwise, if packageSubpath is equal to \".\", then\n\n\n    if (packageSubpath === '.') {\n      // 1. If pjson.main is a string, then\n      // a. Return the URL resolution of main in packageURL.\n      return this.loadAsPackage(packageSubpath, pack, extList);\n    } // g. Otherwise,\n    // 1. Return the URL resolution of packageSubpath in packageURL.\n\n\n    return this.pathConcat(packageURL, packageSubpath);\n  }\n\n}\n\nexports.Resolver = Resolver;\nexports.DefaultResolver = DefaultResolver;","map":{"version":3,"names":["pa","require","fs","VMError","VMScript","EXPORTS_PATTERN","isArrayIndex","key","keyNum","Resolver","constructor","builtinModules","globalPaths","hostRequire","init","vm","pathResolve","path","resolve","pathIsRelative","length","idx","sep","pathIsAbsolute","isAbsolute","pathConcat","join","pathBasename","basename","pathDirname","dirname","lookupPaths","mod","id","Error","paths","getBuiltinModulesList","Object","getOwnPropertyNames","loadBuiltinModule","handler","loadJS","filename","loadJSON","loadNode","registerModule","parent","direct","x","options","ext","startsWith","resolveFull","genLookupPaths","dirs","name","push","dir","DefaultResolver","checkPath","pathContext","customResolver","compiler","packageCache","__proto__","scriptCache","isPathAllowed","pathTestIsDirectory","stat","statSync","throwIfNoEntry","isDirectory","e","pathTestIsFile","isFile","readFile","readFileSync","encoding","readFileWhenExists","undefined","readScript","script","checkAccess","run","strict","module","wrapper","m","exports","readonly","json","_jsonParse","extList","f","loadPackageSelf","loadPackageImports","loadAsFileOrDirecotry","Array","isArray","i","lookups","j","includes","loadNodeModules","loadAsFile","loadAsDirectory","tryFile","tryWithExtension","readPackage","packagePath","cache","content","parsed","JSON","parse","message","filtered","main","imports","type","readPackageScope","pack","data","scope","loadIndex","loadAsPackage","loadPackageExports","match","packageImportsExportsResolve","resolveEsmMatch","res","packageExportsResolve","slice","resolved","exact","resolvedPath","packageURL","subpath","rexports","conditions","hasDots","keys","mainExport","packageTargetResolve","matchKey","matchObj","isImports","target","indexOf","expansionKeys","bestKey","bestSubpath","expansionKey","star","patternBase","patternTrailer","endsWith","patternKeyCompare","keyA","keyB","baseAStar","baseLengthA","baseBStar","baseLengthB","pattern","internal","isURL","URL","packageResolve","replace","decodeURI","split","findIndex","toLowerCase","resolvedTarget","lastException","targetValue","code","p","packageSpecifier","parentURL","packageName","packageSubpath","selfUrl","packageSelfResolve","parentParentURL"],"sources":["C:/Users/bryan/Desktop/myrepresentatives/frontend/node_modules/vm2/lib/resolver.js"],"sourcesContent":["'use strict';\n\n// The Resolver is currently experimental and might be exposed to users in the future.\n\nconst pa = require('path');\nconst fs = require('fs');\n\nconst {\n\tVMError\n} = require('./bridge');\nconst { VMScript } = require('./script');\n\n// This should match. Note that '\\', '%' are invalid characters\n// 1. name/.*\n// 2. @scope/name/.*\nconst EXPORTS_PATTERN = /^((?:@[^/\\\\%]+\\/)?[^/\\\\%]+)(\\/.*)?$/;\n\n// See https://tc39.es/ecma262/#integer-index\nfunction isArrayIndex(key) {\n\tconst keyNum = +key;\n\tif (`${keyNum}` !== key) return false;\n\treturn keyNum >= 0 && keyNum < 0xFFFFFFFF;\n}\n\nclass Resolver {\n\n\tconstructor(builtinModules, globalPaths, hostRequire) {\n\t\tthis.builtinModules = builtinModules;\n\t\tthis.globalPaths = globalPaths;\n\t\tthis.hostRequire = hostRequire;\n\t}\n\n\tinit(vm) {\n\n\t}\n\n\tpathResolve(path) {\n\t\treturn pa.resolve(path);\n\t}\n\n\tpathIsRelative(path) {\n\t\tif (path === '' || path[0] !== '.') return false;\n\t\tif (path.length === 1) return true;\n\t\tconst idx = path[1] === '.' ? 2 : 1;\n\t\tif (path.length <= idx) return false;\n\t\treturn path[idx] === '/' || path[idx] === pa.sep;\n\t}\n\n\tpathIsAbsolute(path) {\n\t\treturn pa.isAbsolute(path);\n\t}\n\n\tpathConcat(...paths) {\n\t\treturn pa.join(...paths);\n\t}\n\n\tpathBasename(path) {\n\t\treturn pa.basename(path);\n\t}\n\n\tpathDirname(path) {\n\t\treturn pa.dirname(path);\n\t}\n\n\tlookupPaths(mod, id) {\n\t\tif (typeof id === 'string') throw new Error('Id is not a string');\n\t\tif (this.pathIsRelative(id)) return [mod.path || '.'];\n\t\treturn [...mod.paths, ...this.globalPaths];\n\t}\n\n\tgetBuiltinModulesList() {\n\t\treturn Object.getOwnPropertyNames(this.builtinModules);\n\t}\n\n\tloadBuiltinModule(vm, id) {\n\t\tconst handler = this.builtinModules[id];\n\t\treturn handler && handler(this, vm, id);\n\t}\n\n\tloadJS(vm, mod, filename) {\n\t\tthrow new VMError(`Access denied to require '${filename}'`, 'EDENIED');\n\t}\n\n\tloadJSON(vm, mod, filename) {\n\t\tthrow new VMError(`Access denied to require '${filename}'`, 'EDENIED');\n\t}\n\n\tloadNode(vm, mod, filename) {\n\t\tthrow new VMError(`Access denied to require '${filename}'`, 'EDENIED');\n\t}\n\n\tregisterModule(mod, filename, path, parent, direct) {\n\n\t}\n\n\tresolve(mod, x, options, ext, direct) {\n\t\tif (typeof x !== 'string') throw new Error('Id is not a string');\n\n\t\tif (x.startsWith('node:') || this.builtinModules[x]) {\n\t\t\t// a. return the core module\n\t\t\t// b. STOP\n\t\t\treturn x;\n\t\t}\n\n\t\treturn this.resolveFull(mod, x, options, ext, direct);\n\t}\n\n\tresolveFull(mod, x, options, ext, direct) {\n\t\t// 7. THROW \"not found\"\n\t\tthrow new VMError(`Cannot find module '${x}'`, 'ENOTFOUND');\n\t}\n\n\t// NODE_MODULES_PATHS(START)\n\tgenLookupPaths(path) {\n\t\t// 1. let PARTS = path split(START)\n\t\t// 2. let I = count of PARTS - 1\n\t\t// 3. let DIRS = []\n\t\tconst dirs = [];\n\t\t// 4. while I >= 0,\n\t\twhile (true) {\n\t\t\tconst name = this.pathBasename(path);\n\t\t\t// a. if PARTS[I] = \"node_modules\" CONTINUE\n\t\t\tif (name !== 'node_modules') {\n\t\t\t\t// b. DIR = path join(PARTS[0 .. I] + \"node_modules\")\n\t\t\t\t// c. DIRS = DIR + DIRS // Note: this seems wrong. Should be DIRS + DIR\n\t\t\t\tdirs.push(this.pathConcat(path, 'node_modules'));\n\t\t\t}\n\t\t\tconst dir = this.pathDirname(path);\n\t\t\tif (dir == path) break;\n\t\t\t// d. let I = I - 1\n\t\t\tpath = dir;\n\t\t}\n\n\t\treturn dirs;\n\t\t// This is done later on\n\t\t// 5. return DIRS + GLOBAL_FOLDERS\n\t}\n\n}\n\nclass DefaultResolver extends Resolver {\n\n\tconstructor(builtinModules, checkPath, globalPaths, pathContext, customResolver, hostRequire, compiler) {\n\t\tsuper(builtinModules, globalPaths, hostRequire);\n\t\tthis.checkPath = checkPath;\n\t\tthis.pathContext = pathContext;\n\t\tthis.customResolver = customResolver;\n\t\tthis.compiler = compiler;\n\t\tthis.packageCache = {__proto__: null};\n\t\tthis.scriptCache = {__proto__: null};\n\t}\n\n\tisPathAllowed(path) {\n\t\treturn this.checkPath(path);\n\t}\n\n\tpathTestIsDirectory(path) {\n\t\ttry {\n\t\t\tconst stat = fs.statSync(path, {__proto__: null, throwIfNoEntry: false});\n\t\t\treturn stat && stat.isDirectory();\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tpathTestIsFile(path) {\n\t\ttry {\n\t\t\tconst stat = fs.statSync(path, {__proto__: null, throwIfNoEntry: false});\n\t\t\treturn stat && stat.isFile();\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treadFile(path) {\n\t\treturn fs.readFileSync(path, {encoding: 'utf8'});\n\t}\n\n\treadFileWhenExists(path) {\n\t\treturn this.pathTestIsFile(path) ? this.readFile(path) : undefined;\n\t}\n\n\treadScript(filename) {\n\t\tlet script = this.scriptCache[filename];\n\t\tif (!script) {\n\t\t\tscript = new VMScript(this.readFile(filename), {filename, compiler: this.compiler});\n\t\t\tthis.scriptCache[filename] = script;\n\t\t}\n\t\treturn script;\n\t}\n\n\tcheckAccess(mod, filename) {\n\t\tif (!this.isPathAllowed(filename)) {\n\t\t\tthrow new VMError(`Module '${filename}' is not allowed to be required. The path is outside the border!`, 'EDENIED');\n\t\t}\n\t}\n\n\tloadJS(vm, mod, filename) {\n\t\tfilename = this.pathResolve(filename);\n\t\tthis.checkAccess(mod, filename);\n\t\tif (this.pathContext(filename, 'js') === 'sandbox') {\n\t\t\tconst script = this.readScript(filename);\n\t\t\tvm.run(script, {filename, strict: true, module: mod, wrapper: 'none', dirname: mod.path});\n\t\t} else {\n\t\t\tconst m = this.hostRequire(filename);\n\t\t\tmod.exports = vm.readonly(m);\n\t\t}\n\t}\n\n\tloadJSON(vm, mod, filename) {\n\t\tfilename = this.pathResolve(filename);\n\t\tthis.checkAccess(mod, filename);\n\t\tconst json = this.readFile(filename);\n\t\tmod.exports = vm._jsonParse(json);\n\t}\n\n\tloadNode(vm, mod, filename) {\n\t\tfilename = this.pathResolve(filename);\n\t\tthis.checkAccess(mod, filename);\n\t\tif (this.pathContext(filename, 'node') === 'sandbox') throw new VMError('Native modules can be required only with context set to \\'host\\'.');\n\t\tconst m = this.hostRequire(filename);\n\t\tmod.exports = vm.readonly(m);\n\t}\n\n\t// require(X) from module at path Y\n\tresolveFull(mod, x, options, ext, direct) {\n\t\t// Note: core module handled by caller\n\n\t\tconst extList = Object.getOwnPropertyNames(ext);\n\t\tconst path = mod.path || '.';\n\n\t\t// 5. LOAD_PACKAGE_SELF(X, dirname(Y))\n\t\tlet f = this.loadPackageSelf(x, path, extList);\n\t\tif (f) return f;\n\n\t\t// 4. If X begins with '#'\n\t\tif (x[0] === '#') {\n\t\t\t// a. LOAD_PACKAGE_IMPORTS(X, dirname(Y))\n\t\t\tf = this.loadPackageImports(x, path, extList);\n\t\t\tif (f) return f;\n\t\t}\n\n\t\t// 2. If X begins with '/'\n\t\tif (this.pathIsAbsolute(x)) {\n\t\t\t// a. set Y to be the filesystem root\n\t\t\tf = this.loadAsFileOrDirecotry(x, extList);\n\t\t\tif (f) return f;\n\n\t\t\t// c. THROW \"not found\"\n\t\t\tthrow new VMError(`Cannot find module '${x}'`, 'ENOTFOUND');\n\n\t\t// 3. If X begins with './' or '/' or '../'\n\t\t} else if (this.pathIsRelative(x)) {\n\t\t\tif (typeof options === 'object' && options !== null) {\n\t\t\t\tconst paths = options.paths;\n\t\t\t\tif (Array.isArray(paths)) {\n\t\t\t\t\tfor (let i = 0; i < paths.length; i++) {\n\t\t\t\t\t\t// a. LOAD_AS_FILE(Y + X)\n\t\t\t\t\t\t// b. LOAD_AS_DIRECTORY(Y + X)\n\t\t\t\t\t\tf = this.loadAsFileOrDirecotry(this.pathConcat(paths[i], x), extList);\n\t\t\t\t\t\tif (f) return f;\n\t\t\t\t\t}\n\t\t\t\t} else if (paths === undefined) {\n\t\t\t\t\t// a. LOAD_AS_FILE(Y + X)\n\t\t\t\t\t// b. LOAD_AS_DIRECTORY(Y + X)\n\t\t\t\t\tf = this.loadAsFileOrDirecotry(this.pathConcat(path, x), extList);\n\t\t\t\t\tif (f) return f;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new VMError('Invalid options.paths option.');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// a. LOAD_AS_FILE(Y + X)\n\t\t\t\t// b. LOAD_AS_DIRECTORY(Y + X)\n\t\t\t\tf = this.loadAsFileOrDirecotry(this.pathConcat(path, x), extList);\n\t\t\t\tif (f) return f;\n\t\t\t}\n\n\t\t\t// c. THROW \"not found\"\n\t\t\tthrow new VMError(`Cannot find module '${x}'`, 'ENOTFOUND');\n\t\t}\n\n\t\tlet dirs;\n\t\tif (typeof options === 'object' && options !== null) {\n\t\t\tconst paths = options.paths;\n\t\t\tif (Array.isArray(paths)) {\n\t\t\t\tdirs = [];\n\n\t\t\t\tfor (let i = 0; i < paths.length; i++) {\n\t\t\t\t\tconst lookups = this.genLookupPaths(paths[i]);\n\t\t\t\t\tfor (let j = 0; j < lookups.length; j++) {\n\t\t\t\t\t\tif (!dirs.includes(lookups[j])) dirs.push(lookups[j]);\n\t\t\t\t\t}\n\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\tconst globalPaths = this.globalPaths;\n\t\t\t\t\t\tfor (let j = 0; j < globalPaths.length; j++) {\n\t\t\t\t\t\t\tif (!dirs.includes(globalPaths[j])) dirs.push(globalPaths[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (paths === undefined) {\n\t\t\t\tdirs = [...mod.paths, ...this.globalPaths];\n\t\t\t} else {\n\t\t\t\tthrow new VMError('Invalid options.paths option.');\n\t\t\t}\n\t\t} else {\n\t\t\tdirs = [...mod.paths, ...this.globalPaths];\n\t\t}\n\n\t\t// 6. LOAD_NODE_MODULES(X, dirname(Y))\n\t\tf = this.loadNodeModules(x, dirs, extList);\n\t\tif (f) return f;\n\n\t\tf = this.customResolver(this, x, path, extList);\n\t\tif (f) return f;\n\n\t\treturn super.resolveFull(mod, x, options, ext, direct);\n\t}\n\n\tloadAsFileOrDirecotry(x, extList) {\n\t\t// a. LOAD_AS_FILE(X)\n\t\tconst f = this.loadAsFile(x, extList);\n\t\tif (f) return f;\n\t\t// b. LOAD_AS_DIRECTORY(X)\n\t\treturn this.loadAsDirectory(x, extList);\n\t}\n\n\ttryFile(x) {\n\t\tx = this.pathResolve(x);\n\t\treturn this.isPathAllowed(x) && this.pathTestIsFile(x) ? x : undefined;\n\t}\n\n\ttryWithExtension(x, extList) {\n\t\tfor (let i = 0; i < extList.length; i++) {\n\t\t\tconst ext = extList[i];\n\t\t\tif (ext !== this.pathBasename(ext)) continue;\n\t\t\tconst f = this.tryFile(x + ext);\n\t\t\tif (f) return f;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\treadPackage(path) {\n\t\tconst packagePath = this.pathResolve(this.pathConcat(path, 'package.json'));\n\n\t\tconst cache = this.packageCache[packagePath];\n\t\tif (cache !== undefined) return cache;\n\n\t\tif (!this.isPathAllowed(packagePath)) return undefined;\n\t\tconst content = this.readFileWhenExists(packagePath);\n\t\tif (!content) {\n\t\t\tthis.packageCache[packagePath] = false;\n\t\t\treturn false;\n\t\t}\n\n\t\tlet parsed;\n\t\ttry {\n\t\t\tparsed = JSON.parse(content);\n\t\t} catch (e) {\n\t\t\te.path = packagePath;\n\t\t\te.message = 'Error parsing ' + packagePath + ': ' + e.message;\n\t\t\tthrow e;\n\t\t}\n\n\t\tconst filtered = {\n\t\t\tname: parsed.name,\n\t\t\tmain: parsed.main,\n\t\t\texports: parsed.exports,\n\t\t\timports: parsed.imports,\n\t\t\ttype: parsed.type\n\t\t};\n\t\tthis.packageCache[packagePath] = filtered;\n\t\treturn filtered;\n\t}\n\n\treadPackageScope(path) {\n\t\twhile (true) {\n\t\t\tconst dir = this.pathDirname(path);\n\t\t\tif (dir === path) break;\n\t\t\tconst basename = this.pathBasename(dir);\n\t\t\tif (basename === 'node_modules') break;\n\t\t\tconst pack = this.readPackage(dir);\n\t\t\tif (pack) return {data: pack, scope: dir};\n\t\t\tpath = dir;\n\t\t}\n\t\treturn {data: undefined, scope: undefined};\n\t}\n\n\t// LOAD_AS_FILE(X)\n\tloadAsFile(x, extList) {\n\t\t// 1. If X is a file, load X as its file extension format. STOP\n\t\tconst f = this.tryFile(x);\n\t\tif (f) return f;\n\t\t// 2. If X.js is a file, load X.js as JavaScript text. STOP\n\t\t// 3. If X.json is a file, parse X.json to a JavaScript Object. STOP\n\t\t// 4. If X.node is a file, load X.node as binary addon. STOP\n\t\treturn this.tryWithExtension(x, extList);\n\t}\n\n\t// LOAD_INDEX(X)\n\tloadIndex(x, extList) {\n\t\t// 1. If X/index.js is a file, load X/index.js as JavaScript text. STOP\n\t\t// 2. If X/index.json is a file, parse X/index.json to a JavaScript object. STOP\n\t\t// 3. If X/index.node is a file, load X/index.node as binary addon. STOP\n\t\treturn this.tryWithExtension(this.pathConcat(x, 'index'), extList);\n\t}\n\n\t// LOAD_AS_DIRECTORY(X)\n\tloadAsPackage(x, pack, extList) {\n\t\t// 1. If X/package.json is a file,\n\t\t// already done.\n\t\tif (pack) {\n\t\t\t// a. Parse X/package.json, and look for \"main\" field.\n\t\t\t// b. If \"main\" is a falsy value, GOTO 2.\n\t\t\tif (typeof pack.main === 'string') {\n\t\t\t\t// c. let M = X + (json main field)\n\t\t\t\tconst m = this.pathConcat(x, pack.main);\n\t\t\t\t// d. LOAD_AS_FILE(M)\n\t\t\t\tlet f = this.loadAsFile(m, extList);\n\t\t\t\tif (f) return f;\n\t\t\t\t// e. LOAD_INDEX(M)\n\t\t\t\tf = this.loadIndex(m, extList);\n\t\t\t\tif (f) return f;\n\t\t\t\t// f. LOAD_INDEX(X) DEPRECATED\n\t\t\t\tf = this.loadIndex(x, extList);\n\t\t\t\tif (f) return f;\n\t\t\t\t// g. THROW \"not found\"\n\t\t\t\tthrow new VMError(`Cannot find module '${x}'`, 'ENOTFOUND');\n\t\t\t}\n\t\t}\n\n\t\t// 2. LOAD_INDEX(X)\n\t\treturn this.loadIndex(x, extList);\n\t}\n\n\t// LOAD_AS_DIRECTORY(X)\n\tloadAsDirectory(x, extList) {\n\t\t// 1. If X/package.json is a file,\n\t\tconst pack = this.readPackage(x);\n\t\treturn this.loadAsPackage(x, pack, extList);\n\t}\n\n\t// LOAD_NODE_MODULES(X, START)\n\tloadNodeModules(x, dirs, extList) {\n\t\t// 1. let DIRS = NODE_MODULES_PATHS(START)\n\t\t// This step is already done.\n\n\t\t// 2. for each DIR in DIRS:\n\t\tfor (let i = 0; i < dirs.length; i++) {\n\t\t\tconst dir = dirs[i];\n\t\t\t// a. LOAD_PACKAGE_EXPORTS(X, DIR)\n\t\t\tlet f = this.loadPackageExports(x, dir, extList);\n\t\t\tif (f) return f;\n\t\t\t// b. LOAD_AS_FILE(DIR/X)\n\t\t\tf = this.loadAsFile(dir + '/' + x, extList);\n\t\t\tif (f) return f;\n\t\t\t// c. LOAD_AS_DIRECTORY(DIR/X)\n\t\t\tf = this.loadAsDirectory(dir + '/' + x, extList);\n\t\t\tif (f) return f;\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t// LOAD_PACKAGE_IMPORTS(X, DIR)\n\tloadPackageImports(x, dir, extList) {\n\t\t// 1. Find the closest package scope SCOPE to DIR.\n\t\tconst {data, scope} = this.readPackageScope(dir);\n\t\t// 2. If no scope was found, return.\n\t\tif (!data) return undefined;\n\t\t// 3. If the SCOPE/package.json \"imports\" is null or undefined, return.\n\t\tif (typeof data.imports !== 'object' || data.imports === null || Array.isArray(data.imports)) return undefined;\n\t\t// 4. let MATCH = PACKAGE_IMPORTS_RESOLVE(X, pathToFileURL(SCOPE),\n\t\t//   [\"node\", \"require\"]) defined in the ESM resolver.\n\n\t\t// PACKAGE_IMPORTS_RESOLVE(specifier, parentURL, conditions)\n\t\t// 1. Assert: specifier begins with \"#\".\n\t\t// 2. If specifier is exactly equal to \"#\" or starts with \"#/\", then\n\t\tif (x === '#' || x.startsWith('#/')) {\n\t\t\t// a. Throw an Invalid Module Specifier error.\n\t\t\tthrow new VMError(`Invalid module specifier '${x}'`, 'ERR_INVALID_MODULE_SPECIFIER');\n\t\t}\n\t\t// 3. Let packageURL be the result of LOOKUP_PACKAGE_SCOPE(parentURL).\n\t\t// Note: packageURL === parentURL === scope\n\t\t// 4. If packageURL is not null, then\n\t\t// Always true\n\t\t// a. Let pjson be the result of READ_PACKAGE_JSON(packageURL).\n\t\t// pjson === data\n\t\t// b. If pjson.imports is a non-null Object, then\n\t\t// Already tested\n\t\t// x. Let resolved be the result of PACKAGE_IMPORTS_EXPORTS_RESOLVE( specifier, pjson.imports, packageURL, true, conditions).\n\t\tconst match = this.packageImportsExportsResolve(x, data.imports, scope, true, ['node', 'require'], extList);\n\t\t// y. If resolved is not null or undefined, return resolved.\n\t\tif (!match) {\n\t\t\t// 5. Throw a Package Import Not Defined error.\n\t\t\tthrow new VMError(`Package import not defined for '${x}'`, 'ERR_PACKAGE_IMPORT_NOT_DEFINED');\n\t\t}\n\t\t// END PACKAGE_IMPORTS_RESOLVE\n\n\t\t// 5. RESOLVE_ESM_MATCH(MATCH).\n\t\treturn this.resolveEsmMatch(match, x, extList);\n\t}\n\n\t// LOAD_PACKAGE_EXPORTS(X, DIR)\n\tloadPackageExports(x, dir, extList) {\n\t\t// 1. Try to interpret X as a combination of NAME and SUBPATH where the name\n\t\t//    may have a @scope/ prefix and the subpath begins with a slash (`/`).\n\t\tconst res = x.match(EXPORTS_PATTERN);\n\t\t// 2. If X does not match this pattern or DIR/NAME/package.json is not a file,\n\t\t//    return.\n\t\tif (!res) return undefined;\n\t\tconst scope = this.pathConcat(dir, res[1]);\n\t\tconst pack = this.readPackage(scope);\n\t\tif (!pack) return undefined;\n\t\t// 3. Parse DIR/NAME/package.json, and look for \"exports\" field.\n\t\t// 4. If \"exports\" is null or undefined, return.\n\t\tif (!pack.exports) return undefined;\n\t\t// 5. let MATCH = PACKAGE_EXPORTS_RESOLVE(pathToFileURL(DIR/NAME), \".\" + SUBPATH,\n\t\t//    `package.json` \"exports\", [\"node\", \"require\"]) defined in the ESM resolver.\n\t\tconst match = this.packageExportsResolve(scope, '.' + (res[2] || ''), pack.exports, ['node', 'require'], extList);\n\t\t// 6. RESOLVE_ESM_MATCH(MATCH)\n\t\treturn this.resolveEsmMatch(match, x, extList);\n\t}\n\n\t// LOAD_PACKAGE_SELF(X, DIR)\n\tloadPackageSelf(x, dir, extList) {\n\t\t// 1. Find the closest package scope SCOPE to DIR.\n\t\tconst {data, scope} = this.readPackageScope(dir);\n\t\t// 2. If no scope was found, return.\n\t\tif (!data) return undefined;\n\t\t// 3. If the SCOPE/package.json \"exports\" is null or undefined, return.\n\t\tif (!data.exports) return undefined;\n\t\t// 4. If the SCOPE/package.json \"name\" is not the first segment of X, return.\n\t\tif (x !== data.name && !x.startsWith(data.name + '/')) return undefined;\n\t\t// 5. let MATCH = PACKAGE_EXPORTS_RESOLVE(pathToFileURL(SCOPE),\n\t\t//    \".\" + X.slice(\"name\".length), `package.json` \"exports\", [\"node\", \"require\"])\n\t\t//    defined in the ESM resolver.\n\t\tconst match = this.packageExportsResolve(scope, '.' + x.slice(data.name.length), data.exports, ['node', 'require'], extList);\n\t\t// 6. RESOLVE_ESM_MATCH(MATCH)\n\t\treturn this.resolveEsmMatch(match, x, extList);\n\t}\n\n\t// RESOLVE_ESM_MATCH(MATCH)\n\tresolveEsmMatch(match, x, extList) {\n\t\t// 1. let { RESOLVED, EXACT } = MATCH\n\t\tconst resolved = match;\n\t\tconst exact = true;\n\t\t// 2. let RESOLVED_PATH = fileURLToPath(RESOLVED)\n\t\tconst resolvedPath = resolved;\n\t\tlet f;\n\t\t// 3. If EXACT is true,\n\t\tif (exact) {\n\t\t\t// a. If the file at RESOLVED_PATH exists, load RESOLVED_PATH as its extension\n\t\t\t// format. STOP\n\t\t\tf = this.tryFile(resolvedPath);\n\t\t// 4. Otherwise, if EXACT is false,\n\t\t} else {\n\t\t\t// a. LOAD_AS_FILE(RESOLVED_PATH)\n\t\t\t// b. LOAD_AS_DIRECTORY(RESOLVED_PATH)\n\t\t\tf = this.loadAsFileOrDirecotry(resolvedPath, extList);\n\t\t}\n\t\tif (f) return f;\n\t\t// 5. THROW \"not found\"\n\t\tthrow new VMError(`Cannot find module '${x}'`, 'ENOTFOUND');\n\t}\n\n\t// PACKAGE_EXPORTS_RESOLVE(packageURL, subpath, exports, conditions)\n\tpackageExportsResolve(packageURL, subpath, rexports, conditions, extList) {\n\t\t// 1. If exports is an Object with both a key starting with \".\" and a key not starting with \".\", throw an Invalid Package Configuration error.\n\t\tlet hasDots = false;\n\t\tif (typeof rexports === 'object' && !Array.isArray(rexports)) {\n\t\t\tconst keys = Object.getOwnPropertyNames(rexports);\n\t\t\tif (keys.length > 0) {\n\t\t\t\thasDots = keys[0][0] === '.';\n\t\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\t\tif (hasDots !== (keys[i][0] === '.')) {\n\t\t\t\t\t\tthrow new VMError('Invalid package configuration', 'ERR_INVALID_PACKAGE_CONFIGURATION');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// 2. If subpath is equal to \".\", then\n\t\tif (subpath === '.') {\n\t\t\t// a. Let mainExport be undefined.\n\t\t\tlet mainExport = undefined;\n\t\t\t// b. If exports is a String or Array, or an Object containing no keys starting with \".\", then\n\t\t\tif (typeof rexports === 'string' || Array.isArray(rexports) || !hasDots) {\n\t\t\t\t// x. Set mainExport to exports.\n\t\t\t\tmainExport = rexports;\n\t\t\t// c. Otherwise if exports is an Object containing a \".\" property, then\n\t\t\t} else if (hasDots) {\n\t\t\t\t// x. Set mainExport to exports[\".\"].\n\t\t\t\tmainExport = rexports['.'];\n\t\t\t}\n\t\t\t// d. If mainExport is not undefined, then\n\t\t\tif (mainExport) {\n\t\t\t\t// x. Let resolved be the result of PACKAGE_TARGET_RESOLVE( packageURL, mainExport, \"\", false, false, conditions).\n\t\t\t\tconst resolved = this.packageTargetResolve(packageURL, mainExport, '', false, false, conditions, extList);\n\t\t\t\t// y. If resolved is not null or undefined, return resolved.\n\t\t\t\tif (resolved) return resolved;\n\t\t\t}\n\t\t// 3. Otherwise, if exports is an Object and all keys of exports start with \".\", then\n\t\t} else if (hasDots) {\n\t\t\t// a. Let matchKey be the string \"./\" concatenated with subpath.\n\t\t\t// Note: Here subpath starts already with './'\n\t\t\t// b. Let resolved be the result of PACKAGE_IMPORTS_EXPORTS_RESOLVE( matchKey, exports, packageURL, false, conditions).\n\t\t\tconst resolved = this.packageImportsExportsResolve(subpath, rexports, packageURL, false, conditions, extList);\n\t\t\t// c. If resolved is not null or undefined, return resolved.\n\t\t\tif (resolved) return resolved;\n\t\t}\n\t\t// 4. Throw a Package Path Not Exported error.\n\t\tthrow new VMError(`Package path '${subpath}' is not exported`, 'ERR_PACKAGE_PATH_NOT_EXPORTED');\n\t}\n\n\t// PACKAGE_IMPORTS_EXPORTS_RESOLVE(matchKey, matchObj, packageURL, isImports, conditions)\n\tpackageImportsExportsResolve(matchKey, matchObj, packageURL, isImports, conditions, extList) {\n\t\t// 1. If matchKey is a key of matchObj and does not contain \"*\", then\n\t\tlet target = matchObj[matchKey];\n\t\tif (target && matchKey.indexOf('*') === -1) {\n\t\t\t// a. Let target be the value of matchObj[matchKey].\n\t\t\t// b. Return the result of PACKAGE_TARGET_RESOLVE(packageURL, target, \"\", false, isImports, conditions).\n\t\t\treturn this.packageTargetResolve(packageURL, target, '', false, isImports, conditions, extList);\n\t\t}\n\t\t// 2. Let expansionKeys be the list of keys of matchObj containing only a single \"*\",\n\t\t//    sorted by the sorting function PATTERN_KEY_COMPARE which orders in descending order of specificity.\n\t\tconst expansionKeys = Object.getOwnPropertyNames(matchObj);\n\t\tlet bestKey = '';\n\t\tlet bestSubpath;\n\t\t// 3. For each key expansionKey in expansionKeys, do\n\t\tfor (let i = 0; i < expansionKeys.length; i++) {\n\t\t\tconst expansionKey = expansionKeys[i];\n\t\t\tif (matchKey.length < expansionKey.length) continue;\n\t\t\t// a. Let patternBase be the substring of expansionKey up to but excluding the first \"*\" character.\n\t\t\tconst star = expansionKey.indexOf('*');\n\t\t\tif (star === -1) continue; // Note: expansionKeys was not filtered\n\t\t\tconst patternBase = expansionKey.slice(0, star);\n\t\t\t// b. If matchKey starts with but is not equal to patternBase, then\n\t\t\tif (matchKey.startsWith(patternBase) && expansionKey.indexOf('*', star + 1) === -1) { // Note: expansionKeys was not filtered\n\t\t\t\t// 1. Let patternTrailer be the substring of expansionKey from the index after the first \"*\" character.\n\t\t\t\tconst patternTrailer = expansionKey.slice(star + 1);\n\t\t\t\t// 2. If patternTrailer has zero length, or if matchKey ends with patternTrailer and the length of matchKey is greater than or\n\t\t\t\t//    equal to the length of expansionKey, then\n\t\t\t\tif (matchKey.endsWith(patternTrailer) && this.patternKeyCompare(bestKey, expansionKey) === 1) { // Note: expansionKeys was not sorted\n\t\t\t\t\t// a. Let target be the value of matchObj[expansionKey].\n\t\t\t\t\ttarget = matchObj[expansionKey];\n\t\t\t\t\t// b. Let subpath be the substring of matchKey starting at the index of the length of patternBase up to the length of\n\t\t\t\t\t//    matchKey minus the length of patternTrailer.\n\t\t\t\t\tbestKey = expansionKey;\n\t\t\t\t\tbestSubpath = matchKey.slice(patternBase.length, matchKey.length - patternTrailer.length);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (bestSubpath) { // Note: expansionKeys was not sorted\n\t\t\t// c. Return the result of PACKAGE_TARGET_RESOLVE(packageURL, target, subpath, true, isImports, conditions).\n\t\t\treturn this.packageTargetResolve(packageURL, target, bestSubpath, true, isImports, conditions, extList);\n\t\t}\n\t\t// 4. Return null.\n\t\treturn null;\n\t}\n\n\t// PATTERN_KEY_COMPARE(keyA, keyB)\n\tpatternKeyCompare(keyA, keyB) {\n\t\t// 1. Assert: keyA ends with \"/\" or contains only a single \"*\".\n\t\t// 2. Assert: keyB ends with \"/\" or contains only a single \"*\".\n\t\t// 3. Let baseLengthA be the index of \"*\" in keyA plus one, if keyA contains \"*\", or the length of keyA otherwise.\n\t\tconst baseAStar = keyA.indexOf('*');\n\t\tconst baseLengthA = baseAStar === -1 ? keyA.length : baseAStar + 1;\n\t\t// 4. Let baseLengthB be the index of \"*\" in keyB plus one, if keyB contains \"*\", or the length of keyB otherwise.\n\t\tconst baseBStar = keyB.indexOf('*');\n\t\tconst baseLengthB = baseBStar === -1 ? keyB.length : baseBStar + 1;\n\t\t// 5. If baseLengthA is greater than baseLengthB, return -1.\n\t\tif (baseLengthA > baseLengthB) return -1;\n\t\t// 6. If baseLengthB is greater than baseLengthA, return 1.\n\t\tif (baseLengthB > baseLengthA) return 1;\n\t\t// 7. If keyA does not contain \"*\", return 1.\n\t\tif (baseAStar === -1) return 1;\n\t\t// 8. If keyB does not contain \"*\", return -1.\n\t\tif (baseBStar === -1) return -1;\n\t\t// 9. If the length of keyA is greater than the length of keyB, return -1.\n\t\tif (keyA.length > keyB.length) return -1;\n\t\t// 10. If the length of keyB is greater than the length of keyA, return 1.\n\t\tif (keyB.length > keyA.length) return 1;\n\t\t// 11. Return 0.\n\t\treturn 0;\n\t}\n\n\t// PACKAGE_TARGET_RESOLVE(packageURL, target, subpath, pattern, internal, conditions)\n\tpackageTargetResolve(packageURL, target, subpath, pattern, internal, conditions, extList) {\n\t\t// 1. If target is a String, then\n\t\tif (typeof target === 'string') {\n\t\t\t// a. If pattern is false, subpath has non-zero length and target does not end with \"/\", throw an Invalid Module Specifier error.\n\t\t\tif (!pattern && subpath.length > 0 && !target.endsWith('/')) {\n\t\t\t\tthrow new VMError(`Invalid package specifier '${subpath}'`, 'ERR_INVALID_MODULE_SPECIFIER');\n\t\t\t}\n\t\t\t// b. If target does not start with \"./\", then\n\t\t\tif (!target.startsWith('./')) {\n\t\t\t\t// 1. If internal is true and target does not start with \"../\" or \"/\" and is not a valid URL, then\n\t\t\t\tif (internal && !target.startsWith('../') && !target.startsWith('/')) {\n\t\t\t\t\tlet isURL = false;\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// eslint-disable-next-line no-new\n\t\t\t\t\t\tnew URL(target);\n\t\t\t\t\t\tisURL = true;\n\t\t\t\t\t} catch (e) {}\n\t\t\t\t\tif (!isURL) {\n\t\t\t\t\t\t// a. If pattern is true, then\n\t\t\t\t\t\tif (pattern) {\n\t\t\t\t\t\t\t// 1. Return PACKAGE_RESOLVE(target with every instance of \"*\" replaced by subpath, packageURL + \"/\").\n\t\t\t\t\t\t\treturn this.packageResolve(target.replace(/\\*/g, subpath), packageURL, conditions, extList);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// b. Return PACKAGE_RESOLVE(target + subpath, packageURL + \"/\").\n\t\t\t\t\t\treturn this.packageResolve(this.pathConcat(target, subpath), packageURL, conditions, extList);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Otherwise, throw an Invalid Package Target error.\n\t\t\t\tthrow new VMError(`Invalid package target for '${subpath}'`, 'ERR_INVALID_PACKAGE_TARGET');\n\t\t\t}\n\t\t\ttarget = decodeURI(target);\n\t\t\t// c. If target split on \"/\" or \"\\\" contains any \".\", \"..\" or \"node_modules\" segments after the first segment, case insensitive\n\t\t\t//    and including percent encoded variants, throw an Invalid Package Target error.\n\t\t\tif (target.split(/[/\\\\]/).slice(1).findIndex(x => x === '.' || x === '..' || x.toLowerCase() === 'node_modules') !== -1) {\n\t\t\t\tthrow new VMError(`Invalid package target for '${subpath}'`, 'ERR_INVALID_PACKAGE_TARGET');\n\t\t\t}\n\t\t\t// d. Let resolvedTarget be the URL resolution of the concatenation of packageURL and target.\n\t\t\tconst resolvedTarget = this.pathConcat(packageURL, target);\n\t\t\t// e. Assert: resolvedTarget is contained in packageURL.\n\t\t\tsubpath = decodeURI(subpath);\n\t\t\t// f. If subpath split on \"/\" or \"\\\" contains any \".\", \"..\" or \"node_modules\" segments, case insensitive and including percent\n\t\t\t//    encoded variants, throw an Invalid Module Specifier error.\n\t\t\tif (subpath.split(/[/\\\\]/).findIndex(x => x === '.' || x === '..' || x.toLowerCase() === 'node_modules') !== -1) {\n\t\t\t\tthrow new VMError(`Invalid package specifier '${subpath}'`, 'ERR_INVALID_MODULE_SPECIFIER');\n\t\t\t}\n\t\t\t// g. If pattern is true, then\n\t\t\tif (pattern) {\n\t\t\t\t// 1. Return the URL resolution of resolvedTarget with every instance of \"*\" replaced with subpath.\n\t\t\t\treturn resolvedTarget.replace(/\\*/g, subpath);\n\t\t\t}\n\t\t\t// h. Otherwise,\n\t\t\t// 1. Return the URL resolution of the concatenation of subpath and resolvedTarget.\n\t\t\treturn this.pathConcat(resolvedTarget, subpath);\n\t\t// 3. Otherwise, if target is an Array, then\n\t\t} else if (Array.isArray(target)) {\n\t\t\t// a. If target.length is zero, return null.\n\t\t\tif (target.length === 0) return null;\n\t\t\tlet lastException = undefined;\n\t\t\t// b. For each item targetValue in target, do\n\t\t\tfor (let i = 0; i < target.length; i++) {\n\t\t\t\tconst targetValue = target[i];\n\t\t\t\t// 1. Let resolved be the result of PACKAGE_TARGET_RESOLVE( packageURL, targetValue, subpath, pattern, internal, conditions),\n\t\t\t\t//    continuing the loop on any Invalid Package Target error.\n\t\t\t\tlet resolved;\n\t\t\t\ttry {\n\t\t\t\t\tresolved = this.packageTargetResolve(packageURL, targetValue, subpath, pattern, internal, conditions, extList);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (e.code !== 'ERR_INVALID_PACKAGE_TARGET') throw e;\n\t\t\t\t\tlastException = e;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// 2. If resolved is undefined, continue the loop.\n\t\t\t\t// 3. Return resolved.\n\t\t\t\tif (resolved !== undefined) return resolved;\n\t\t\t\tif (resolved === null) {\n\t\t\t\t\tlastException = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// c. Return or throw the last fallback resolution null return or error.\n\t\t\tif (lastException === undefined || lastException === null) return lastException;\n\t\t\tthrow lastException;\n\t\t// 2. Otherwise, if target is a non-null Object, then\n\t\t} else if (typeof target === 'object' && target !== null) {\n\t\t\tconst keys = Object.getOwnPropertyNames(target);\n\t\t\t// a. If exports contains any index property keys, as defined in ECMA-262 6.1.7 Array Index, throw an Invalid Package Configuration error.\n\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\tconst p = keys[i];\n\t\t\t\tif (isArrayIndex(p)) throw new VMError(`Invalid package configuration for '${subpath}'`, 'ERR_INVALID_PACKAGE_CONFIGURATION');\n\t\t\t}\n\t\t\t// b. For each property p of target, in object insertion order as,\n\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\tconst p = keys[i];\n\t\t\t\t// 1. If p equals \"default\" or conditions contains an entry for p, then\n\t\t\t\tif (p === 'default' || conditions.includes(p)) {\n\t\t\t\t\t// a. Let targetValue be the value of the p property in target.\n\t\t\t\t\tconst targetValue = target[p];\n\t\t\t\t\t// b. Let resolved be the result of PACKAGE_TARGET_RESOLVE( packageURL, targetValue, subpath, pattern, internal, conditions).\n\t\t\t\t\tconst resolved = this.packageTargetResolve(packageURL, targetValue, subpath, pattern, internal, conditions, extList);\n\t\t\t\t\t// c. If resolved is equal to undefined, continue the loop.\n\t\t\t\t\t// d. Return resolved.\n\t\t\t\t\tif (resolved !== undefined) return resolved;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// c. Return undefined.\n\t\t\treturn undefined;\n\t\t// 4. Otherwise, if target is null, return null.\n\t\t} else if (target == null) {\n\t\t\treturn null;\n\t\t}\n\t\t// Otherwise throw an Invalid Package Target error.\n\t\tthrow new VMError(`Invalid package target for '${subpath}'`, 'ERR_INVALID_PACKAGE_TARGET');\n\t}\n\n\t// PACKAGE_RESOLVE(packageSpecifier, parentURL)\n\tpackageResolve(packageSpecifier, parentURL, conditions, extList) {\n\t\t// 1. Let packageName be undefined.\n\t\tlet packageName = undefined;\n\t\t// 2. If packageSpecifier is an empty string, then\n\t\tif (packageSpecifier === '') {\n\t\t\t// a. Throw an Invalid Module Specifier error.\n\t\t\tthrow new VMError(`Invalid package specifier '${packageSpecifier}'`, 'ERR_INVALID_MODULE_SPECIFIER');\n\t\t}\n\t\t// 3. If packageSpecifier is a Node.js builtin module name, then\n\t\tif (this.builtinModules[packageSpecifier]) {\n\t\t\t// a. Return the string \"node:\" concatenated with packageSpecifier.\n\t\t\treturn 'node:' + packageSpecifier;\n\t\t}\n\t\tlet idx = packageSpecifier.indexOf('/');\n\t\t// 5. Otherwise,\n\t\tif (packageSpecifier[0] === '@') {\n\t\t\t// a. If packageSpecifier does not contain a \"/\" separator, then\n\t\t\tif (idx === -1) {\n\t\t\t\t// x. Throw an Invalid Module Specifier error.\n\t\t\t\tthrow new VMError(`Invalid package specifier '${packageSpecifier}'`, 'ERR_INVALID_MODULE_SPECIFIER');\n\t\t\t}\n\t\t\t// b. Set packageName to the substring of packageSpecifier until the second \"/\" separator or the end of the string.\n\t\t\tidx = packageSpecifier.indexOf('/', idx + 1);\n\t\t}\n\t\t// else\n\t\t// 4. If packageSpecifier does not start with \"@\", then\n\t\t// a. Set packageName to the substring of packageSpecifier until the first \"/\" separator or the end of the string.\n\t\tpackageName = idx === -1 ? packageSpecifier : packageSpecifier.slice(0, idx);\n\t\t// 6. If packageName starts with \".\" or contains \"\\\" or \"%\", then\n\t\tif (idx !== 0 && (packageName[0] === '.' || packageName.indexOf('\\\\') >= 0 || packageName.indexOf('%') >= 0)) {\n\t\t\t// a. Throw an Invalid Module Specifier error.\n\t\t\tthrow new VMError(`Invalid package specifier '${packageSpecifier}'`, 'ERR_INVALID_MODULE_SPECIFIER');\n\t\t}\n\t\t// 7. Let packageSubpath be \".\" concatenated with the substring of packageSpecifier from the position at the length of packageName.\n\t\tconst packageSubpath = '.' + packageSpecifier.slice(packageName.length);\n\t\t// 8. If packageSubpath ends in \"/\", then\n\t\tif (packageSubpath[packageSubpath.length - 1] === '/') {\n\t\t\t// a. Throw an Invalid Module Specifier error.\n\t\t\tthrow new VMError(`Invalid package specifier '${packageSpecifier}'`, 'ERR_INVALID_MODULE_SPECIFIER');\n\t\t}\n\t\t// 9. Let selfUrl be the result of PACKAGE_SELF_RESOLVE(packageName, packageSubpath, parentURL).\n\t\tconst selfUrl = this.packageSelfResolve(packageName, packageSubpath, parentURL);\n\t\t// 10. If selfUrl is not undefined, return selfUrl.\n\t\tif (selfUrl) return selfUrl;\n\t\t// 11. While parentURL is not the file system root,\n\t\tlet packageURL;\n\t\twhile (true) {\n\t\t\t// a. Let packageURL be the URL resolution of \"node_modules/\" concatenated with packageSpecifier, relative to parentURL.\n\t\t\tpackageURL = this.pathResolve(this.pathConcat(parentURL, 'node_modules', packageSpecifier));\n\t\t\t// b. Set parentURL to the parent folder URL of parentURL.\n\t\t\tconst parentParentURL = this.pathDirname(parentURL);\n\t\t\t// c. If the folder at packageURL does not exist, then\n\t\t\tif (this.isPathAllowed(packageURL) && this.pathTestIsDirectory(packageURL)) break;\n\t\t\t// 1. Continue the next loop iteration.\n\t\t\tif (parentParentURL === parentURL) {\n\t\t\t\t// 12. Throw a Module Not Found error.\n\t\t\t\tthrow new VMError(`Cannot find module '${packageSpecifier}'`, 'ENOTFOUND');\n\t\t\t}\n\t\t\tparentURL = parentParentURL;\n\t\t}\n\t\t// d. Let pjson be the result of READ_PACKAGE_JSON(packageURL).\n\t\tconst pack = this.readPackage(packageURL);\n\t\t// e. If pjson is not null and pjson.exports is not null or undefined, then\n\t\tif (pack && pack.exports) {\n\t\t\t// 1. Return the result of PACKAGE_EXPORTS_RESOLVE(packageURL, packageSubpath, pjson.exports, defaultConditions).\n\t\t\treturn this.packageExportsResolve(packageURL, packageSubpath, pack.exports, conditions, extList);\n\t\t}\n\t\t// f. Otherwise, if packageSubpath is equal to \".\", then\n\t\tif (packageSubpath === '.') {\n\t\t\t// 1. If pjson.main is a string, then\n\t\t\t// a. Return the URL resolution of main in packageURL.\n\t\t\treturn this.loadAsPackage(packageSubpath, pack, extList);\n\t\t}\n\t\t// g. Otherwise,\n\t\t// 1. Return the URL resolution of packageSubpath in packageURL.\n\t\treturn this.pathConcat(packageURL, packageSubpath);\n\t}\n\n}\n\nexports.Resolver = Resolver;\nexports.DefaultResolver = DefaultResolver;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}