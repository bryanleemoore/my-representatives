{"ast":null,"code":"\"use strict\";\n\n;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar types_1 = tslib_1.__importDefault(require(\"./types\"));\n\nfunction default_1(fork) {\n  var types = fork.use(types_1.default);\n  var getFieldNames = types.getFieldNames;\n  var getFieldValue = types.getFieldValue;\n  var isArray = types.builtInTypes.array;\n  var isObject = types.builtInTypes.object;\n  var isDate = types.builtInTypes.Date;\n  var isRegExp = types.builtInTypes.RegExp;\n  var hasOwn = Object.prototype.hasOwnProperty;\n\n  function astNodesAreEquivalent(a, b, problemPath) {\n    if (isArray.check(problemPath)) {\n      problemPath.length = 0;\n    } else {\n      problemPath = null;\n    }\n\n    return areEquivalent(a, b, problemPath);\n  }\n\n  astNodesAreEquivalent.assert = function (a, b) {\n    var problemPath = [];\n\n    if (!astNodesAreEquivalent(a, b, problemPath)) {\n      if (problemPath.length === 0) {\n        if (a !== b) {\n          throw new Error(\"Nodes must be equal\");\n        }\n      } else {\n        throw new Error(\"Nodes differ in the following path: \" + problemPath.map(subscriptForProperty).join(\"\"));\n      }\n    }\n  };\n\n  function subscriptForProperty(property) {\n    if (/[_$a-z][_$a-z0-9]*/i.test(property)) {\n      return \".\" + property;\n    }\n\n    return \"[\" + JSON.stringify(property) + \"]\";\n  }\n\n  function areEquivalent(a, b, problemPath) {\n    if (a === b) {\n      return true;\n    }\n\n    if (isArray.check(a)) {\n      return arraysAreEquivalent(a, b, problemPath);\n    }\n\n    if (isObject.check(a)) {\n      return objectsAreEquivalent(a, b, problemPath);\n    }\n\n    if (isDate.check(a)) {\n      return isDate.check(b) && +a === +b;\n    }\n\n    if (isRegExp.check(a)) {\n      return isRegExp.check(b) && a.source === b.source && a.global === b.global && a.multiline === b.multiline && a.ignoreCase === b.ignoreCase;\n    }\n\n    return a == b;\n  }\n\n  function arraysAreEquivalent(a, b, problemPath) {\n    isArray.assert(a);\n    var aLength = a.length;\n\n    if (!isArray.check(b) || b.length !== aLength) {\n      if (problemPath) {\n        problemPath.push(\"length\");\n      }\n\n      return false;\n    }\n\n    for (var i = 0; i < aLength; ++i) {\n      if (problemPath) {\n        problemPath.push(i);\n      }\n\n      if (i in a !== i in b) {\n        return false;\n      }\n\n      if (!areEquivalent(a[i], b[i], problemPath)) {\n        return false;\n      }\n\n      if (problemPath) {\n        var problemPathTail = problemPath.pop();\n\n        if (problemPathTail !== i) {\n          throw new Error(\"\" + problemPathTail);\n        }\n      }\n    }\n\n    return true;\n  }\n\n  function objectsAreEquivalent(a, b, problemPath) {\n    isObject.assert(a);\n\n    if (!isObject.check(b)) {\n      return false;\n    } // Fast path for a common property of AST nodes.\n\n\n    if (a.type !== b.type) {\n      if (problemPath) {\n        problemPath.push(\"type\");\n      }\n\n      return false;\n    }\n\n    var aNames = getFieldNames(a);\n    var aNameCount = aNames.length;\n    var bNames = getFieldNames(b);\n    var bNameCount = bNames.length;\n\n    if (aNameCount === bNameCount) {\n      for (var i = 0; i < aNameCount; ++i) {\n        var name = aNames[i];\n        var aChild = getFieldValue(a, name);\n        var bChild = getFieldValue(b, name);\n\n        if (problemPath) {\n          problemPath.push(name);\n        }\n\n        if (!areEquivalent(aChild, bChild, problemPath)) {\n          return false;\n        }\n\n        if (problemPath) {\n          var problemPathTail = problemPath.pop();\n\n          if (problemPathTail !== name) {\n            throw new Error(\"\" + problemPathTail);\n          }\n        }\n      }\n\n      return true;\n    }\n\n    if (!problemPath) {\n      return false;\n    } // Since aNameCount !== bNameCount, we need to find some name that's\n    // missing in aNames but present in bNames, or vice-versa.\n\n\n    var seenNames = Object.create(null);\n\n    for (i = 0; i < aNameCount; ++i) {\n      seenNames[aNames[i]] = true;\n    }\n\n    for (i = 0; i < bNameCount; ++i) {\n      name = bNames[i];\n\n      if (!hasOwn.call(seenNames, name)) {\n        problemPath.push(name);\n        return false;\n      }\n\n      delete seenNames[name];\n    }\n\n    for (name in seenNames) {\n      problemPath.push(name);\n      break;\n    }\n\n    return false;\n  }\n\n  return astNodesAreEquivalent;\n}\n\nexports.default = default_1;\nmodule.exports = exports[\"default\"];","map":{"version":3,"names":["Object","defineProperty","exports","value","tslib_1","require","types_1","__importDefault","default_1","fork","types","use","default","getFieldNames","getFieldValue","isArray","builtInTypes","array","isObject","object","isDate","Date","isRegExp","RegExp","hasOwn","prototype","hasOwnProperty","astNodesAreEquivalent","a","b","problemPath","check","length","areEquivalent","assert","Error","map","subscriptForProperty","join","property","test","JSON","stringify","arraysAreEquivalent","objectsAreEquivalent","source","global","multiline","ignoreCase","aLength","push","i","problemPathTail","pop","type","aNames","aNameCount","bNames","bNameCount","name","aChild","bChild","seenNames","create","call","module"],"sources":["C:/Users/bryan/Desktop/myrepresentatives/frontend/node_modules/ast-types/lib/equiv.js"],"sourcesContent":["\"use strict\";;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar types_1 = tslib_1.__importDefault(require(\"./types\"));\nfunction default_1(fork) {\n    var types = fork.use(types_1.default);\n    var getFieldNames = types.getFieldNames;\n    var getFieldValue = types.getFieldValue;\n    var isArray = types.builtInTypes.array;\n    var isObject = types.builtInTypes.object;\n    var isDate = types.builtInTypes.Date;\n    var isRegExp = types.builtInTypes.RegExp;\n    var hasOwn = Object.prototype.hasOwnProperty;\n    function astNodesAreEquivalent(a, b, problemPath) {\n        if (isArray.check(problemPath)) {\n            problemPath.length = 0;\n        }\n        else {\n            problemPath = null;\n        }\n        return areEquivalent(a, b, problemPath);\n    }\n    astNodesAreEquivalent.assert = function (a, b) {\n        var problemPath = [];\n        if (!astNodesAreEquivalent(a, b, problemPath)) {\n            if (problemPath.length === 0) {\n                if (a !== b) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n            }\n            else {\n                throw new Error(\"Nodes differ in the following path: \" +\n                    problemPath.map(subscriptForProperty).join(\"\"));\n            }\n        }\n    };\n    function subscriptForProperty(property) {\n        if (/[_$a-z][_$a-z0-9]*/i.test(property)) {\n            return \".\" + property;\n        }\n        return \"[\" + JSON.stringify(property) + \"]\";\n    }\n    function areEquivalent(a, b, problemPath) {\n        if (a === b) {\n            return true;\n        }\n        if (isArray.check(a)) {\n            return arraysAreEquivalent(a, b, problemPath);\n        }\n        if (isObject.check(a)) {\n            return objectsAreEquivalent(a, b, problemPath);\n        }\n        if (isDate.check(a)) {\n            return isDate.check(b) && (+a === +b);\n        }\n        if (isRegExp.check(a)) {\n            return isRegExp.check(b) && (a.source === b.source &&\n                a.global === b.global &&\n                a.multiline === b.multiline &&\n                a.ignoreCase === b.ignoreCase);\n        }\n        return a == b;\n    }\n    function arraysAreEquivalent(a, b, problemPath) {\n        isArray.assert(a);\n        var aLength = a.length;\n        if (!isArray.check(b) || b.length !== aLength) {\n            if (problemPath) {\n                problemPath.push(\"length\");\n            }\n            return false;\n        }\n        for (var i = 0; i < aLength; ++i) {\n            if (problemPath) {\n                problemPath.push(i);\n            }\n            if (i in a !== i in b) {\n                return false;\n            }\n            if (!areEquivalent(a[i], b[i], problemPath)) {\n                return false;\n            }\n            if (problemPath) {\n                var problemPathTail = problemPath.pop();\n                if (problemPathTail !== i) {\n                    throw new Error(\"\" + problemPathTail);\n                }\n            }\n        }\n        return true;\n    }\n    function objectsAreEquivalent(a, b, problemPath) {\n        isObject.assert(a);\n        if (!isObject.check(b)) {\n            return false;\n        }\n        // Fast path for a common property of AST nodes.\n        if (a.type !== b.type) {\n            if (problemPath) {\n                problemPath.push(\"type\");\n            }\n            return false;\n        }\n        var aNames = getFieldNames(a);\n        var aNameCount = aNames.length;\n        var bNames = getFieldNames(b);\n        var bNameCount = bNames.length;\n        if (aNameCount === bNameCount) {\n            for (var i = 0; i < aNameCount; ++i) {\n                var name = aNames[i];\n                var aChild = getFieldValue(a, name);\n                var bChild = getFieldValue(b, name);\n                if (problemPath) {\n                    problemPath.push(name);\n                }\n                if (!areEquivalent(aChild, bChild, problemPath)) {\n                    return false;\n                }\n                if (problemPath) {\n                    var problemPathTail = problemPath.pop();\n                    if (problemPathTail !== name) {\n                        throw new Error(\"\" + problemPathTail);\n                    }\n                }\n            }\n            return true;\n        }\n        if (!problemPath) {\n            return false;\n        }\n        // Since aNameCount !== bNameCount, we need to find some name that's\n        // missing in aNames but present in bNames, or vice-versa.\n        var seenNames = Object.create(null);\n        for (i = 0; i < aNameCount; ++i) {\n            seenNames[aNames[i]] = true;\n        }\n        for (i = 0; i < bNameCount; ++i) {\n            name = bNames[i];\n            if (!hasOwn.call(seenNames, name)) {\n                problemPath.push(name);\n                return false;\n            }\n            delete seenNames[name];\n        }\n        for (name in seenNames) {\n            problemPath.push(name);\n            break;\n        }\n        return false;\n    }\n    return astNodesAreEquivalent;\n}\nexports.default = default_1;\nmodule.exports = exports[\"default\"];\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}