{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Def = void 0;\n\nvar tslib_1 = require(\"tslib\");\n\nvar Op = Object.prototype;\nvar objToStr = Op.toString;\nvar hasOwn = Op.hasOwnProperty;\n\nvar BaseType =\n/** @class */\nfunction () {\n  function BaseType() {}\n\n  BaseType.prototype.assert = function (value, deep) {\n    if (!this.check(value, deep)) {\n      var str = shallowStringify(value);\n      throw new Error(str + \" does not match type \" + this);\n    }\n\n    return true;\n  };\n\n  BaseType.prototype.arrayOf = function () {\n    var elemType = this;\n    return new ArrayType(elemType);\n  };\n\n  return BaseType;\n}();\n\nvar ArrayType =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(ArrayType, _super);\n\n  function ArrayType(elemType) {\n    var _this = _super.call(this) || this;\n\n    _this.elemType = elemType;\n    _this.kind = \"ArrayType\";\n    return _this;\n  }\n\n  ArrayType.prototype.toString = function () {\n    return \"[\" + this.elemType + \"]\";\n  };\n\n  ArrayType.prototype.check = function (value, deep) {\n    var _this = this;\n\n    return Array.isArray(value) && value.every(function (elem) {\n      return _this.elemType.check(elem, deep);\n    });\n  };\n\n  return ArrayType;\n}(BaseType);\n\nvar IdentityType =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(IdentityType, _super);\n\n  function IdentityType(value) {\n    var _this = _super.call(this) || this;\n\n    _this.value = value;\n    _this.kind = \"IdentityType\";\n    return _this;\n  }\n\n  IdentityType.prototype.toString = function () {\n    return String(this.value);\n  };\n\n  IdentityType.prototype.check = function (value, deep) {\n    var result = value === this.value;\n\n    if (!result && typeof deep === \"function\") {\n      deep(this, value);\n    }\n\n    return result;\n  };\n\n  return IdentityType;\n}(BaseType);\n\nvar ObjectType =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(ObjectType, _super);\n\n  function ObjectType(fields) {\n    var _this = _super.call(this) || this;\n\n    _this.fields = fields;\n    _this.kind = \"ObjectType\";\n    return _this;\n  }\n\n  ObjectType.prototype.toString = function () {\n    return \"{ \" + this.fields.join(\", \") + \" }\";\n  };\n\n  ObjectType.prototype.check = function (value, deep) {\n    return objToStr.call(value) === objToStr.call({}) && this.fields.every(function (field) {\n      return field.type.check(value[field.name], deep);\n    });\n  };\n\n  return ObjectType;\n}(BaseType);\n\nvar OrType =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(OrType, _super);\n\n  function OrType(types) {\n    var _this = _super.call(this) || this;\n\n    _this.types = types;\n    _this.kind = \"OrType\";\n    return _this;\n  }\n\n  OrType.prototype.toString = function () {\n    return this.types.join(\" | \");\n  };\n\n  OrType.prototype.check = function (value, deep) {\n    return this.types.some(function (type) {\n      return type.check(value, deep);\n    });\n  };\n\n  return OrType;\n}(BaseType);\n\nvar PredicateType =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(PredicateType, _super);\n\n  function PredicateType(name, predicate) {\n    var _this = _super.call(this) || this;\n\n    _this.name = name;\n    _this.predicate = predicate;\n    _this.kind = \"PredicateType\";\n    return _this;\n  }\n\n  PredicateType.prototype.toString = function () {\n    return this.name;\n  };\n\n  PredicateType.prototype.check = function (value, deep) {\n    var result = this.predicate(value, deep);\n\n    if (!result && typeof deep === \"function\") {\n      deep(this, value);\n    }\n\n    return result;\n  };\n\n  return PredicateType;\n}(BaseType);\n\nvar Def =\n/** @class */\nfunction () {\n  function Def(type, typeName) {\n    this.type = type;\n    this.typeName = typeName;\n    this.baseNames = [];\n    this.ownFields = Object.create(null); // Includes own typeName. Populated during finalization.\n\n    this.allSupertypes = Object.create(null); // Linear inheritance hierarchy. Populated during finalization.\n\n    this.supertypeList = []; // Includes inherited fields.\n\n    this.allFields = Object.create(null); // Non-hidden keys of allFields.\n\n    this.fieldNames = []; // This property will be overridden as true by individual Def instances\n    // when they are finalized.\n\n    this.finalized = false; // False by default until .build(...) is called on an instance.\n\n    this.buildable = false;\n    this.buildParams = [];\n  }\n\n  Def.prototype.isSupertypeOf = function (that) {\n    if (that instanceof Def) {\n      if (this.finalized !== true || that.finalized !== true) {\n        throw new Error(\"\");\n      }\n\n      return hasOwn.call(that.allSupertypes, this.typeName);\n    } else {\n      throw new Error(that + \" is not a Def\");\n    }\n  };\n\n  Def.prototype.checkAllFields = function (value, deep) {\n    var allFields = this.allFields;\n\n    if (this.finalized !== true) {\n      throw new Error(\"\" + this.typeName);\n    }\n\n    function checkFieldByName(name) {\n      var field = allFields[name];\n      var type = field.type;\n      var child = field.getValue(value);\n      return type.check(child, deep);\n    }\n\n    return value !== null && typeof value === \"object\" && Object.keys(allFields).every(checkFieldByName);\n  };\n\n  Def.prototype.bases = function () {\n    var supertypeNames = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      supertypeNames[_i] = arguments[_i];\n    }\n\n    var bases = this.baseNames;\n\n    if (this.finalized) {\n      if (supertypeNames.length !== bases.length) {\n        throw new Error(\"\");\n      }\n\n      for (var i = 0; i < supertypeNames.length; i++) {\n        if (supertypeNames[i] !== bases[i]) {\n          throw new Error(\"\");\n        }\n      }\n\n      return this;\n    }\n\n    supertypeNames.forEach(function (baseName) {\n      // This indexOf lookup may be O(n), but the typical number of base\n      // names is very small, and indexOf is a native Array method.\n      if (bases.indexOf(baseName) < 0) {\n        bases.push(baseName);\n      }\n    });\n    return this; // For chaining.\n  };\n\n  return Def;\n}();\n\nexports.Def = Def;\n\nvar Field =\n/** @class */\nfunction () {\n  function Field(name, type, defaultFn, hidden) {\n    this.name = name;\n    this.type = type;\n    this.defaultFn = defaultFn;\n    this.hidden = !!hidden;\n  }\n\n  Field.prototype.toString = function () {\n    return JSON.stringify(this.name) + \": \" + this.type;\n  };\n\n  Field.prototype.getValue = function (obj) {\n    var value = obj[this.name];\n\n    if (typeof value !== \"undefined\") {\n      return value;\n    }\n\n    if (typeof this.defaultFn === \"function\") {\n      value = this.defaultFn.call(obj);\n    }\n\n    return value;\n  };\n\n  return Field;\n}();\n\nfunction shallowStringify(value) {\n  if (Array.isArray(value)) {\n    return \"[\" + value.map(shallowStringify).join(\", \") + \"]\";\n  }\n\n  if (value && typeof value === \"object\") {\n    return \"{ \" + Object.keys(value).map(function (key) {\n      return key + \": \" + value[key];\n    }).join(\", \") + \" }\";\n  }\n\n  return JSON.stringify(value);\n}\n\nfunction typesPlugin(_fork) {\n  var Type = {\n    or: function () {\n      var types = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        types[_i] = arguments[_i];\n      }\n\n      return new OrType(types.map(function (type) {\n        return Type.from(type);\n      }));\n    },\n    from: function (value, name) {\n      if (value instanceof ArrayType || value instanceof IdentityType || value instanceof ObjectType || value instanceof OrType || value instanceof PredicateType) {\n        return value;\n      } // The Def type is used as a helper for constructing compound\n      // interface types for AST nodes.\n\n\n      if (value instanceof Def) {\n        return value.type;\n      } // Support [ElemType] syntax.\n\n\n      if (isArray.check(value)) {\n        if (value.length !== 1) {\n          throw new Error(\"only one element type is permitted for typed arrays\");\n        }\n\n        return new ArrayType(Type.from(value[0]));\n      } // Support { someField: FieldType, ... } syntax.\n\n\n      if (isObject.check(value)) {\n        return new ObjectType(Object.keys(value).map(function (name) {\n          return new Field(name, Type.from(value[name], name));\n        }));\n      }\n\n      if (typeof value === \"function\") {\n        var bicfIndex = builtInCtorFns.indexOf(value);\n\n        if (bicfIndex >= 0) {\n          return builtInCtorTypes[bicfIndex];\n        }\n\n        if (typeof name !== \"string\") {\n          throw new Error(\"missing name\");\n        }\n\n        return new PredicateType(name, value);\n      } // As a last resort, toType returns a type that matches any value that\n      // is === from. This is primarily useful for literal values like\n      // toType(null), but it has the additional advantage of allowing\n      // toType to be a total function.\n\n\n      return new IdentityType(value);\n    },\n    // Define a type whose name is registered in a namespace (the defCache) so\n    // that future definitions will return the same type given the same name.\n    // In particular, this system allows for circular and forward definitions.\n    // The Def object d returned from Type.def may be used to configure the\n    // type d.type by calling methods such as d.bases, d.build, and d.field.\n    def: function (typeName) {\n      return hasOwn.call(defCache, typeName) ? defCache[typeName] : defCache[typeName] = new DefImpl(typeName);\n    },\n    hasDef: function (typeName) {\n      return hasOwn.call(defCache, typeName);\n    }\n  };\n  var builtInCtorFns = [];\n  var builtInCtorTypes = [];\n\n  function defBuiltInType(name, example) {\n    var objStr = objToStr.call(example);\n    var type = new PredicateType(name, function (value) {\n      return objToStr.call(value) === objStr;\n    });\n\n    if (example && typeof example.constructor === \"function\") {\n      builtInCtorFns.push(example.constructor);\n      builtInCtorTypes.push(type);\n    }\n\n    return type;\n  } // These types check the underlying [[Class]] attribute of the given\n  // value, rather than using the problematic typeof operator. Note however\n  // that no subtyping is considered; so, for instance, isObject.check\n  // returns false for [], /./, new Date, and null.\n\n\n  var isString = defBuiltInType(\"string\", \"truthy\");\n  var isFunction = defBuiltInType(\"function\", function () {});\n  var isArray = defBuiltInType(\"array\", []);\n  var isObject = defBuiltInType(\"object\", {});\n  var isRegExp = defBuiltInType(\"RegExp\", /./);\n  var isDate = defBuiltInType(\"Date\", new Date());\n  var isNumber = defBuiltInType(\"number\", 3);\n  var isBoolean = defBuiltInType(\"boolean\", true);\n  var isNull = defBuiltInType(\"null\", null);\n  var isUndefined = defBuiltInType(\"undefined\", undefined);\n  var builtInTypes = {\n    string: isString,\n    function: isFunction,\n    array: isArray,\n    object: isObject,\n    RegExp: isRegExp,\n    Date: isDate,\n    number: isNumber,\n    boolean: isBoolean,\n    null: isNull,\n    undefined: isUndefined\n  }; // In order to return the same Def instance every time Type.def is called\n  // with a particular name, those instances need to be stored in a cache.\n\n  var defCache = Object.create(null);\n\n  function defFromValue(value) {\n    if (value && typeof value === \"object\") {\n      var type = value.type;\n\n      if (typeof type === \"string\" && hasOwn.call(defCache, type)) {\n        var d = defCache[type];\n\n        if (d.finalized) {\n          return d;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  var DefImpl =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(DefImpl, _super);\n\n    function DefImpl(typeName) {\n      var _this = _super.call(this, new PredicateType(typeName, function (value, deep) {\n        return _this.check(value, deep);\n      }), typeName) || this;\n\n      return _this;\n    }\n\n    DefImpl.prototype.check = function (value, deep) {\n      if (this.finalized !== true) {\n        throw new Error(\"prematurely checking unfinalized type \" + this.typeName);\n      } // A Def type can only match an object value.\n\n\n      if (value === null || typeof value !== \"object\") {\n        return false;\n      }\n\n      var vDef = defFromValue(value);\n\n      if (!vDef) {\n        // If we couldn't infer the Def associated with the given value,\n        // and we expected it to be a SourceLocation or a Position, it was\n        // probably just missing a \"type\" field (because Esprima does not\n        // assign a type property to such nodes). Be optimistic and let\n        // this.checkAllFields make the final decision.\n        if (this.typeName === \"SourceLocation\" || this.typeName === \"Position\") {\n          return this.checkAllFields(value, deep);\n        } // Calling this.checkAllFields for any other type of node is both\n        // bad for performance and way too forgiving.\n\n\n        return false;\n      } // If checking deeply and vDef === this, then we only need to call\n      // checkAllFields once. Calling checkAllFields is too strict when deep\n      // is false, because then we only care about this.isSupertypeOf(vDef).\n\n\n      if (deep && vDef === this) {\n        return this.checkAllFields(value, deep);\n      } // In most cases we rely exclusively on isSupertypeOf to make O(1)\n      // subtyping determinations. This suffices in most situations outside\n      // of unit tests, since interface conformance is checked whenever new\n      // instances are created using builder functions.\n\n\n      if (!this.isSupertypeOf(vDef)) {\n        return false;\n      } // The exception is when deep is true; then, we recursively check all\n      // fields.\n\n\n      if (!deep) {\n        return true;\n      } // Use the more specific Def (vDef) to perform the deep check, but\n      // shallow-check fields defined by the less specific Def (this).\n\n\n      return vDef.checkAllFields(value, deep) && this.checkAllFields(value, false);\n    };\n\n    DefImpl.prototype.build = function () {\n      var _this = this;\n\n      var buildParams = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        buildParams[_i] = arguments[_i];\n      } // Calling Def.prototype.build multiple times has the effect of merely\n      // redefining this property.\n\n\n      this.buildParams = buildParams;\n\n      if (this.buildable) {\n        // If this Def is already buildable, update self.buildParams and\n        // continue using the old builder function.\n        return this;\n      } // Every buildable type will have its \"type\" field filled in\n      // automatically. This includes types that are not subtypes of Node,\n      // like SourceLocation, but that seems harmless (TODO?).\n\n\n      this.field(\"type\", String, function () {\n        return _this.typeName;\n      }); // Override Dp.buildable for this Def instance.\n\n      this.buildable = true;\n\n      var addParam = function (built, param, arg, isArgAvailable) {\n        if (hasOwn.call(built, param)) return;\n        var all = _this.allFields;\n\n        if (!hasOwn.call(all, param)) {\n          throw new Error(\"\" + param);\n        }\n\n        var field = all[param];\n        var type = field.type;\n        var value;\n\n        if (isArgAvailable) {\n          value = arg;\n        } else if (field.defaultFn) {\n          // Expose the partially-built object to the default\n          // function as its `this` object.\n          value = field.defaultFn.call(built);\n        } else {\n          var message = \"no value or default function given for field \" + JSON.stringify(param) + \" of \" + _this.typeName + \"(\" + _this.buildParams.map(function (name) {\n            return all[name];\n          }).join(\", \") + \")\";\n          throw new Error(message);\n        }\n\n        if (!type.check(value)) {\n          throw new Error(shallowStringify(value) + \" does not match field \" + field + \" of type \" + _this.typeName);\n        }\n\n        built[param] = value;\n      }; // Calling the builder function will construct an instance of the Def,\n      // with positional arguments mapped to the fields original passed to .build.\n      // If not enough arguments are provided, the default value for the remaining fields\n      // will be used.\n\n\n      var builder = function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        var argc = args.length;\n\n        if (!_this.finalized) {\n          throw new Error(\"attempting to instantiate unfinalized type \" + _this.typeName);\n        }\n\n        var built = Object.create(nodePrototype);\n\n        _this.buildParams.forEach(function (param, i) {\n          if (i < argc) {\n            addParam(built, param, args[i], true);\n          } else {\n            addParam(built, param, null, false);\n          }\n        });\n\n        Object.keys(_this.allFields).forEach(function (param) {\n          // Use the default value.\n          addParam(built, param, null, false);\n        }); // Make sure that the \"type\" field was filled automatically.\n\n        if (built.type !== _this.typeName) {\n          throw new Error(\"\");\n        }\n\n        return built;\n      }; // Calling .from on the builder function will construct an instance of the Def,\n      // using field values from the passed object. For fields missing from the passed object,\n      // their default value will be used.\n\n\n      builder.from = function (obj) {\n        if (!_this.finalized) {\n          throw new Error(\"attempting to instantiate unfinalized type \" + _this.typeName);\n        }\n\n        var built = Object.create(nodePrototype);\n        Object.keys(_this.allFields).forEach(function (param) {\n          if (hasOwn.call(obj, param)) {\n            addParam(built, param, obj[param], true);\n          } else {\n            addParam(built, param, null, false);\n          }\n        }); // Make sure that the \"type\" field was filled automatically.\n\n        if (built.type !== _this.typeName) {\n          throw new Error(\"\");\n        }\n\n        return built;\n      };\n\n      Object.defineProperty(builders, getBuilderName(this.typeName), {\n        enumerable: true,\n        value: builder\n      });\n      return this;\n    }; // The reason fields are specified using .field(...) instead of an object\n    // literal syntax is somewhat subtle: the object literal syntax would\n    // support only one key and one value, but with .field(...) we can pass\n    // any number of arguments to specify the field.\n\n\n    DefImpl.prototype.field = function (name, type, defaultFn, hidden) {\n      if (this.finalized) {\n        console.error(\"Ignoring attempt to redefine field \" + JSON.stringify(name) + \" of finalized type \" + JSON.stringify(this.typeName));\n        return this;\n      }\n\n      this.ownFields[name] = new Field(name, Type.from(type), defaultFn, hidden);\n      return this; // For chaining.\n    };\n\n    DefImpl.prototype.finalize = function () {\n      var _this = this; // It's not an error to finalize a type more than once, but only the\n      // first call to .finalize does anything.\n\n\n      if (!this.finalized) {\n        var allFields = this.allFields;\n        var allSupertypes = this.allSupertypes;\n        this.baseNames.forEach(function (name) {\n          var def = defCache[name];\n\n          if (def instanceof Def) {\n            def.finalize();\n            extend(allFields, def.allFields);\n            extend(allSupertypes, def.allSupertypes);\n          } else {\n            var message = \"unknown supertype name \" + JSON.stringify(name) + \" for subtype \" + JSON.stringify(_this.typeName);\n            throw new Error(message);\n          }\n        }); // TODO Warn if fields are overridden with incompatible types.\n\n        extend(allFields, this.ownFields);\n        allSupertypes[this.typeName] = this;\n        this.fieldNames.length = 0;\n\n        for (var fieldName in allFields) {\n          if (hasOwn.call(allFields, fieldName) && !allFields[fieldName].hidden) {\n            this.fieldNames.push(fieldName);\n          }\n        } // Types are exported only once they have been finalized.\n\n\n        Object.defineProperty(namedTypes, this.typeName, {\n          enumerable: true,\n          value: this.type\n        });\n        this.finalized = true; // A linearization of the inheritance hierarchy.\n\n        populateSupertypeList(this.typeName, this.supertypeList);\n\n        if (this.buildable && this.supertypeList.lastIndexOf(\"Expression\") >= 0) {\n          wrapExpressionBuilderWithStatement(this.typeName);\n        }\n      }\n    };\n\n    return DefImpl;\n  }(Def); // Note that the list returned by this function is a copy of the internal\n  // supertypeList, *without* the typeName itself as the first element.\n\n\n  function getSupertypeNames(typeName) {\n    if (!hasOwn.call(defCache, typeName)) {\n      throw new Error(\"\");\n    }\n\n    var d = defCache[typeName];\n\n    if (d.finalized !== true) {\n      throw new Error(\"\");\n    }\n\n    return d.supertypeList.slice(1);\n  } // Returns an object mapping from every known type in the defCache to the\n  // most specific supertype whose name is an own property of the candidates\n  // object.\n\n\n  function computeSupertypeLookupTable(candidates) {\n    var table = {};\n    var typeNames = Object.keys(defCache);\n    var typeNameCount = typeNames.length;\n\n    for (var i = 0; i < typeNameCount; ++i) {\n      var typeName = typeNames[i];\n      var d = defCache[typeName];\n\n      if (d.finalized !== true) {\n        throw new Error(\"\" + typeName);\n      }\n\n      for (var j = 0; j < d.supertypeList.length; ++j) {\n        var superTypeName = d.supertypeList[j];\n\n        if (hasOwn.call(candidates, superTypeName)) {\n          table[typeName] = superTypeName;\n          break;\n        }\n      }\n    }\n\n    return table;\n  }\n\n  var builders = Object.create(null); // This object is used as prototype for any node created by a builder.\n\n  var nodePrototype = {}; // Call this function to define a new method to be shared by all AST\n  // nodes. The replaced method (if any) is returned for easy wrapping.\n\n  function defineMethod(name, func) {\n    var old = nodePrototype[name]; // Pass undefined as func to delete nodePrototype[name].\n\n    if (isUndefined.check(func)) {\n      delete nodePrototype[name];\n    } else {\n      isFunction.assert(func);\n      Object.defineProperty(nodePrototype, name, {\n        enumerable: true,\n        configurable: true,\n        value: func\n      });\n    }\n\n    return old;\n  }\n\n  function getBuilderName(typeName) {\n    return typeName.replace(/^[A-Z]+/, function (upperCasePrefix) {\n      var len = upperCasePrefix.length;\n\n      switch (len) {\n        case 0:\n          return \"\";\n        // If there's only one initial capital letter, just lower-case it.\n\n        case 1:\n          return upperCasePrefix.toLowerCase();\n\n        default:\n          // If there's more than one initial capital letter, lower-case\n          // all but the last one, so that XMLDefaultDeclaration (for\n          // example) becomes xmlDefaultDeclaration.\n          return upperCasePrefix.slice(0, len - 1).toLowerCase() + upperCasePrefix.charAt(len - 1);\n      }\n    });\n  }\n\n  function getStatementBuilderName(typeName) {\n    typeName = getBuilderName(typeName);\n    return typeName.replace(/(Expression)?$/, \"Statement\");\n  }\n\n  var namedTypes = {}; // Like Object.keys, but aware of what fields each AST type should have.\n\n  function getFieldNames(object) {\n    var d = defFromValue(object);\n\n    if (d) {\n      return d.fieldNames.slice(0);\n    }\n\n    if (\"type\" in object) {\n      throw new Error(\"did not recognize object of type \" + JSON.stringify(object.type));\n    }\n\n    return Object.keys(object);\n  } // Get the value of an object property, taking object.type and default\n  // functions into account.\n\n\n  function getFieldValue(object, fieldName) {\n    var d = defFromValue(object);\n\n    if (d) {\n      var field = d.allFields[fieldName];\n\n      if (field) {\n        return field.getValue(object);\n      }\n    }\n\n    return object && object[fieldName];\n  } // Iterate over all defined fields of an object, including those missing\n  // or undefined, passing each field name and effective value (as returned\n  // by getFieldValue) to the callback. If the object has no corresponding\n  // Def, the callback will never be called.\n\n\n  function eachField(object, callback, context) {\n    getFieldNames(object).forEach(function (name) {\n      callback.call(this, name, getFieldValue(object, name));\n    }, context);\n  } // Similar to eachField, except that iteration stops as soon as the\n  // callback returns a truthy value. Like Array.prototype.some, the final\n  // result is either true or false to indicates whether the callback\n  // returned true for any element or not.\n\n\n  function someField(object, callback, context) {\n    return getFieldNames(object).some(function (name) {\n      return callback.call(this, name, getFieldValue(object, name));\n    }, context);\n  } // Adds an additional builder for Expression subtypes\n  // that wraps the built Expression in an ExpressionStatements.\n\n\n  function wrapExpressionBuilderWithStatement(typeName) {\n    var wrapperName = getStatementBuilderName(typeName); // skip if the builder already exists\n\n    if (builders[wrapperName]) return; // the builder function to wrap with builders.ExpressionStatement\n\n    var wrapped = builders[getBuilderName(typeName)]; // skip if there is nothing to wrap\n\n    if (!wrapped) return;\n\n    var builder = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return builders.expressionStatement(wrapped.apply(builders, args));\n    };\n\n    builder.from = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return builders.expressionStatement(wrapped.from.apply(builders, args));\n    };\n\n    builders[wrapperName] = builder;\n  }\n\n  function populateSupertypeList(typeName, list) {\n    list.length = 0;\n    list.push(typeName);\n    var lastSeen = Object.create(null);\n\n    for (var pos = 0; pos < list.length; ++pos) {\n      typeName = list[pos];\n      var d = defCache[typeName];\n\n      if (d.finalized !== true) {\n        throw new Error(\"\");\n      } // If we saw typeName earlier in the breadth-first traversal,\n      // delete the last-seen occurrence.\n\n\n      if (hasOwn.call(lastSeen, typeName)) {\n        delete list[lastSeen[typeName]];\n      } // Record the new index of the last-seen occurrence of typeName.\n\n\n      lastSeen[typeName] = pos; // Enqueue the base names of this type.\n\n      list.push.apply(list, d.baseNames);\n    } // Compaction loop to remove array holes.\n\n\n    for (var to = 0, from = to, len = list.length; from < len; ++from) {\n      if (hasOwn.call(list, from)) {\n        list[to++] = list[from];\n      }\n    }\n\n    list.length = to;\n  }\n\n  function extend(into, from) {\n    Object.keys(from).forEach(function (name) {\n      into[name] = from[name];\n    });\n    return into;\n  }\n\n  function finalize() {\n    Object.keys(defCache).forEach(function (name) {\n      defCache[name].finalize();\n    });\n  }\n\n  return {\n    Type: Type,\n    builtInTypes: builtInTypes,\n    getSupertypeNames: getSupertypeNames,\n    computeSupertypeLookupTable: computeSupertypeLookupTable,\n    builders: builders,\n    defineMethod: defineMethod,\n    getBuilderName: getBuilderName,\n    getStatementBuilderName: getStatementBuilderName,\n    namedTypes: namedTypes,\n    getFieldNames: getFieldNames,\n    getFieldValue: getFieldValue,\n    eachField: eachField,\n    someField: someField,\n    finalize: finalize\n  };\n}\n\nexports.default = typesPlugin;\n;","map":{"version":3,"names":["Object","defineProperty","exports","value","Def","tslib_1","require","Op","prototype","objToStr","toString","hasOwn","hasOwnProperty","BaseType","assert","deep","check","str","shallowStringify","Error","arrayOf","elemType","ArrayType","_super","__extends","_this","call","kind","Array","isArray","every","elem","IdentityType","String","result","ObjectType","fields","join","field","type","name","OrType","types","some","PredicateType","predicate","typeName","baseNames","ownFields","create","allSupertypes","supertypeList","allFields","fieldNames","finalized","buildable","buildParams","isSupertypeOf","that","checkAllFields","checkFieldByName","child","getValue","keys","bases","supertypeNames","_i","arguments","length","i","forEach","baseName","indexOf","push","Field","defaultFn","hidden","JSON","stringify","obj","map","key","typesPlugin","_fork","Type","or","from","isObject","bicfIndex","builtInCtorFns","builtInCtorTypes","def","defCache","DefImpl","hasDef","defBuiltInType","example","objStr","constructor","isString","isFunction","isRegExp","isDate","Date","isNumber","isBoolean","isNull","isUndefined","undefined","builtInTypes","string","function","array","object","RegExp","number","boolean","null","defFromValue","d","vDef","build","addParam","built","param","arg","isArgAvailable","all","message","builder","args","argc","nodePrototype","builders","getBuilderName","enumerable","console","error","finalize","extend","fieldName","namedTypes","populateSupertypeList","lastIndexOf","wrapExpressionBuilderWithStatement","getSupertypeNames","slice","computeSupertypeLookupTable","candidates","table","typeNames","typeNameCount","j","superTypeName","defineMethod","func","old","configurable","replace","upperCasePrefix","len","toLowerCase","charAt","getStatementBuilderName","getFieldNames","getFieldValue","eachField","callback","context","someField","wrapperName","wrapped","expressionStatement","apply","list","lastSeen","pos","to","into","default"],"sources":["C:/Users/bryan/Desktop/myrepresentatives/frontend/node_modules/ast-types/lib/types.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Def = void 0;\nvar tslib_1 = require(\"tslib\");\nvar Op = Object.prototype;\nvar objToStr = Op.toString;\nvar hasOwn = Op.hasOwnProperty;\nvar BaseType = /** @class */ (function () {\n    function BaseType() {\n    }\n    BaseType.prototype.assert = function (value, deep) {\n        if (!this.check(value, deep)) {\n            var str = shallowStringify(value);\n            throw new Error(str + \" does not match type \" + this);\n        }\n        return true;\n    };\n    BaseType.prototype.arrayOf = function () {\n        var elemType = this;\n        return new ArrayType(elemType);\n    };\n    return BaseType;\n}());\nvar ArrayType = /** @class */ (function (_super) {\n    tslib_1.__extends(ArrayType, _super);\n    function ArrayType(elemType) {\n        var _this = _super.call(this) || this;\n        _this.elemType = elemType;\n        _this.kind = \"ArrayType\";\n        return _this;\n    }\n    ArrayType.prototype.toString = function () {\n        return \"[\" + this.elemType + \"]\";\n    };\n    ArrayType.prototype.check = function (value, deep) {\n        var _this = this;\n        return Array.isArray(value) && value.every(function (elem) { return _this.elemType.check(elem, deep); });\n    };\n    return ArrayType;\n}(BaseType));\nvar IdentityType = /** @class */ (function (_super) {\n    tslib_1.__extends(IdentityType, _super);\n    function IdentityType(value) {\n        var _this = _super.call(this) || this;\n        _this.value = value;\n        _this.kind = \"IdentityType\";\n        return _this;\n    }\n    IdentityType.prototype.toString = function () {\n        return String(this.value);\n    };\n    IdentityType.prototype.check = function (value, deep) {\n        var result = value === this.value;\n        if (!result && typeof deep === \"function\") {\n            deep(this, value);\n        }\n        return result;\n    };\n    return IdentityType;\n}(BaseType));\nvar ObjectType = /** @class */ (function (_super) {\n    tslib_1.__extends(ObjectType, _super);\n    function ObjectType(fields) {\n        var _this = _super.call(this) || this;\n        _this.fields = fields;\n        _this.kind = \"ObjectType\";\n        return _this;\n    }\n    ObjectType.prototype.toString = function () {\n        return \"{ \" + this.fields.join(\", \") + \" }\";\n    };\n    ObjectType.prototype.check = function (value, deep) {\n        return (objToStr.call(value) === objToStr.call({}) &&\n            this.fields.every(function (field) {\n                return field.type.check(value[field.name], deep);\n            }));\n    };\n    return ObjectType;\n}(BaseType));\nvar OrType = /** @class */ (function (_super) {\n    tslib_1.__extends(OrType, _super);\n    function OrType(types) {\n        var _this = _super.call(this) || this;\n        _this.types = types;\n        _this.kind = \"OrType\";\n        return _this;\n    }\n    OrType.prototype.toString = function () {\n        return this.types.join(\" | \");\n    };\n    OrType.prototype.check = function (value, deep) {\n        return this.types.some(function (type) {\n            return type.check(value, deep);\n        });\n    };\n    return OrType;\n}(BaseType));\nvar PredicateType = /** @class */ (function (_super) {\n    tslib_1.__extends(PredicateType, _super);\n    function PredicateType(name, predicate) {\n        var _this = _super.call(this) || this;\n        _this.name = name;\n        _this.predicate = predicate;\n        _this.kind = \"PredicateType\";\n        return _this;\n    }\n    PredicateType.prototype.toString = function () {\n        return this.name;\n    };\n    PredicateType.prototype.check = function (value, deep) {\n        var result = this.predicate(value, deep);\n        if (!result && typeof deep === \"function\") {\n            deep(this, value);\n        }\n        return result;\n    };\n    return PredicateType;\n}(BaseType));\nvar Def = /** @class */ (function () {\n    function Def(type, typeName) {\n        this.type = type;\n        this.typeName = typeName;\n        this.baseNames = [];\n        this.ownFields = Object.create(null);\n        // Includes own typeName. Populated during finalization.\n        this.allSupertypes = Object.create(null);\n        // Linear inheritance hierarchy. Populated during finalization.\n        this.supertypeList = [];\n        // Includes inherited fields.\n        this.allFields = Object.create(null);\n        // Non-hidden keys of allFields.\n        this.fieldNames = [];\n        // This property will be overridden as true by individual Def instances\n        // when they are finalized.\n        this.finalized = false;\n        // False by default until .build(...) is called on an instance.\n        this.buildable = false;\n        this.buildParams = [];\n    }\n    Def.prototype.isSupertypeOf = function (that) {\n        if (that instanceof Def) {\n            if (this.finalized !== true ||\n                that.finalized !== true) {\n                throw new Error(\"\");\n            }\n            return hasOwn.call(that.allSupertypes, this.typeName);\n        }\n        else {\n            throw new Error(that + \" is not a Def\");\n        }\n    };\n    Def.prototype.checkAllFields = function (value, deep) {\n        var allFields = this.allFields;\n        if (this.finalized !== true) {\n            throw new Error(\"\" + this.typeName);\n        }\n        function checkFieldByName(name) {\n            var field = allFields[name];\n            var type = field.type;\n            var child = field.getValue(value);\n            return type.check(child, deep);\n        }\n        return value !== null &&\n            typeof value === \"object\" &&\n            Object.keys(allFields).every(checkFieldByName);\n    };\n    Def.prototype.bases = function () {\n        var supertypeNames = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            supertypeNames[_i] = arguments[_i];\n        }\n        var bases = this.baseNames;\n        if (this.finalized) {\n            if (supertypeNames.length !== bases.length) {\n                throw new Error(\"\");\n            }\n            for (var i = 0; i < supertypeNames.length; i++) {\n                if (supertypeNames[i] !== bases[i]) {\n                    throw new Error(\"\");\n                }\n            }\n            return this;\n        }\n        supertypeNames.forEach(function (baseName) {\n            // This indexOf lookup may be O(n), but the typical number of base\n            // names is very small, and indexOf is a native Array method.\n            if (bases.indexOf(baseName) < 0) {\n                bases.push(baseName);\n            }\n        });\n        return this; // For chaining.\n    };\n    return Def;\n}());\nexports.Def = Def;\nvar Field = /** @class */ (function () {\n    function Field(name, type, defaultFn, hidden) {\n        this.name = name;\n        this.type = type;\n        this.defaultFn = defaultFn;\n        this.hidden = !!hidden;\n    }\n    Field.prototype.toString = function () {\n        return JSON.stringify(this.name) + \": \" + this.type;\n    };\n    Field.prototype.getValue = function (obj) {\n        var value = obj[this.name];\n        if (typeof value !== \"undefined\") {\n            return value;\n        }\n        if (typeof this.defaultFn === \"function\") {\n            value = this.defaultFn.call(obj);\n        }\n        return value;\n    };\n    return Field;\n}());\nfunction shallowStringify(value) {\n    if (Array.isArray(value)) {\n        return \"[\" + value.map(shallowStringify).join(\", \") + \"]\";\n    }\n    if (value && typeof value === \"object\") {\n        return \"{ \" + Object.keys(value).map(function (key) {\n            return key + \": \" + value[key];\n        }).join(\", \") + \" }\";\n    }\n    return JSON.stringify(value);\n}\nfunction typesPlugin(_fork) {\n    var Type = {\n        or: function () {\n            var types = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                types[_i] = arguments[_i];\n            }\n            return new OrType(types.map(function (type) { return Type.from(type); }));\n        },\n        from: function (value, name) {\n            if (value instanceof ArrayType ||\n                value instanceof IdentityType ||\n                value instanceof ObjectType ||\n                value instanceof OrType ||\n                value instanceof PredicateType) {\n                return value;\n            }\n            // The Def type is used as a helper for constructing compound\n            // interface types for AST nodes.\n            if (value instanceof Def) {\n                return value.type;\n            }\n            // Support [ElemType] syntax.\n            if (isArray.check(value)) {\n                if (value.length !== 1) {\n                    throw new Error(\"only one element type is permitted for typed arrays\");\n                }\n                return new ArrayType(Type.from(value[0]));\n            }\n            // Support { someField: FieldType, ... } syntax.\n            if (isObject.check(value)) {\n                return new ObjectType(Object.keys(value).map(function (name) {\n                    return new Field(name, Type.from(value[name], name));\n                }));\n            }\n            if (typeof value === \"function\") {\n                var bicfIndex = builtInCtorFns.indexOf(value);\n                if (bicfIndex >= 0) {\n                    return builtInCtorTypes[bicfIndex];\n                }\n                if (typeof name !== \"string\") {\n                    throw new Error(\"missing name\");\n                }\n                return new PredicateType(name, value);\n            }\n            // As a last resort, toType returns a type that matches any value that\n            // is === from. This is primarily useful for literal values like\n            // toType(null), but it has the additional advantage of allowing\n            // toType to be a total function.\n            return new IdentityType(value);\n        },\n        // Define a type whose name is registered in a namespace (the defCache) so\n        // that future definitions will return the same type given the same name.\n        // In particular, this system allows for circular and forward definitions.\n        // The Def object d returned from Type.def may be used to configure the\n        // type d.type by calling methods such as d.bases, d.build, and d.field.\n        def: function (typeName) {\n            return hasOwn.call(defCache, typeName)\n                ? defCache[typeName]\n                : defCache[typeName] = new DefImpl(typeName);\n        },\n        hasDef: function (typeName) {\n            return hasOwn.call(defCache, typeName);\n        }\n    };\n    var builtInCtorFns = [];\n    var builtInCtorTypes = [];\n    function defBuiltInType(name, example) {\n        var objStr = objToStr.call(example);\n        var type = new PredicateType(name, function (value) { return objToStr.call(value) === objStr; });\n        if (example && typeof example.constructor === \"function\") {\n            builtInCtorFns.push(example.constructor);\n            builtInCtorTypes.push(type);\n        }\n        return type;\n    }\n    // These types check the underlying [[Class]] attribute of the given\n    // value, rather than using the problematic typeof operator. Note however\n    // that no subtyping is considered; so, for instance, isObject.check\n    // returns false for [], /./, new Date, and null.\n    var isString = defBuiltInType(\"string\", \"truthy\");\n    var isFunction = defBuiltInType(\"function\", function () { });\n    var isArray = defBuiltInType(\"array\", []);\n    var isObject = defBuiltInType(\"object\", {});\n    var isRegExp = defBuiltInType(\"RegExp\", /./);\n    var isDate = defBuiltInType(\"Date\", new Date());\n    var isNumber = defBuiltInType(\"number\", 3);\n    var isBoolean = defBuiltInType(\"boolean\", true);\n    var isNull = defBuiltInType(\"null\", null);\n    var isUndefined = defBuiltInType(\"undefined\", undefined);\n    var builtInTypes = {\n        string: isString,\n        function: isFunction,\n        array: isArray,\n        object: isObject,\n        RegExp: isRegExp,\n        Date: isDate,\n        number: isNumber,\n        boolean: isBoolean,\n        null: isNull,\n        undefined: isUndefined,\n    };\n    // In order to return the same Def instance every time Type.def is called\n    // with a particular name, those instances need to be stored in a cache.\n    var defCache = Object.create(null);\n    function defFromValue(value) {\n        if (value && typeof value === \"object\") {\n            var type = value.type;\n            if (typeof type === \"string\" &&\n                hasOwn.call(defCache, type)) {\n                var d = defCache[type];\n                if (d.finalized) {\n                    return d;\n                }\n            }\n        }\n        return null;\n    }\n    var DefImpl = /** @class */ (function (_super) {\n        tslib_1.__extends(DefImpl, _super);\n        function DefImpl(typeName) {\n            var _this = _super.call(this, new PredicateType(typeName, function (value, deep) { return _this.check(value, deep); }), typeName) || this;\n            return _this;\n        }\n        DefImpl.prototype.check = function (value, deep) {\n            if (this.finalized !== true) {\n                throw new Error(\"prematurely checking unfinalized type \" + this.typeName);\n            }\n            // A Def type can only match an object value.\n            if (value === null || typeof value !== \"object\") {\n                return false;\n            }\n            var vDef = defFromValue(value);\n            if (!vDef) {\n                // If we couldn't infer the Def associated with the given value,\n                // and we expected it to be a SourceLocation or a Position, it was\n                // probably just missing a \"type\" field (because Esprima does not\n                // assign a type property to such nodes). Be optimistic and let\n                // this.checkAllFields make the final decision.\n                if (this.typeName === \"SourceLocation\" ||\n                    this.typeName === \"Position\") {\n                    return this.checkAllFields(value, deep);\n                }\n                // Calling this.checkAllFields for any other type of node is both\n                // bad for performance and way too forgiving.\n                return false;\n            }\n            // If checking deeply and vDef === this, then we only need to call\n            // checkAllFields once. Calling checkAllFields is too strict when deep\n            // is false, because then we only care about this.isSupertypeOf(vDef).\n            if (deep && vDef === this) {\n                return this.checkAllFields(value, deep);\n            }\n            // In most cases we rely exclusively on isSupertypeOf to make O(1)\n            // subtyping determinations. This suffices in most situations outside\n            // of unit tests, since interface conformance is checked whenever new\n            // instances are created using builder functions.\n            if (!this.isSupertypeOf(vDef)) {\n                return false;\n            }\n            // The exception is when deep is true; then, we recursively check all\n            // fields.\n            if (!deep) {\n                return true;\n            }\n            // Use the more specific Def (vDef) to perform the deep check, but\n            // shallow-check fields defined by the less specific Def (this).\n            return vDef.checkAllFields(value, deep)\n                && this.checkAllFields(value, false);\n        };\n        DefImpl.prototype.build = function () {\n            var _this = this;\n            var buildParams = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                buildParams[_i] = arguments[_i];\n            }\n            // Calling Def.prototype.build multiple times has the effect of merely\n            // redefining this property.\n            this.buildParams = buildParams;\n            if (this.buildable) {\n                // If this Def is already buildable, update self.buildParams and\n                // continue using the old builder function.\n                return this;\n            }\n            // Every buildable type will have its \"type\" field filled in\n            // automatically. This includes types that are not subtypes of Node,\n            // like SourceLocation, but that seems harmless (TODO?).\n            this.field(\"type\", String, function () { return _this.typeName; });\n            // Override Dp.buildable for this Def instance.\n            this.buildable = true;\n            var addParam = function (built, param, arg, isArgAvailable) {\n                if (hasOwn.call(built, param))\n                    return;\n                var all = _this.allFields;\n                if (!hasOwn.call(all, param)) {\n                    throw new Error(\"\" + param);\n                }\n                var field = all[param];\n                var type = field.type;\n                var value;\n                if (isArgAvailable) {\n                    value = arg;\n                }\n                else if (field.defaultFn) {\n                    // Expose the partially-built object to the default\n                    // function as its `this` object.\n                    value = field.defaultFn.call(built);\n                }\n                else {\n                    var message = \"no value or default function given for field \" +\n                        JSON.stringify(param) + \" of \" + _this.typeName + \"(\" +\n                        _this.buildParams.map(function (name) {\n                            return all[name];\n                        }).join(\", \") + \")\";\n                    throw new Error(message);\n                }\n                if (!type.check(value)) {\n                    throw new Error(shallowStringify(value) +\n                        \" does not match field \" + field +\n                        \" of type \" + _this.typeName);\n                }\n                built[param] = value;\n            };\n            // Calling the builder function will construct an instance of the Def,\n            // with positional arguments mapped to the fields original passed to .build.\n            // If not enough arguments are provided, the default value for the remaining fields\n            // will be used.\n            var builder = function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                var argc = args.length;\n                if (!_this.finalized) {\n                    throw new Error(\"attempting to instantiate unfinalized type \" +\n                        _this.typeName);\n                }\n                var built = Object.create(nodePrototype);\n                _this.buildParams.forEach(function (param, i) {\n                    if (i < argc) {\n                        addParam(built, param, args[i], true);\n                    }\n                    else {\n                        addParam(built, param, null, false);\n                    }\n                });\n                Object.keys(_this.allFields).forEach(function (param) {\n                    // Use the default value.\n                    addParam(built, param, null, false);\n                });\n                // Make sure that the \"type\" field was filled automatically.\n                if (built.type !== _this.typeName) {\n                    throw new Error(\"\");\n                }\n                return built;\n            };\n            // Calling .from on the builder function will construct an instance of the Def,\n            // using field values from the passed object. For fields missing from the passed object,\n            // their default value will be used.\n            builder.from = function (obj) {\n                if (!_this.finalized) {\n                    throw new Error(\"attempting to instantiate unfinalized type \" +\n                        _this.typeName);\n                }\n                var built = Object.create(nodePrototype);\n                Object.keys(_this.allFields).forEach(function (param) {\n                    if (hasOwn.call(obj, param)) {\n                        addParam(built, param, obj[param], true);\n                    }\n                    else {\n                        addParam(built, param, null, false);\n                    }\n                });\n                // Make sure that the \"type\" field was filled automatically.\n                if (built.type !== _this.typeName) {\n                    throw new Error(\"\");\n                }\n                return built;\n            };\n            Object.defineProperty(builders, getBuilderName(this.typeName), {\n                enumerable: true,\n                value: builder\n            });\n            return this;\n        };\n        // The reason fields are specified using .field(...) instead of an object\n        // literal syntax is somewhat subtle: the object literal syntax would\n        // support only one key and one value, but with .field(...) we can pass\n        // any number of arguments to specify the field.\n        DefImpl.prototype.field = function (name, type, defaultFn, hidden) {\n            if (this.finalized) {\n                console.error(\"Ignoring attempt to redefine field \" +\n                    JSON.stringify(name) + \" of finalized type \" +\n                    JSON.stringify(this.typeName));\n                return this;\n            }\n            this.ownFields[name] = new Field(name, Type.from(type), defaultFn, hidden);\n            return this; // For chaining.\n        };\n        DefImpl.prototype.finalize = function () {\n            var _this = this;\n            // It's not an error to finalize a type more than once, but only the\n            // first call to .finalize does anything.\n            if (!this.finalized) {\n                var allFields = this.allFields;\n                var allSupertypes = this.allSupertypes;\n                this.baseNames.forEach(function (name) {\n                    var def = defCache[name];\n                    if (def instanceof Def) {\n                        def.finalize();\n                        extend(allFields, def.allFields);\n                        extend(allSupertypes, def.allSupertypes);\n                    }\n                    else {\n                        var message = \"unknown supertype name \" +\n                            JSON.stringify(name) +\n                            \" for subtype \" +\n                            JSON.stringify(_this.typeName);\n                        throw new Error(message);\n                    }\n                });\n                // TODO Warn if fields are overridden with incompatible types.\n                extend(allFields, this.ownFields);\n                allSupertypes[this.typeName] = this;\n                this.fieldNames.length = 0;\n                for (var fieldName in allFields) {\n                    if (hasOwn.call(allFields, fieldName) &&\n                        !allFields[fieldName].hidden) {\n                        this.fieldNames.push(fieldName);\n                    }\n                }\n                // Types are exported only once they have been finalized.\n                Object.defineProperty(namedTypes, this.typeName, {\n                    enumerable: true,\n                    value: this.type\n                });\n                this.finalized = true;\n                // A linearization of the inheritance hierarchy.\n                populateSupertypeList(this.typeName, this.supertypeList);\n                if (this.buildable &&\n                    this.supertypeList.lastIndexOf(\"Expression\") >= 0) {\n                    wrapExpressionBuilderWithStatement(this.typeName);\n                }\n            }\n        };\n        return DefImpl;\n    }(Def));\n    // Note that the list returned by this function is a copy of the internal\n    // supertypeList, *without* the typeName itself as the first element.\n    function getSupertypeNames(typeName) {\n        if (!hasOwn.call(defCache, typeName)) {\n            throw new Error(\"\");\n        }\n        var d = defCache[typeName];\n        if (d.finalized !== true) {\n            throw new Error(\"\");\n        }\n        return d.supertypeList.slice(1);\n    }\n    // Returns an object mapping from every known type in the defCache to the\n    // most specific supertype whose name is an own property of the candidates\n    // object.\n    function computeSupertypeLookupTable(candidates) {\n        var table = {};\n        var typeNames = Object.keys(defCache);\n        var typeNameCount = typeNames.length;\n        for (var i = 0; i < typeNameCount; ++i) {\n            var typeName = typeNames[i];\n            var d = defCache[typeName];\n            if (d.finalized !== true) {\n                throw new Error(\"\" + typeName);\n            }\n            for (var j = 0; j < d.supertypeList.length; ++j) {\n                var superTypeName = d.supertypeList[j];\n                if (hasOwn.call(candidates, superTypeName)) {\n                    table[typeName] = superTypeName;\n                    break;\n                }\n            }\n        }\n        return table;\n    }\n    var builders = Object.create(null);\n    // This object is used as prototype for any node created by a builder.\n    var nodePrototype = {};\n    // Call this function to define a new method to be shared by all AST\n    // nodes. The replaced method (if any) is returned for easy wrapping.\n    function defineMethod(name, func) {\n        var old = nodePrototype[name];\n        // Pass undefined as func to delete nodePrototype[name].\n        if (isUndefined.check(func)) {\n            delete nodePrototype[name];\n        }\n        else {\n            isFunction.assert(func);\n            Object.defineProperty(nodePrototype, name, {\n                enumerable: true,\n                configurable: true,\n                value: func\n            });\n        }\n        return old;\n    }\n    function getBuilderName(typeName) {\n        return typeName.replace(/^[A-Z]+/, function (upperCasePrefix) {\n            var len = upperCasePrefix.length;\n            switch (len) {\n                case 0: return \"\";\n                // If there's only one initial capital letter, just lower-case it.\n                case 1: return upperCasePrefix.toLowerCase();\n                default:\n                    // If there's more than one initial capital letter, lower-case\n                    // all but the last one, so that XMLDefaultDeclaration (for\n                    // example) becomes xmlDefaultDeclaration.\n                    return upperCasePrefix.slice(0, len - 1).toLowerCase() +\n                        upperCasePrefix.charAt(len - 1);\n            }\n        });\n    }\n    function getStatementBuilderName(typeName) {\n        typeName = getBuilderName(typeName);\n        return typeName.replace(/(Expression)?$/, \"Statement\");\n    }\n    var namedTypes = {};\n    // Like Object.keys, but aware of what fields each AST type should have.\n    function getFieldNames(object) {\n        var d = defFromValue(object);\n        if (d) {\n            return d.fieldNames.slice(0);\n        }\n        if (\"type\" in object) {\n            throw new Error(\"did not recognize object of type \" +\n                JSON.stringify(object.type));\n        }\n        return Object.keys(object);\n    }\n    // Get the value of an object property, taking object.type and default\n    // functions into account.\n    function getFieldValue(object, fieldName) {\n        var d = defFromValue(object);\n        if (d) {\n            var field = d.allFields[fieldName];\n            if (field) {\n                return field.getValue(object);\n            }\n        }\n        return object && object[fieldName];\n    }\n    // Iterate over all defined fields of an object, including those missing\n    // or undefined, passing each field name and effective value (as returned\n    // by getFieldValue) to the callback. If the object has no corresponding\n    // Def, the callback will never be called.\n    function eachField(object, callback, context) {\n        getFieldNames(object).forEach(function (name) {\n            callback.call(this, name, getFieldValue(object, name));\n        }, context);\n    }\n    // Similar to eachField, except that iteration stops as soon as the\n    // callback returns a truthy value. Like Array.prototype.some, the final\n    // result is either true or false to indicates whether the callback\n    // returned true for any element or not.\n    function someField(object, callback, context) {\n        return getFieldNames(object).some(function (name) {\n            return callback.call(this, name, getFieldValue(object, name));\n        }, context);\n    }\n    // Adds an additional builder for Expression subtypes\n    // that wraps the built Expression in an ExpressionStatements.\n    function wrapExpressionBuilderWithStatement(typeName) {\n        var wrapperName = getStatementBuilderName(typeName);\n        // skip if the builder already exists\n        if (builders[wrapperName])\n            return;\n        // the builder function to wrap with builders.ExpressionStatement\n        var wrapped = builders[getBuilderName(typeName)];\n        // skip if there is nothing to wrap\n        if (!wrapped)\n            return;\n        var builder = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return builders.expressionStatement(wrapped.apply(builders, args));\n        };\n        builder.from = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return builders.expressionStatement(wrapped.from.apply(builders, args));\n        };\n        builders[wrapperName] = builder;\n    }\n    function populateSupertypeList(typeName, list) {\n        list.length = 0;\n        list.push(typeName);\n        var lastSeen = Object.create(null);\n        for (var pos = 0; pos < list.length; ++pos) {\n            typeName = list[pos];\n            var d = defCache[typeName];\n            if (d.finalized !== true) {\n                throw new Error(\"\");\n            }\n            // If we saw typeName earlier in the breadth-first traversal,\n            // delete the last-seen occurrence.\n            if (hasOwn.call(lastSeen, typeName)) {\n                delete list[lastSeen[typeName]];\n            }\n            // Record the new index of the last-seen occurrence of typeName.\n            lastSeen[typeName] = pos;\n            // Enqueue the base names of this type.\n            list.push.apply(list, d.baseNames);\n        }\n        // Compaction loop to remove array holes.\n        for (var to = 0, from = to, len = list.length; from < len; ++from) {\n            if (hasOwn.call(list, from)) {\n                list[to++] = list[from];\n            }\n        }\n        list.length = to;\n    }\n    function extend(into, from) {\n        Object.keys(from).forEach(function (name) {\n            into[name] = from[name];\n        });\n        return into;\n    }\n    function finalize() {\n        Object.keys(defCache).forEach(function (name) {\n            defCache[name].finalize();\n        });\n    }\n    return {\n        Type: Type,\n        builtInTypes: builtInTypes,\n        getSupertypeNames: getSupertypeNames,\n        computeSupertypeLookupTable: computeSupertypeLookupTable,\n        builders: builders,\n        defineMethod: defineMethod,\n        getBuilderName: getBuilderName,\n        getStatementBuilderName: getStatementBuilderName,\n        namedTypes: namedTypes,\n        getFieldNames: getFieldNames,\n        getFieldValue: getFieldValue,\n        eachField: eachField,\n        someField: someField,\n        finalize: finalize,\n    };\n}\nexports.default = typesPlugin;\n;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}