{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst stream_1 = require(\"stream\");\n\nconst crypto_1 = require(\"crypto\");\n\nconst data_uri_to_buffer_1 = __importDefault(require(\"data-uri-to-buffer\"));\n\nconst notmodified_1 = __importDefault(require(\"./notmodified\"));\n\nconst debug = debug_1.default('get-uri:data');\n\nclass DataReadable extends stream_1.Readable {\n  constructor(hash, buf) {\n    super();\n    this.push(buf);\n    this.push(null);\n    this.hash = hash;\n  }\n\n}\n/**\n * Returns a Readable stream from a \"data:\" URI.\n */\n\n\nfunction get(_ref, _ref2) {\n  let {\n    href: uri\n  } = _ref;\n  let {\n    cache\n  } = _ref2;\n  return __awaiter(this, void 0, void 0, function* () {\n    // need to create a SHA1 hash of the URI string, for cacheability checks\n    // in future `getUri()` calls with the same data URI passed in.\n    const shasum = crypto_1.createHash('sha1');\n    shasum.update(uri);\n    const hash = shasum.digest('hex');\n    debug('generated SHA1 hash for \"data:\" URI: %o', hash); // check if the cache is the same \"data:\" URI that was previously passed in.\n\n    if (cache && cache.hash === hash) {\n      debug('got matching cache SHA1 hash: %o', hash);\n      throw new notmodified_1.default();\n    } else {\n      debug('creating Readable stream from \"data:\" URI buffer');\n      const buf = data_uri_to_buffer_1.default(uri);\n      return new DataReadable(hash, buf);\n    }\n  });\n}\n\nexports.default = get;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AACA;;AAEA;;AAEA;;AAEA,MAAMA,KAAK,GAAGC,gBAAY,cAAZ,CAAd;;AAEA,MAAMC,YAAN,SAA2BC,iBAA3B,CAAmC;EAGlCC,YAAYC,IAAZ,EAA0BC,GAA1B,EAAqC;IACpC;IACA,KAAKC,IAAL,CAAUD,GAAV;IACA,KAAKC,IAAL,CAAU,IAAV;IACA,KAAKF,IAAL,GAAYA,IAAZ;EACA;;AARiC;AAenC;;;;;AAGA,SAA8BG,GAA9B,cAEuB;EAAA,IADtB;IAAEC,IAAI,EAAEC;EAAR,CACsB;EAAA,IAAtB;IAAEC;EAAF,CAAsB;;IAEtB;IACA;IACA,MAAMC,MAAM,GAAGC,oBAAW,MAAX,CAAf;IACAD,MAAM,CAACE,MAAP,CAAcJ,GAAd;IACA,MAAML,IAAI,GAAGO,MAAM,CAACG,MAAP,CAAc,KAAd,CAAb;IACAf,KAAK,CAAC,yCAAD,EAA4CK,IAA5C,CAAL,EAEA;;IACA,IAAIM,KAAK,IAAIA,KAAK,CAACN,IAAN,KAAeA,IAA5B,EAAkC;MACjCL,KAAK,CAAC,kCAAD,EAAqCK,IAArC,CAAL;MACA,MAAM,IAAIW,qBAAJ,EAAN;IACA,CAHD,MAGO;MACNhB,KAAK,CAAC,kDAAD,CAAL;MACA,MAAMM,GAAG,GAAGW,6BAAgBP,GAAhB,CAAZ;MACA,OAAO,IAAIR,YAAJ,CAAiBG,IAAjB,EAAuBC,GAAvB,CAAP;IACA;EACD;AAAA;;AApBDY","names":["debug","debug_1","DataReadable","stream_1","constructor","hash","buf","push","get","href","uri","cache","shasum","crypto_1","update","digest","notmodified_1","data_uri_to_buffer_1","exports"],"sources":["../src/data.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}