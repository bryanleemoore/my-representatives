{"ast":null,"code":"\"use strict\";\n\n;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar types_1 = tslib_1.__importDefault(require(\"./types\"));\n\nvar Op = Object.prototype;\nvar hasOwn = Op.hasOwnProperty;\n\nfunction pathPlugin(fork) {\n  var types = fork.use(types_1.default);\n  var isArray = types.builtInTypes.array;\n  var isNumber = types.builtInTypes.number;\n\n  var Path = function Path(value, parentPath, name) {\n    if (!(this instanceof Path)) {\n      throw new Error(\"Path constructor cannot be invoked without 'new'\");\n    }\n\n    if (parentPath) {\n      if (!(parentPath instanceof Path)) {\n        throw new Error(\"\");\n      }\n    } else {\n      parentPath = null;\n      name = null;\n    } // The value encapsulated by this Path, generally equal to\n    // parentPath.value[name] if we have a parentPath.\n\n\n    this.value = value; // The immediate parent Path of this Path.\n\n    this.parentPath = parentPath; // The name of the property of parentPath.value through which this\n    // Path's value was reached.\n\n    this.name = name; // Calling path.get(\"child\") multiple times always returns the same\n    // child Path object, for both performance and consistency reasons.\n\n    this.__childCache = null;\n  };\n\n  var Pp = Path.prototype;\n\n  function getChildCache(path) {\n    // Lazily create the child cache. This also cheapens cache\n    // invalidation, since you can just reset path.__childCache to null.\n    return path.__childCache || (path.__childCache = Object.create(null));\n  }\n\n  function getChildPath(path, name) {\n    var cache = getChildCache(path);\n    var actualChildValue = path.getValueProperty(name);\n    var childPath = cache[name];\n\n    if (!hasOwn.call(cache, name) || // Ensure consistency between cache and reality.\n    childPath.value !== actualChildValue) {\n      childPath = cache[name] = new path.constructor(actualChildValue, path, name);\n    }\n\n    return childPath;\n  } // This method is designed to be overridden by subclasses that need to\n  // handle missing properties, etc.\n\n\n  Pp.getValueProperty = function getValueProperty(name) {\n    return this.value[name];\n  };\n\n  Pp.get = function get() {\n    var names = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      names[_i] = arguments[_i];\n    }\n\n    var path = this;\n    var count = names.length;\n\n    for (var i = 0; i < count; ++i) {\n      path = getChildPath(path, names[i]);\n    }\n\n    return path;\n  };\n\n  Pp.each = function each(callback, context) {\n    var childPaths = [];\n    var len = this.value.length;\n    var i = 0; // Collect all the original child paths before invoking the callback.\n\n    for (var i = 0; i < len; ++i) {\n      if (hasOwn.call(this.value, i)) {\n        childPaths[i] = this.get(i);\n      }\n    } // Invoke the callback on just the original child paths, regardless of\n    // any modifications made to the array by the callback. I chose these\n    // semantics over cleverly invoking the callback on new elements because\n    // this way is much easier to reason about.\n\n\n    context = context || this;\n\n    for (i = 0; i < len; ++i) {\n      if (hasOwn.call(childPaths, i)) {\n        callback.call(context, childPaths[i]);\n      }\n    }\n  };\n\n  Pp.map = function map(callback, context) {\n    var result = [];\n    this.each(function (childPath) {\n      result.push(callback.call(this, childPath));\n    }, context);\n    return result;\n  };\n\n  Pp.filter = function filter(callback, context) {\n    var result = [];\n    this.each(function (childPath) {\n      if (callback.call(this, childPath)) {\n        result.push(childPath);\n      }\n    }, context);\n    return result;\n  };\n\n  function emptyMoves() {}\n\n  function getMoves(path, offset, start, end) {\n    isArray.assert(path.value);\n\n    if (offset === 0) {\n      return emptyMoves;\n    }\n\n    var length = path.value.length;\n\n    if (length < 1) {\n      return emptyMoves;\n    }\n\n    var argc = arguments.length;\n\n    if (argc === 2) {\n      start = 0;\n      end = length;\n    } else if (argc === 3) {\n      start = Math.max(start, 0);\n      end = length;\n    } else {\n      start = Math.max(start, 0);\n      end = Math.min(end, length);\n    }\n\n    isNumber.assert(start);\n    isNumber.assert(end);\n    var moves = Object.create(null);\n    var cache = getChildCache(path);\n\n    for (var i = start; i < end; ++i) {\n      if (hasOwn.call(path.value, i)) {\n        var childPath = path.get(i);\n\n        if (childPath.name !== i) {\n          throw new Error(\"\");\n        }\n\n        var newIndex = i + offset;\n        childPath.name = newIndex;\n        moves[newIndex] = childPath;\n        delete cache[i];\n      }\n    }\n\n    delete cache.length;\n    return function () {\n      for (var newIndex in moves) {\n        var childPath = moves[newIndex];\n\n        if (childPath.name !== +newIndex) {\n          throw new Error(\"\");\n        }\n\n        cache[newIndex] = childPath;\n        path.value[newIndex] = childPath.value;\n      }\n    };\n  }\n\n  Pp.shift = function shift() {\n    var move = getMoves(this, -1);\n    var result = this.value.shift();\n    move();\n    return result;\n  };\n\n  Pp.unshift = function unshift() {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var move = getMoves(this, args.length);\n    var result = this.value.unshift.apply(this.value, args);\n    move();\n    return result;\n  };\n\n  Pp.push = function push() {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    isArray.assert(this.value);\n    delete getChildCache(this).length;\n    return this.value.push.apply(this.value, args);\n  };\n\n  Pp.pop = function pop() {\n    isArray.assert(this.value);\n    var cache = getChildCache(this);\n    delete cache[this.value.length - 1];\n    delete cache.length;\n    return this.value.pop();\n  };\n\n  Pp.insertAt = function insertAt(index) {\n    var argc = arguments.length;\n    var move = getMoves(this, argc - 1, index);\n\n    if (move === emptyMoves && argc <= 1) {\n      return this;\n    }\n\n    index = Math.max(index, 0);\n\n    for (var i = 1; i < argc; ++i) {\n      this.value[index + i - 1] = arguments[i];\n    }\n\n    move();\n    return this;\n  };\n\n  Pp.insertBefore = function insertBefore() {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var pp = this.parentPath;\n    var argc = args.length;\n    var insertAtArgs = [this.name];\n\n    for (var i = 0; i < argc; ++i) {\n      insertAtArgs.push(args[i]);\n    }\n\n    return pp.insertAt.apply(pp, insertAtArgs);\n  };\n\n  Pp.insertAfter = function insertAfter() {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var pp = this.parentPath;\n    var argc = args.length;\n    var insertAtArgs = [this.name + 1];\n\n    for (var i = 0; i < argc; ++i) {\n      insertAtArgs.push(args[i]);\n    }\n\n    return pp.insertAt.apply(pp, insertAtArgs);\n  };\n\n  function repairRelationshipWithParent(path) {\n    if (!(path instanceof Path)) {\n      throw new Error(\"\");\n    }\n\n    var pp = path.parentPath;\n\n    if (!pp) {\n      // Orphan paths have no relationship to repair.\n      return path;\n    }\n\n    var parentValue = pp.value;\n    var parentCache = getChildCache(pp); // Make sure parentCache[path.name] is populated.\n\n    if (parentValue[path.name] === path.value) {\n      parentCache[path.name] = path;\n    } else if (isArray.check(parentValue)) {\n      // Something caused path.name to become out of date, so attempt to\n      // recover by searching for path.value in parentValue.\n      var i = parentValue.indexOf(path.value);\n\n      if (i >= 0) {\n        parentCache[path.name = i] = path;\n      }\n    } else {\n      // If path.value disagrees with parentValue[path.name], and\n      // path.name is not an array index, let path.value become the new\n      // parentValue[path.name] and update parentCache accordingly.\n      parentValue[path.name] = path.value;\n      parentCache[path.name] = path;\n    }\n\n    if (parentValue[path.name] !== path.value) {\n      throw new Error(\"\");\n    }\n\n    if (path.parentPath.get(path.name) !== path) {\n      throw new Error(\"\");\n    }\n\n    return path;\n  }\n\n  Pp.replace = function replace(replacement) {\n    var results = [];\n    var parentValue = this.parentPath.value;\n    var parentCache = getChildCache(this.parentPath);\n    var count = arguments.length;\n    repairRelationshipWithParent(this);\n\n    if (isArray.check(parentValue)) {\n      var originalLength = parentValue.length;\n      var move = getMoves(this.parentPath, count - 1, this.name + 1);\n      var spliceArgs = [this.name, 1];\n\n      for (var i = 0; i < count; ++i) {\n        spliceArgs.push(arguments[i]);\n      }\n\n      var splicedOut = parentValue.splice.apply(parentValue, spliceArgs);\n\n      if (splicedOut[0] !== this.value) {\n        throw new Error(\"\");\n      }\n\n      if (parentValue.length !== originalLength - 1 + count) {\n        throw new Error(\"\");\n      }\n\n      move();\n\n      if (count === 0) {\n        delete this.value;\n        delete parentCache[this.name];\n        this.__childCache = null;\n      } else {\n        if (parentValue[this.name] !== replacement) {\n          throw new Error(\"\");\n        }\n\n        if (this.value !== replacement) {\n          this.value = replacement;\n          this.__childCache = null;\n        }\n\n        for (i = 0; i < count; ++i) {\n          results.push(this.parentPath.get(this.name + i));\n        }\n\n        if (results[0] !== this) {\n          throw new Error(\"\");\n        }\n      }\n    } else if (count === 1) {\n      if (this.value !== replacement) {\n        this.__childCache = null;\n      }\n\n      this.value = parentValue[this.name] = replacement;\n      results.push(this);\n    } else if (count === 0) {\n      delete parentValue[this.name];\n      delete this.value;\n      this.__childCache = null; // Leave this path cached as parentCache[this.name], even though\n      // it no longer has a value defined.\n    } else {\n      throw new Error(\"Could not replace path\");\n    }\n\n    return results;\n  };\n\n  return Path;\n}\n\nexports.default = pathPlugin;\nmodule.exports = exports[\"default\"];","map":{"version":3,"names":["Object","defineProperty","exports","value","tslib_1","require","types_1","__importDefault","Op","prototype","hasOwn","hasOwnProperty","pathPlugin","fork","types","use","default","isArray","builtInTypes","array","isNumber","number","Path","parentPath","name","Error","__childCache","Pp","getChildCache","path","create","getChildPath","cache","actualChildValue","getValueProperty","childPath","call","constructor","get","names","_i","arguments","length","count","i","each","callback","context","childPaths","len","map","result","push","filter","emptyMoves","getMoves","offset","start","end","assert","argc","Math","max","min","moves","newIndex","shift","move","unshift","args","apply","pop","insertAt","index","insertBefore","pp","insertAtArgs","insertAfter","repairRelationshipWithParent","parentValue","parentCache","check","indexOf","replace","replacement","results","originalLength","spliceArgs","splicedOut","splice","module"],"sources":["C:/Users/bryan/Desktop/myrepresentatives/frontend/node_modules/ast-types/lib/path.js"],"sourcesContent":["\"use strict\";;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar types_1 = tslib_1.__importDefault(require(\"./types\"));\nvar Op = Object.prototype;\nvar hasOwn = Op.hasOwnProperty;\nfunction pathPlugin(fork) {\n    var types = fork.use(types_1.default);\n    var isArray = types.builtInTypes.array;\n    var isNumber = types.builtInTypes.number;\n    var Path = function Path(value, parentPath, name) {\n        if (!(this instanceof Path)) {\n            throw new Error(\"Path constructor cannot be invoked without 'new'\");\n        }\n        if (parentPath) {\n            if (!(parentPath instanceof Path)) {\n                throw new Error(\"\");\n            }\n        }\n        else {\n            parentPath = null;\n            name = null;\n        }\n        // The value encapsulated by this Path, generally equal to\n        // parentPath.value[name] if we have a parentPath.\n        this.value = value;\n        // The immediate parent Path of this Path.\n        this.parentPath = parentPath;\n        // The name of the property of parentPath.value through which this\n        // Path's value was reached.\n        this.name = name;\n        // Calling path.get(\"child\") multiple times always returns the same\n        // child Path object, for both performance and consistency reasons.\n        this.__childCache = null;\n    };\n    var Pp = Path.prototype;\n    function getChildCache(path) {\n        // Lazily create the child cache. This also cheapens cache\n        // invalidation, since you can just reset path.__childCache to null.\n        return path.__childCache || (path.__childCache = Object.create(null));\n    }\n    function getChildPath(path, name) {\n        var cache = getChildCache(path);\n        var actualChildValue = path.getValueProperty(name);\n        var childPath = cache[name];\n        if (!hasOwn.call(cache, name) ||\n            // Ensure consistency between cache and reality.\n            childPath.value !== actualChildValue) {\n            childPath = cache[name] = new path.constructor(actualChildValue, path, name);\n        }\n        return childPath;\n    }\n    // This method is designed to be overridden by subclasses that need to\n    // handle missing properties, etc.\n    Pp.getValueProperty = function getValueProperty(name) {\n        return this.value[name];\n    };\n    Pp.get = function get() {\n        var names = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            names[_i] = arguments[_i];\n        }\n        var path = this;\n        var count = names.length;\n        for (var i = 0; i < count; ++i) {\n            path = getChildPath(path, names[i]);\n        }\n        return path;\n    };\n    Pp.each = function each(callback, context) {\n        var childPaths = [];\n        var len = this.value.length;\n        var i = 0;\n        // Collect all the original child paths before invoking the callback.\n        for (var i = 0; i < len; ++i) {\n            if (hasOwn.call(this.value, i)) {\n                childPaths[i] = this.get(i);\n            }\n        }\n        // Invoke the callback on just the original child paths, regardless of\n        // any modifications made to the array by the callback. I chose these\n        // semantics over cleverly invoking the callback on new elements because\n        // this way is much easier to reason about.\n        context = context || this;\n        for (i = 0; i < len; ++i) {\n            if (hasOwn.call(childPaths, i)) {\n                callback.call(context, childPaths[i]);\n            }\n        }\n    };\n    Pp.map = function map(callback, context) {\n        var result = [];\n        this.each(function (childPath) {\n            result.push(callback.call(this, childPath));\n        }, context);\n        return result;\n    };\n    Pp.filter = function filter(callback, context) {\n        var result = [];\n        this.each(function (childPath) {\n            if (callback.call(this, childPath)) {\n                result.push(childPath);\n            }\n        }, context);\n        return result;\n    };\n    function emptyMoves() { }\n    function getMoves(path, offset, start, end) {\n        isArray.assert(path.value);\n        if (offset === 0) {\n            return emptyMoves;\n        }\n        var length = path.value.length;\n        if (length < 1) {\n            return emptyMoves;\n        }\n        var argc = arguments.length;\n        if (argc === 2) {\n            start = 0;\n            end = length;\n        }\n        else if (argc === 3) {\n            start = Math.max(start, 0);\n            end = length;\n        }\n        else {\n            start = Math.max(start, 0);\n            end = Math.min(end, length);\n        }\n        isNumber.assert(start);\n        isNumber.assert(end);\n        var moves = Object.create(null);\n        var cache = getChildCache(path);\n        for (var i = start; i < end; ++i) {\n            if (hasOwn.call(path.value, i)) {\n                var childPath = path.get(i);\n                if (childPath.name !== i) {\n                    throw new Error(\"\");\n                }\n                var newIndex = i + offset;\n                childPath.name = newIndex;\n                moves[newIndex] = childPath;\n                delete cache[i];\n            }\n        }\n        delete cache.length;\n        return function () {\n            for (var newIndex in moves) {\n                var childPath = moves[newIndex];\n                if (childPath.name !== +newIndex) {\n                    throw new Error(\"\");\n                }\n                cache[newIndex] = childPath;\n                path.value[newIndex] = childPath.value;\n            }\n        };\n    }\n    Pp.shift = function shift() {\n        var move = getMoves(this, -1);\n        var result = this.value.shift();\n        move();\n        return result;\n    };\n    Pp.unshift = function unshift() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var move = getMoves(this, args.length);\n        var result = this.value.unshift.apply(this.value, args);\n        move();\n        return result;\n    };\n    Pp.push = function push() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        isArray.assert(this.value);\n        delete getChildCache(this).length;\n        return this.value.push.apply(this.value, args);\n    };\n    Pp.pop = function pop() {\n        isArray.assert(this.value);\n        var cache = getChildCache(this);\n        delete cache[this.value.length - 1];\n        delete cache.length;\n        return this.value.pop();\n    };\n    Pp.insertAt = function insertAt(index) {\n        var argc = arguments.length;\n        var move = getMoves(this, argc - 1, index);\n        if (move === emptyMoves && argc <= 1) {\n            return this;\n        }\n        index = Math.max(index, 0);\n        for (var i = 1; i < argc; ++i) {\n            this.value[index + i - 1] = arguments[i];\n        }\n        move();\n        return this;\n    };\n    Pp.insertBefore = function insertBefore() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var pp = this.parentPath;\n        var argc = args.length;\n        var insertAtArgs = [this.name];\n        for (var i = 0; i < argc; ++i) {\n            insertAtArgs.push(args[i]);\n        }\n        return pp.insertAt.apply(pp, insertAtArgs);\n    };\n    Pp.insertAfter = function insertAfter() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var pp = this.parentPath;\n        var argc = args.length;\n        var insertAtArgs = [this.name + 1];\n        for (var i = 0; i < argc; ++i) {\n            insertAtArgs.push(args[i]);\n        }\n        return pp.insertAt.apply(pp, insertAtArgs);\n    };\n    function repairRelationshipWithParent(path) {\n        if (!(path instanceof Path)) {\n            throw new Error(\"\");\n        }\n        var pp = path.parentPath;\n        if (!pp) {\n            // Orphan paths have no relationship to repair.\n            return path;\n        }\n        var parentValue = pp.value;\n        var parentCache = getChildCache(pp);\n        // Make sure parentCache[path.name] is populated.\n        if (parentValue[path.name] === path.value) {\n            parentCache[path.name] = path;\n        }\n        else if (isArray.check(parentValue)) {\n            // Something caused path.name to become out of date, so attempt to\n            // recover by searching for path.value in parentValue.\n            var i = parentValue.indexOf(path.value);\n            if (i >= 0) {\n                parentCache[path.name = i] = path;\n            }\n        }\n        else {\n            // If path.value disagrees with parentValue[path.name], and\n            // path.name is not an array index, let path.value become the new\n            // parentValue[path.name] and update parentCache accordingly.\n            parentValue[path.name] = path.value;\n            parentCache[path.name] = path;\n        }\n        if (parentValue[path.name] !== path.value) {\n            throw new Error(\"\");\n        }\n        if (path.parentPath.get(path.name) !== path) {\n            throw new Error(\"\");\n        }\n        return path;\n    }\n    Pp.replace = function replace(replacement) {\n        var results = [];\n        var parentValue = this.parentPath.value;\n        var parentCache = getChildCache(this.parentPath);\n        var count = arguments.length;\n        repairRelationshipWithParent(this);\n        if (isArray.check(parentValue)) {\n            var originalLength = parentValue.length;\n            var move = getMoves(this.parentPath, count - 1, this.name + 1);\n            var spliceArgs = [this.name, 1];\n            for (var i = 0; i < count; ++i) {\n                spliceArgs.push(arguments[i]);\n            }\n            var splicedOut = parentValue.splice.apply(parentValue, spliceArgs);\n            if (splicedOut[0] !== this.value) {\n                throw new Error(\"\");\n            }\n            if (parentValue.length !== (originalLength - 1 + count)) {\n                throw new Error(\"\");\n            }\n            move();\n            if (count === 0) {\n                delete this.value;\n                delete parentCache[this.name];\n                this.__childCache = null;\n            }\n            else {\n                if (parentValue[this.name] !== replacement) {\n                    throw new Error(\"\");\n                }\n                if (this.value !== replacement) {\n                    this.value = replacement;\n                    this.__childCache = null;\n                }\n                for (i = 0; i < count; ++i) {\n                    results.push(this.parentPath.get(this.name + i));\n                }\n                if (results[0] !== this) {\n                    throw new Error(\"\");\n                }\n            }\n        }\n        else if (count === 1) {\n            if (this.value !== replacement) {\n                this.__childCache = null;\n            }\n            this.value = parentValue[this.name] = replacement;\n            results.push(this);\n        }\n        else if (count === 0) {\n            delete parentValue[this.name];\n            delete this.value;\n            this.__childCache = null;\n            // Leave this path cached as parentCache[this.name], even though\n            // it no longer has a value defined.\n        }\n        else {\n            throw new Error(\"Could not replace path\");\n        }\n        return results;\n    };\n    return Path;\n}\nexports.default = pathPlugin;\nmodule.exports = exports[\"default\"];\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}