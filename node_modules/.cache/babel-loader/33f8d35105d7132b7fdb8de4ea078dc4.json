{"ast":null,"code":"\"use strict\";\n\nconst util_1 = require(\"util\");\n\nconst escodegen_1 = require(\"escodegen\");\n\nconst esprima_1 = require(\"esprima\");\n\nconst ast_types_1 = require(\"ast-types\");\n\nconst vm2_1 = require(\"vm2\");\n/**\n * Compiles sync JavaScript code into JavaScript with async Functions.\n *\n * @param {String} code JavaScript string to convert\n * @param {Array} names Array of function names to add `await` operators to\n * @return {String} Converted JavaScript string with async/await injected\n * @api public\n */\n\n\nfunction degenerator(code, _names) {\n  if (!Array.isArray(_names)) {\n    throw new TypeError('an array of async function \"names\" is required');\n  } // Duplicate the `names` array since it's rude to augment the user args\n\n\n  const names = _names.slice(0);\n\n  const ast = esprima_1.parseScript(code); // First pass is to find the `function` nodes and turn them into async or\n  // generator functions only if their body includes `CallExpressions` to\n  // function in `names`. We also add the names of the functions to the `names`\n  // array. We'll iterate several time, as every iteration might add new items\n  // to the `names` array, until no new names were added in the iteration.\n\n  let lastNamesLength = 0;\n\n  do {\n    lastNamesLength = names.length;\n    ast_types_1.visit(ast, {\n      visitVariableDeclaration(path) {\n        if (path.node.declarations) {\n          for (let i = 0; i < path.node.declarations.length; i++) {\n            const declaration = path.node.declarations[i];\n\n            if (ast_types_1.namedTypes.VariableDeclarator.check(declaration) && ast_types_1.namedTypes.Identifier.check(declaration.init) && ast_types_1.namedTypes.Identifier.check(declaration.id) && checkName(declaration.init.name, names) && !checkName(declaration.id.name, names)) {\n              names.push(declaration.id.name);\n            }\n          }\n        }\n\n        return false;\n      },\n\n      visitAssignmentExpression(path) {\n        if (ast_types_1.namedTypes.Identifier.check(path.node.left) && ast_types_1.namedTypes.Identifier.check(path.node.right) && checkName(path.node.right.name, names) && !checkName(path.node.left.name, names)) {\n          names.push(path.node.left.name);\n        }\n\n        return false;\n      },\n\n      visitFunction(path) {\n        if (path.node.id) {\n          let shouldDegenerate = false;\n          ast_types_1.visit(path.node, {\n            visitCallExpression(path) {\n              if (checkNames(path.node, names)) {\n                shouldDegenerate = true;\n              }\n\n              return false;\n            }\n\n          });\n\n          if (!shouldDegenerate) {\n            return false;\n          } // Got a \"function\" expression/statement,\n          // convert it into an async function\n\n\n          path.node.async = true; // Add function name to `names` array\n\n          if (!checkName(path.node.id.name, names)) {\n            names.push(path.node.id.name);\n          }\n        }\n\n        this.traverse(path);\n      }\n\n    });\n  } while (lastNamesLength !== names.length); // Second pass is for adding `await`/`yield` statements to any function\n  // invocations that match the given `names` array.\n\n\n  ast_types_1.visit(ast, {\n    visitCallExpression(path) {\n      if (checkNames(path.node, names)) {\n        // A \"function invocation\" expression,\n        // we need to inject a `AwaitExpression`/`YieldExpression`\n        const delegate = false;\n        const {\n          name,\n          parent: {\n            node: pNode\n          }\n        } = path;\n        const expr = ast_types_1.builders.awaitExpression(path.node, delegate);\n\n        if (ast_types_1.namedTypes.CallExpression.check(pNode)) {\n          pNode.arguments[name] = expr;\n        } else {\n          pNode[name] = expr;\n        }\n      }\n\n      this.traverse(path);\n    }\n\n  });\n  return escodegen_1.generate(ast);\n}\n\n(function (degenerator) {\n  function compile(code, returnName, names) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const compiled = degenerator(code, names);\n    const vm = new vm2_1.VM(options);\n    const script = new vm2_1.VMScript(`${compiled};${returnName}`, {\n      filename: options.filename\n    });\n    const fn = vm.run(script);\n\n    if (typeof fn !== 'function') {\n      throw new Error(`Expected a \"function\" to be returned for \\`${returnName}\\`, but got \"${typeof fn}\"`);\n    }\n\n    const r = function () {\n      try {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        const p = fn.apply(this, args);\n\n        if (typeof (p === null || p === void 0 ? void 0 : p.then) === 'function') {\n          return p;\n        }\n\n        return Promise.resolve(p);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    };\n\n    Object.defineProperty(r, 'toString', {\n      value: fn.toString.bind(fn),\n      enumerable: false\n    });\n    return r;\n  }\n\n  degenerator.compile = compile;\n})(degenerator || (degenerator = {}));\n/**\n * Returns `true` if `node` has a matching name to one of the entries in the\n * `names` array.\n *\n * @param {types.Node} node\n * @param {Array} names Array of function names to return true for\n * @return {Boolean}\n * @api private\n */\n\n\nfunction checkNames(_ref, names) {\n  let {\n    callee\n  } = _ref;\n  let name;\n\n  if (ast_types_1.namedTypes.Identifier.check(callee)) {\n    name = callee.name;\n  } else if (ast_types_1.namedTypes.MemberExpression.check(callee)) {\n    if (ast_types_1.namedTypes.Identifier.check(callee.object) && ast_types_1.namedTypes.Identifier.check(callee.property)) {\n      name = `${callee.object.name}.${callee.property.name}`;\n    } else {\n      return false;\n    }\n  } else if (ast_types_1.namedTypes.FunctionExpression.check(callee)) {\n    if (callee.id) {\n      name = callee.id.name;\n    } else {\n      return false;\n    }\n  } else {\n    throw new Error(`Don't know how to get name for: ${callee.type}`);\n  }\n\n  return checkName(name, names);\n}\n\nfunction checkName(name, names) {\n  // now that we have the `name`, check if any entries match in the `names` array\n  for (let i = 0; i < names.length; i++) {\n    const n = names[i];\n\n    if (util_1.isRegExp(n)) {\n      if (n.test(name)) {\n        return true;\n      }\n    } else if (name === n) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nmodule.exports = degenerator;","map":{"version":3,"mappings":"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","names":["degenerator","code","_names","Array","isArray","TypeError","names","slice","ast","esprima_1","lastNamesLength","length","ast_types_1","visitVariableDeclaration","path","node","declarations","i","declaration","VariableDeclarator","check","Identifier","init","id","checkName","name","push","visitAssignmentExpression","left","right","visitFunction","shouldDegenerate","visitCallExpression","checkNames","async","traverse","delegate","parent","pNode","expr","awaitExpression","CallExpression","arguments","escodegen_1","compile","returnName","options","compiled","vm","vm2_1","script","filename","fn","run","Error","r","args","p","apply","then","Promise","resolve","err","reject","Object","defineProperty","value","toString","bind","enumerable","callee","MemberExpression","object","property","FunctionExpression","type","n","util_1","test","module"],"sources":["../../src/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}