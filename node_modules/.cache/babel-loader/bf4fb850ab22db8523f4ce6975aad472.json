{"ast":null,"code":"\"use strict\";\n\n;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar types_1 = tslib_1.__importDefault(require(\"./types\"));\n\nvar node_path_1 = tslib_1.__importDefault(require(\"./node-path\"));\n\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction pathVisitorPlugin(fork) {\n  var types = fork.use(types_1.default);\n  var NodePath = fork.use(node_path_1.default);\n  var isArray = types.builtInTypes.array;\n  var isObject = types.builtInTypes.object;\n  var isFunction = types.builtInTypes.function;\n  var undefined;\n\n  var PathVisitor = function PathVisitor() {\n    if (!(this instanceof PathVisitor)) {\n      throw new Error(\"PathVisitor constructor cannot be invoked without 'new'\");\n    } // Permanent state.\n\n\n    this._reusableContextStack = [];\n    this._methodNameTable = computeMethodNameTable(this);\n    this._shouldVisitComments = hasOwn.call(this._methodNameTable, \"Block\") || hasOwn.call(this._methodNameTable, \"Line\");\n    this.Context = makeContextConstructor(this); // State reset every time PathVisitor.prototype.visit is called.\n\n    this._visiting = false;\n    this._changeReported = false;\n  };\n\n  function computeMethodNameTable(visitor) {\n    var typeNames = Object.create(null);\n\n    for (var methodName in visitor) {\n      if (/^visit[A-Z]/.test(methodName)) {\n        typeNames[methodName.slice(\"visit\".length)] = true;\n      }\n    }\n\n    var supertypeTable = types.computeSupertypeLookupTable(typeNames);\n    var methodNameTable = Object.create(null);\n    var typeNameKeys = Object.keys(supertypeTable);\n    var typeNameCount = typeNameKeys.length;\n\n    for (var i = 0; i < typeNameCount; ++i) {\n      var typeName = typeNameKeys[i];\n      methodName = \"visit\" + supertypeTable[typeName];\n\n      if (isFunction.check(visitor[methodName])) {\n        methodNameTable[typeName] = methodName;\n      }\n    }\n\n    return methodNameTable;\n  }\n\n  PathVisitor.fromMethodsObject = function fromMethodsObject(methods) {\n    if (methods instanceof PathVisitor) {\n      return methods;\n    }\n\n    if (!isObject.check(methods)) {\n      // An empty visitor?\n      return new PathVisitor();\n    }\n\n    var Visitor = function Visitor() {\n      if (!(this instanceof Visitor)) {\n        throw new Error(\"Visitor constructor cannot be invoked without 'new'\");\n      }\n\n      PathVisitor.call(this);\n    };\n\n    var Vp = Visitor.prototype = Object.create(PVp);\n    Vp.constructor = Visitor;\n    extend(Vp, methods);\n    extend(Visitor, PathVisitor);\n    isFunction.assert(Visitor.fromMethodsObject);\n    isFunction.assert(Visitor.visit);\n    return new Visitor();\n  };\n\n  function extend(target, source) {\n    for (var property in source) {\n      if (hasOwn.call(source, property)) {\n        target[property] = source[property];\n      }\n    }\n\n    return target;\n  }\n\n  PathVisitor.visit = function visit(node, methods) {\n    return PathVisitor.fromMethodsObject(methods).visit(node);\n  };\n\n  var PVp = PathVisitor.prototype;\n\n  PVp.visit = function () {\n    if (this._visiting) {\n      throw new Error(\"Recursively calling visitor.visit(path) resets visitor state. \" + \"Try this.visit(path) or this.traverse(path) instead.\");\n    } // Private state that needs to be reset before every traversal.\n\n\n    this._visiting = true;\n    this._changeReported = false;\n    this._abortRequested = false;\n    var argc = arguments.length;\n    var args = new Array(argc);\n\n    for (var i = 0; i < argc; ++i) {\n      args[i] = arguments[i];\n    }\n\n    if (!(args[0] instanceof NodePath)) {\n      args[0] = new NodePath({\n        root: args[0]\n      }).get(\"root\");\n    } // Called with the same arguments as .visit.\n\n\n    this.reset.apply(this, args);\n    var didNotThrow;\n\n    try {\n      var root = this.visitWithoutReset(args[0]);\n      didNotThrow = true;\n    } finally {\n      this._visiting = false;\n\n      if (!didNotThrow && this._abortRequested) {\n        // If this.visitWithoutReset threw an exception and\n        // this._abortRequested was set to true, return the root of\n        // the AST instead of letting the exception propagate, so that\n        // client code does not have to provide a try-catch block to\n        // intercept the AbortRequest exception.  Other kinds of\n        // exceptions will propagate without being intercepted and\n        // rethrown by a catch block, so their stacks will accurately\n        // reflect the original throwing context.\n        return args[0].value;\n      }\n    }\n\n    return root;\n  };\n\n  PVp.AbortRequest = function AbortRequest() {};\n\n  PVp.abort = function () {\n    var visitor = this;\n    visitor._abortRequested = true;\n    var request = new visitor.AbortRequest(); // If you decide to catch this exception and stop it from propagating,\n    // make sure to call its cancel method to avoid silencing other\n    // exceptions that might be thrown later in the traversal.\n\n    request.cancel = function () {\n      visitor._abortRequested = false;\n    };\n\n    throw request;\n  };\n\n  PVp.reset = function (_path\n  /*, additional arguments */\n  ) {// Empty stub; may be reassigned or overridden by subclasses.\n  };\n\n  PVp.visitWithoutReset = function (path) {\n    if (this instanceof this.Context) {\n      // Since this.Context.prototype === this, there's a chance we\n      // might accidentally call context.visitWithoutReset. If that\n      // happens, re-invoke the method against context.visitor.\n      return this.visitor.visitWithoutReset(path);\n    }\n\n    if (!(path instanceof NodePath)) {\n      throw new Error(\"\");\n    }\n\n    var value = path.value;\n    var methodName = value && typeof value === \"object\" && typeof value.type === \"string\" && this._methodNameTable[value.type];\n\n    if (methodName) {\n      var context = this.acquireContext(path);\n\n      try {\n        return context.invokeVisitorMethod(methodName);\n      } finally {\n        this.releaseContext(context);\n      }\n    } else {\n      // If there was no visitor method to call, visit the children of\n      // this node generically.\n      return visitChildren(path, this);\n    }\n  };\n\n  function visitChildren(path, visitor) {\n    if (!(path instanceof NodePath)) {\n      throw new Error(\"\");\n    }\n\n    if (!(visitor instanceof PathVisitor)) {\n      throw new Error(\"\");\n    }\n\n    var value = path.value;\n\n    if (isArray.check(value)) {\n      path.each(visitor.visitWithoutReset, visitor);\n    } else if (!isObject.check(value)) {// No children to visit.\n    } else {\n      var childNames = types.getFieldNames(value); // The .comments field of the Node type is hidden, so we only\n      // visit it if the visitor defines visitBlock or visitLine, and\n      // value.comments is defined.\n\n      if (visitor._shouldVisitComments && value.comments && childNames.indexOf(\"comments\") < 0) {\n        childNames.push(\"comments\");\n      }\n\n      var childCount = childNames.length;\n      var childPaths = [];\n\n      for (var i = 0; i < childCount; ++i) {\n        var childName = childNames[i];\n\n        if (!hasOwn.call(value, childName)) {\n          value[childName] = types.getFieldValue(value, childName);\n        }\n\n        childPaths.push(path.get(childName));\n      }\n\n      for (var i = 0; i < childCount; ++i) {\n        visitor.visitWithoutReset(childPaths[i]);\n      }\n    }\n\n    return path.value;\n  }\n\n  PVp.acquireContext = function (path) {\n    if (this._reusableContextStack.length === 0) {\n      return new this.Context(path);\n    }\n\n    return this._reusableContextStack.pop().reset(path);\n  };\n\n  PVp.releaseContext = function (context) {\n    if (!(context instanceof this.Context)) {\n      throw new Error(\"\");\n    }\n\n    this._reusableContextStack.push(context);\n\n    context.currentPath = null;\n  };\n\n  PVp.reportChanged = function () {\n    this._changeReported = true;\n  };\n\n  PVp.wasChangeReported = function () {\n    return this._changeReported;\n  };\n\n  function makeContextConstructor(visitor) {\n    function Context(path) {\n      if (!(this instanceof Context)) {\n        throw new Error(\"\");\n      }\n\n      if (!(this instanceof PathVisitor)) {\n        throw new Error(\"\");\n      }\n\n      if (!(path instanceof NodePath)) {\n        throw new Error(\"\");\n      }\n\n      Object.defineProperty(this, \"visitor\", {\n        value: visitor,\n        writable: false,\n        enumerable: true,\n        configurable: false\n      });\n      this.currentPath = path;\n      this.needToCallTraverse = true;\n      Object.seal(this);\n    }\n\n    if (!(visitor instanceof PathVisitor)) {\n      throw new Error(\"\");\n    } // Note that the visitor object is the prototype of Context.prototype,\n    // so all visitor methods are inherited by context objects.\n\n\n    var Cp = Context.prototype = Object.create(visitor);\n    Cp.constructor = Context;\n    extend(Cp, sharedContextProtoMethods);\n    return Context;\n  } // Every PathVisitor has a different this.Context constructor and\n  // this.Context.prototype object, but those prototypes can all use the\n  // same reset, invokeVisitorMethod, and traverse function objects.\n\n\n  var sharedContextProtoMethods = Object.create(null);\n\n  sharedContextProtoMethods.reset = function reset(path) {\n    if (!(this instanceof this.Context)) {\n      throw new Error(\"\");\n    }\n\n    if (!(path instanceof NodePath)) {\n      throw new Error(\"\");\n    }\n\n    this.currentPath = path;\n    this.needToCallTraverse = true;\n    return this;\n  };\n\n  sharedContextProtoMethods.invokeVisitorMethod = function invokeVisitorMethod(methodName) {\n    if (!(this instanceof this.Context)) {\n      throw new Error(\"\");\n    }\n\n    if (!(this.currentPath instanceof NodePath)) {\n      throw new Error(\"\");\n    }\n\n    var result = this.visitor[methodName].call(this, this.currentPath);\n\n    if (result === false) {\n      // Visitor methods return false to indicate that they have handled\n      // their own traversal needs, and we should not complain if\n      // this.needToCallTraverse is still true.\n      this.needToCallTraverse = false;\n    } else if (result !== undefined) {\n      // Any other non-undefined value returned from the visitor method\n      // is interpreted as a replacement value.\n      this.currentPath = this.currentPath.replace(result)[0];\n\n      if (this.needToCallTraverse) {\n        // If this.traverse still hasn't been called, visit the\n        // children of the replacement node.\n        this.traverse(this.currentPath);\n      }\n    }\n\n    if (this.needToCallTraverse !== false) {\n      throw new Error(\"Must either call this.traverse or return false in \" + methodName);\n    }\n\n    var path = this.currentPath;\n    return path && path.value;\n  };\n\n  sharedContextProtoMethods.traverse = function traverse(path, newVisitor) {\n    if (!(this instanceof this.Context)) {\n      throw new Error(\"\");\n    }\n\n    if (!(path instanceof NodePath)) {\n      throw new Error(\"\");\n    }\n\n    if (!(this.currentPath instanceof NodePath)) {\n      throw new Error(\"\");\n    }\n\n    this.needToCallTraverse = false;\n    return visitChildren(path, PathVisitor.fromMethodsObject(newVisitor || this.visitor));\n  };\n\n  sharedContextProtoMethods.visit = function visit(path, newVisitor) {\n    if (!(this instanceof this.Context)) {\n      throw new Error(\"\");\n    }\n\n    if (!(path instanceof NodePath)) {\n      throw new Error(\"\");\n    }\n\n    if (!(this.currentPath instanceof NodePath)) {\n      throw new Error(\"\");\n    }\n\n    this.needToCallTraverse = false;\n    return PathVisitor.fromMethodsObject(newVisitor || this.visitor).visitWithoutReset(path);\n  };\n\n  sharedContextProtoMethods.reportChanged = function reportChanged() {\n    this.visitor.reportChanged();\n  };\n\n  sharedContextProtoMethods.abort = function abort() {\n    this.needToCallTraverse = false;\n    this.visitor.abort();\n  };\n\n  return PathVisitor;\n}\n\nexports.default = pathVisitorPlugin;\nmodule.exports = exports[\"default\"];","map":{"version":3,"names":["Object","defineProperty","exports","value","tslib_1","require","types_1","__importDefault","node_path_1","hasOwn","prototype","hasOwnProperty","pathVisitorPlugin","fork","types","use","default","NodePath","isArray","builtInTypes","array","isObject","object","isFunction","function","undefined","PathVisitor","Error","_reusableContextStack","_methodNameTable","computeMethodNameTable","_shouldVisitComments","call","Context","makeContextConstructor","_visiting","_changeReported","visitor","typeNames","create","methodName","test","slice","length","supertypeTable","computeSupertypeLookupTable","methodNameTable","typeNameKeys","keys","typeNameCount","i","typeName","check","fromMethodsObject","methods","Visitor","Vp","PVp","constructor","extend","assert","visit","target","source","property","node","_abortRequested","argc","arguments","args","Array","root","get","reset","apply","didNotThrow","visitWithoutReset","AbortRequest","abort","request","cancel","_path","path","type","context","acquireContext","invokeVisitorMethod","releaseContext","visitChildren","each","childNames","getFieldNames","comments","indexOf","push","childCount","childPaths","childName","getFieldValue","pop","currentPath","reportChanged","wasChangeReported","writable","enumerable","configurable","needToCallTraverse","seal","Cp","sharedContextProtoMethods","result","replace","traverse","newVisitor","module"],"sources":["C:/Users/bryan/Desktop/myrepresentatives/frontend/node_modules/ast-types/lib/path-visitor.js"],"sourcesContent":["\"use strict\";;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar types_1 = tslib_1.__importDefault(require(\"./types\"));\nvar node_path_1 = tslib_1.__importDefault(require(\"./node-path\"));\nvar hasOwn = Object.prototype.hasOwnProperty;\nfunction pathVisitorPlugin(fork) {\n    var types = fork.use(types_1.default);\n    var NodePath = fork.use(node_path_1.default);\n    var isArray = types.builtInTypes.array;\n    var isObject = types.builtInTypes.object;\n    var isFunction = types.builtInTypes.function;\n    var undefined;\n    var PathVisitor = function PathVisitor() {\n        if (!(this instanceof PathVisitor)) {\n            throw new Error(\"PathVisitor constructor cannot be invoked without 'new'\");\n        }\n        // Permanent state.\n        this._reusableContextStack = [];\n        this._methodNameTable = computeMethodNameTable(this);\n        this._shouldVisitComments =\n            hasOwn.call(this._methodNameTable, \"Block\") ||\n                hasOwn.call(this._methodNameTable, \"Line\");\n        this.Context = makeContextConstructor(this);\n        // State reset every time PathVisitor.prototype.visit is called.\n        this._visiting = false;\n        this._changeReported = false;\n    };\n    function computeMethodNameTable(visitor) {\n        var typeNames = Object.create(null);\n        for (var methodName in visitor) {\n            if (/^visit[A-Z]/.test(methodName)) {\n                typeNames[methodName.slice(\"visit\".length)] = true;\n            }\n        }\n        var supertypeTable = types.computeSupertypeLookupTable(typeNames);\n        var methodNameTable = Object.create(null);\n        var typeNameKeys = Object.keys(supertypeTable);\n        var typeNameCount = typeNameKeys.length;\n        for (var i = 0; i < typeNameCount; ++i) {\n            var typeName = typeNameKeys[i];\n            methodName = \"visit\" + supertypeTable[typeName];\n            if (isFunction.check(visitor[methodName])) {\n                methodNameTable[typeName] = methodName;\n            }\n        }\n        return methodNameTable;\n    }\n    PathVisitor.fromMethodsObject = function fromMethodsObject(methods) {\n        if (methods instanceof PathVisitor) {\n            return methods;\n        }\n        if (!isObject.check(methods)) {\n            // An empty visitor?\n            return new PathVisitor;\n        }\n        var Visitor = function Visitor() {\n            if (!(this instanceof Visitor)) {\n                throw new Error(\"Visitor constructor cannot be invoked without 'new'\");\n            }\n            PathVisitor.call(this);\n        };\n        var Vp = Visitor.prototype = Object.create(PVp);\n        Vp.constructor = Visitor;\n        extend(Vp, methods);\n        extend(Visitor, PathVisitor);\n        isFunction.assert(Visitor.fromMethodsObject);\n        isFunction.assert(Visitor.visit);\n        return new Visitor;\n    };\n    function extend(target, source) {\n        for (var property in source) {\n            if (hasOwn.call(source, property)) {\n                target[property] = source[property];\n            }\n        }\n        return target;\n    }\n    PathVisitor.visit = function visit(node, methods) {\n        return PathVisitor.fromMethodsObject(methods).visit(node);\n    };\n    var PVp = PathVisitor.prototype;\n    PVp.visit = function () {\n        if (this._visiting) {\n            throw new Error(\"Recursively calling visitor.visit(path) resets visitor state. \" +\n                \"Try this.visit(path) or this.traverse(path) instead.\");\n        }\n        // Private state that needs to be reset before every traversal.\n        this._visiting = true;\n        this._changeReported = false;\n        this._abortRequested = false;\n        var argc = arguments.length;\n        var args = new Array(argc);\n        for (var i = 0; i < argc; ++i) {\n            args[i] = arguments[i];\n        }\n        if (!(args[0] instanceof NodePath)) {\n            args[0] = new NodePath({ root: args[0] }).get(\"root\");\n        }\n        // Called with the same arguments as .visit.\n        this.reset.apply(this, args);\n        var didNotThrow;\n        try {\n            var root = this.visitWithoutReset(args[0]);\n            didNotThrow = true;\n        }\n        finally {\n            this._visiting = false;\n            if (!didNotThrow && this._abortRequested) {\n                // If this.visitWithoutReset threw an exception and\n                // this._abortRequested was set to true, return the root of\n                // the AST instead of letting the exception propagate, so that\n                // client code does not have to provide a try-catch block to\n                // intercept the AbortRequest exception.  Other kinds of\n                // exceptions will propagate without being intercepted and\n                // rethrown by a catch block, so their stacks will accurately\n                // reflect the original throwing context.\n                return args[0].value;\n            }\n        }\n        return root;\n    };\n    PVp.AbortRequest = function AbortRequest() { };\n    PVp.abort = function () {\n        var visitor = this;\n        visitor._abortRequested = true;\n        var request = new visitor.AbortRequest();\n        // If you decide to catch this exception and stop it from propagating,\n        // make sure to call its cancel method to avoid silencing other\n        // exceptions that might be thrown later in the traversal.\n        request.cancel = function () {\n            visitor._abortRequested = false;\n        };\n        throw request;\n    };\n    PVp.reset = function (_path /*, additional arguments */) {\n        // Empty stub; may be reassigned or overridden by subclasses.\n    };\n    PVp.visitWithoutReset = function (path) {\n        if (this instanceof this.Context) {\n            // Since this.Context.prototype === this, there's a chance we\n            // might accidentally call context.visitWithoutReset. If that\n            // happens, re-invoke the method against context.visitor.\n            return this.visitor.visitWithoutReset(path);\n        }\n        if (!(path instanceof NodePath)) {\n            throw new Error(\"\");\n        }\n        var value = path.value;\n        var methodName = value &&\n            typeof value === \"object\" &&\n            typeof value.type === \"string\" &&\n            this._methodNameTable[value.type];\n        if (methodName) {\n            var context = this.acquireContext(path);\n            try {\n                return context.invokeVisitorMethod(methodName);\n            }\n            finally {\n                this.releaseContext(context);\n            }\n        }\n        else {\n            // If there was no visitor method to call, visit the children of\n            // this node generically.\n            return visitChildren(path, this);\n        }\n    };\n    function visitChildren(path, visitor) {\n        if (!(path instanceof NodePath)) {\n            throw new Error(\"\");\n        }\n        if (!(visitor instanceof PathVisitor)) {\n            throw new Error(\"\");\n        }\n        var value = path.value;\n        if (isArray.check(value)) {\n            path.each(visitor.visitWithoutReset, visitor);\n        }\n        else if (!isObject.check(value)) {\n            // No children to visit.\n        }\n        else {\n            var childNames = types.getFieldNames(value);\n            // The .comments field of the Node type is hidden, so we only\n            // visit it if the visitor defines visitBlock or visitLine, and\n            // value.comments is defined.\n            if (visitor._shouldVisitComments &&\n                value.comments &&\n                childNames.indexOf(\"comments\") < 0) {\n                childNames.push(\"comments\");\n            }\n            var childCount = childNames.length;\n            var childPaths = [];\n            for (var i = 0; i < childCount; ++i) {\n                var childName = childNames[i];\n                if (!hasOwn.call(value, childName)) {\n                    value[childName] = types.getFieldValue(value, childName);\n                }\n                childPaths.push(path.get(childName));\n            }\n            for (var i = 0; i < childCount; ++i) {\n                visitor.visitWithoutReset(childPaths[i]);\n            }\n        }\n        return path.value;\n    }\n    PVp.acquireContext = function (path) {\n        if (this._reusableContextStack.length === 0) {\n            return new this.Context(path);\n        }\n        return this._reusableContextStack.pop().reset(path);\n    };\n    PVp.releaseContext = function (context) {\n        if (!(context instanceof this.Context)) {\n            throw new Error(\"\");\n        }\n        this._reusableContextStack.push(context);\n        context.currentPath = null;\n    };\n    PVp.reportChanged = function () {\n        this._changeReported = true;\n    };\n    PVp.wasChangeReported = function () {\n        return this._changeReported;\n    };\n    function makeContextConstructor(visitor) {\n        function Context(path) {\n            if (!(this instanceof Context)) {\n                throw new Error(\"\");\n            }\n            if (!(this instanceof PathVisitor)) {\n                throw new Error(\"\");\n            }\n            if (!(path instanceof NodePath)) {\n                throw new Error(\"\");\n            }\n            Object.defineProperty(this, \"visitor\", {\n                value: visitor,\n                writable: false,\n                enumerable: true,\n                configurable: false\n            });\n            this.currentPath = path;\n            this.needToCallTraverse = true;\n            Object.seal(this);\n        }\n        if (!(visitor instanceof PathVisitor)) {\n            throw new Error(\"\");\n        }\n        // Note that the visitor object is the prototype of Context.prototype,\n        // so all visitor methods are inherited by context objects.\n        var Cp = Context.prototype = Object.create(visitor);\n        Cp.constructor = Context;\n        extend(Cp, sharedContextProtoMethods);\n        return Context;\n    }\n    // Every PathVisitor has a different this.Context constructor and\n    // this.Context.prototype object, but those prototypes can all use the\n    // same reset, invokeVisitorMethod, and traverse function objects.\n    var sharedContextProtoMethods = Object.create(null);\n    sharedContextProtoMethods.reset =\n        function reset(path) {\n            if (!(this instanceof this.Context)) {\n                throw new Error(\"\");\n            }\n            if (!(path instanceof NodePath)) {\n                throw new Error(\"\");\n            }\n            this.currentPath = path;\n            this.needToCallTraverse = true;\n            return this;\n        };\n    sharedContextProtoMethods.invokeVisitorMethod =\n        function invokeVisitorMethod(methodName) {\n            if (!(this instanceof this.Context)) {\n                throw new Error(\"\");\n            }\n            if (!(this.currentPath instanceof NodePath)) {\n                throw new Error(\"\");\n            }\n            var result = this.visitor[methodName].call(this, this.currentPath);\n            if (result === false) {\n                // Visitor methods return false to indicate that they have handled\n                // their own traversal needs, and we should not complain if\n                // this.needToCallTraverse is still true.\n                this.needToCallTraverse = false;\n            }\n            else if (result !== undefined) {\n                // Any other non-undefined value returned from the visitor method\n                // is interpreted as a replacement value.\n                this.currentPath = this.currentPath.replace(result)[0];\n                if (this.needToCallTraverse) {\n                    // If this.traverse still hasn't been called, visit the\n                    // children of the replacement node.\n                    this.traverse(this.currentPath);\n                }\n            }\n            if (this.needToCallTraverse !== false) {\n                throw new Error(\"Must either call this.traverse or return false in \" + methodName);\n            }\n            var path = this.currentPath;\n            return path && path.value;\n        };\n    sharedContextProtoMethods.traverse =\n        function traverse(path, newVisitor) {\n            if (!(this instanceof this.Context)) {\n                throw new Error(\"\");\n            }\n            if (!(path instanceof NodePath)) {\n                throw new Error(\"\");\n            }\n            if (!(this.currentPath instanceof NodePath)) {\n                throw new Error(\"\");\n            }\n            this.needToCallTraverse = false;\n            return visitChildren(path, PathVisitor.fromMethodsObject(newVisitor || this.visitor));\n        };\n    sharedContextProtoMethods.visit =\n        function visit(path, newVisitor) {\n            if (!(this instanceof this.Context)) {\n                throw new Error(\"\");\n            }\n            if (!(path instanceof NodePath)) {\n                throw new Error(\"\");\n            }\n            if (!(this.currentPath instanceof NodePath)) {\n                throw new Error(\"\");\n            }\n            this.needToCallTraverse = false;\n            return PathVisitor.fromMethodsObject(newVisitor || this.visitor).visitWithoutReset(path);\n        };\n    sharedContextProtoMethods.reportChanged = function reportChanged() {\n        this.visitor.reportChanged();\n    };\n    sharedContextProtoMethods.abort = function abort() {\n        this.needToCallTraverse = false;\n        this.visitor.abort();\n    };\n    return PathVisitor;\n}\nexports.default = pathVisitorPlugin;\nmodule.exports = exports[\"default\"];\n"],"mappings":"AAAA;;AAAa;AACbA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAAEC,KAAK,EAAE;AAAT,CAA7C;;AACA,IAAIC,OAAO,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,IAAIC,OAAO,GAAGF,OAAO,CAACG,eAAR,CAAwBF,OAAO,CAAC,SAAD,CAA/B,CAAd;;AACA,IAAIG,WAAW,GAAGJ,OAAO,CAACG,eAAR,CAAwBF,OAAO,CAAC,aAAD,CAA/B,CAAlB;;AACA,IAAII,MAAM,GAAGT,MAAM,CAACU,SAAP,CAAiBC,cAA9B;;AACA,SAASC,iBAAT,CAA2BC,IAA3B,EAAiC;EAC7B,IAAIC,KAAK,GAAGD,IAAI,CAACE,GAAL,CAAST,OAAO,CAACU,OAAjB,CAAZ;EACA,IAAIC,QAAQ,GAAGJ,IAAI,CAACE,GAAL,CAASP,WAAW,CAACQ,OAArB,CAAf;EACA,IAAIE,OAAO,GAAGJ,KAAK,CAACK,YAAN,CAAmBC,KAAjC;EACA,IAAIC,QAAQ,GAAGP,KAAK,CAACK,YAAN,CAAmBG,MAAlC;EACA,IAAIC,UAAU,GAAGT,KAAK,CAACK,YAAN,CAAmBK,QAApC;EACA,IAAIC,SAAJ;;EACA,IAAIC,WAAW,GAAG,SAASA,WAAT,GAAuB;IACrC,IAAI,EAAE,gBAAgBA,WAAlB,CAAJ,EAAoC;MAChC,MAAM,IAAIC,KAAJ,CAAU,yDAAV,CAAN;IACH,CAHoC,CAIrC;;;IACA,KAAKC,qBAAL,GAA6B,EAA7B;IACA,KAAKC,gBAAL,GAAwBC,sBAAsB,CAAC,IAAD,CAA9C;IACA,KAAKC,oBAAL,GACItB,MAAM,CAACuB,IAAP,CAAY,KAAKH,gBAAjB,EAAmC,OAAnC,KACIpB,MAAM,CAACuB,IAAP,CAAY,KAAKH,gBAAjB,EAAmC,MAAnC,CAFR;IAGA,KAAKI,OAAL,GAAeC,sBAAsB,CAAC,IAAD,CAArC,CAVqC,CAWrC;;IACA,KAAKC,SAAL,GAAiB,KAAjB;IACA,KAAKC,eAAL,GAAuB,KAAvB;EACH,CAdD;;EAeA,SAASN,sBAAT,CAAgCO,OAAhC,EAAyC;IACrC,IAAIC,SAAS,GAAGtC,MAAM,CAACuC,MAAP,CAAc,IAAd,CAAhB;;IACA,KAAK,IAAIC,UAAT,IAAuBH,OAAvB,EAAgC;MAC5B,IAAI,cAAcI,IAAd,CAAmBD,UAAnB,CAAJ,EAAoC;QAChCF,SAAS,CAACE,UAAU,CAACE,KAAX,CAAiB,QAAQC,MAAzB,CAAD,CAAT,GAA8C,IAA9C;MACH;IACJ;;IACD,IAAIC,cAAc,GAAG9B,KAAK,CAAC+B,2BAAN,CAAkCP,SAAlC,CAArB;IACA,IAAIQ,eAAe,GAAG9C,MAAM,CAACuC,MAAP,CAAc,IAAd,CAAtB;IACA,IAAIQ,YAAY,GAAG/C,MAAM,CAACgD,IAAP,CAAYJ,cAAZ,CAAnB;IACA,IAAIK,aAAa,GAAGF,YAAY,CAACJ,MAAjC;;IACA,KAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,aAApB,EAAmC,EAAEC,CAArC,EAAwC;MACpC,IAAIC,QAAQ,GAAGJ,YAAY,CAACG,CAAD,CAA3B;MACAV,UAAU,GAAG,UAAUI,cAAc,CAACO,QAAD,CAArC;;MACA,IAAI5B,UAAU,CAAC6B,KAAX,CAAiBf,OAAO,CAACG,UAAD,CAAxB,CAAJ,EAA2C;QACvCM,eAAe,CAACK,QAAD,CAAf,GAA4BX,UAA5B;MACH;IACJ;;IACD,OAAOM,eAAP;EACH;;EACDpB,WAAW,CAAC2B,iBAAZ,GAAgC,SAASA,iBAAT,CAA2BC,OAA3B,EAAoC;IAChE,IAAIA,OAAO,YAAY5B,WAAvB,EAAoC;MAChC,OAAO4B,OAAP;IACH;;IACD,IAAI,CAACjC,QAAQ,CAAC+B,KAAT,CAAeE,OAAf,CAAL,EAA8B;MAC1B;MACA,OAAO,IAAI5B,WAAJ,EAAP;IACH;;IACD,IAAI6B,OAAO,GAAG,SAASA,OAAT,GAAmB;MAC7B,IAAI,EAAE,gBAAgBA,OAAlB,CAAJ,EAAgC;QAC5B,MAAM,IAAI5B,KAAJ,CAAU,qDAAV,CAAN;MACH;;MACDD,WAAW,CAACM,IAAZ,CAAiB,IAAjB;IACH,CALD;;IAMA,IAAIwB,EAAE,GAAGD,OAAO,CAAC7C,SAAR,GAAoBV,MAAM,CAACuC,MAAP,CAAckB,GAAd,CAA7B;IACAD,EAAE,CAACE,WAAH,GAAiBH,OAAjB;IACAI,MAAM,CAACH,EAAD,EAAKF,OAAL,CAAN;IACAK,MAAM,CAACJ,OAAD,EAAU7B,WAAV,CAAN;IACAH,UAAU,CAACqC,MAAX,CAAkBL,OAAO,CAACF,iBAA1B;IACA9B,UAAU,CAACqC,MAAX,CAAkBL,OAAO,CAACM,KAA1B;IACA,OAAO,IAAIN,OAAJ,EAAP;EACH,CArBD;;EAsBA,SAASI,MAAT,CAAgBG,MAAhB,EAAwBC,MAAxB,EAAgC;IAC5B,KAAK,IAAIC,QAAT,IAAqBD,MAArB,EAA6B;MACzB,IAAItD,MAAM,CAACuB,IAAP,CAAY+B,MAAZ,EAAoBC,QAApB,CAAJ,EAAmC;QAC/BF,MAAM,CAACE,QAAD,CAAN,GAAmBD,MAAM,CAACC,QAAD,CAAzB;MACH;IACJ;;IACD,OAAOF,MAAP;EACH;;EACDpC,WAAW,CAACmC,KAAZ,GAAoB,SAASA,KAAT,CAAeI,IAAf,EAAqBX,OAArB,EAA8B;IAC9C,OAAO5B,WAAW,CAAC2B,iBAAZ,CAA8BC,OAA9B,EAAuCO,KAAvC,CAA6CI,IAA7C,CAAP;EACH,CAFD;;EAGA,IAAIR,GAAG,GAAG/B,WAAW,CAAChB,SAAtB;;EACA+C,GAAG,CAACI,KAAJ,GAAY,YAAY;IACpB,IAAI,KAAK1B,SAAT,EAAoB;MAChB,MAAM,IAAIR,KAAJ,CAAU,mEACZ,sDADE,CAAN;IAEH,CAJmB,CAKpB;;;IACA,KAAKQ,SAAL,GAAiB,IAAjB;IACA,KAAKC,eAAL,GAAuB,KAAvB;IACA,KAAK8B,eAAL,GAAuB,KAAvB;IACA,IAAIC,IAAI,GAAGC,SAAS,CAACzB,MAArB;IACA,IAAI0B,IAAI,GAAG,IAAIC,KAAJ,CAAUH,IAAV,CAAX;;IACA,KAAK,IAAIjB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiB,IAApB,EAA0B,EAAEjB,CAA5B,EAA+B;MAC3BmB,IAAI,CAACnB,CAAD,CAAJ,GAAUkB,SAAS,CAAClB,CAAD,CAAnB;IACH;;IACD,IAAI,EAAEmB,IAAI,CAAC,CAAD,CAAJ,YAAmBpD,QAArB,CAAJ,EAAoC;MAChCoD,IAAI,CAAC,CAAD,CAAJ,GAAU,IAAIpD,QAAJ,CAAa;QAAEsD,IAAI,EAAEF,IAAI,CAAC,CAAD;MAAZ,CAAb,EAAgCG,GAAhC,CAAoC,MAApC,CAAV;IACH,CAhBmB,CAiBpB;;;IACA,KAAKC,KAAL,CAAWC,KAAX,CAAiB,IAAjB,EAAuBL,IAAvB;IACA,IAAIM,WAAJ;;IACA,IAAI;MACA,IAAIJ,IAAI,GAAG,KAAKK,iBAAL,CAAuBP,IAAI,CAAC,CAAD,CAA3B,CAAX;MACAM,WAAW,GAAG,IAAd;IACH,CAHD,SAIQ;MACJ,KAAKxC,SAAL,GAAiB,KAAjB;;MACA,IAAI,CAACwC,WAAD,IAAgB,KAAKT,eAAzB,EAA0C;QACtC;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,OAAOG,IAAI,CAAC,CAAD,CAAJ,CAAQlE,KAAf;MACH;IACJ;;IACD,OAAOoE,IAAP;EACH,CAvCD;;EAwCAd,GAAG,CAACoB,YAAJ,GAAmB,SAASA,YAAT,GAAwB,CAAG,CAA9C;;EACApB,GAAG,CAACqB,KAAJ,GAAY,YAAY;IACpB,IAAIzC,OAAO,GAAG,IAAd;IACAA,OAAO,CAAC6B,eAAR,GAA0B,IAA1B;IACA,IAAIa,OAAO,GAAG,IAAI1C,OAAO,CAACwC,YAAZ,EAAd,CAHoB,CAIpB;IACA;IACA;;IACAE,OAAO,CAACC,MAAR,GAAiB,YAAY;MACzB3C,OAAO,CAAC6B,eAAR,GAA0B,KAA1B;IACH,CAFD;;IAGA,MAAMa,OAAN;EACH,CAXD;;EAYAtB,GAAG,CAACgB,KAAJ,GAAY,UAAUQ;EAAM;EAAhB,EAA6C,CACrD;EACH,CAFD;;EAGAxB,GAAG,CAACmB,iBAAJ,GAAwB,UAAUM,IAAV,EAAgB;IACpC,IAAI,gBAAgB,KAAKjD,OAAzB,EAAkC;MAC9B;MACA;MACA;MACA,OAAO,KAAKI,OAAL,CAAauC,iBAAb,CAA+BM,IAA/B,CAAP;IACH;;IACD,IAAI,EAAEA,IAAI,YAAYjE,QAAlB,CAAJ,EAAiC;MAC7B,MAAM,IAAIU,KAAJ,CAAU,EAAV,CAAN;IACH;;IACD,IAAIxB,KAAK,GAAG+E,IAAI,CAAC/E,KAAjB;IACA,IAAIqC,UAAU,GAAGrC,KAAK,IAClB,OAAOA,KAAP,KAAiB,QADJ,IAEb,OAAOA,KAAK,CAACgF,IAAb,KAAsB,QAFT,IAGb,KAAKtD,gBAAL,CAAsB1B,KAAK,CAACgF,IAA5B,CAHJ;;IAIA,IAAI3C,UAAJ,EAAgB;MACZ,IAAI4C,OAAO,GAAG,KAAKC,cAAL,CAAoBH,IAApB,CAAd;;MACA,IAAI;QACA,OAAOE,OAAO,CAACE,mBAAR,CAA4B9C,UAA5B,CAAP;MACH,CAFD,SAGQ;QACJ,KAAK+C,cAAL,CAAoBH,OAApB;MACH;IACJ,CARD,MASK;MACD;MACA;MACA,OAAOI,aAAa,CAACN,IAAD,EAAO,IAAP,CAApB;IACH;EACJ,CA7BD;;EA8BA,SAASM,aAAT,CAAuBN,IAAvB,EAA6B7C,OAA7B,EAAsC;IAClC,IAAI,EAAE6C,IAAI,YAAYjE,QAAlB,CAAJ,EAAiC;MAC7B,MAAM,IAAIU,KAAJ,CAAU,EAAV,CAAN;IACH;;IACD,IAAI,EAAEU,OAAO,YAAYX,WAArB,CAAJ,EAAuC;MACnC,MAAM,IAAIC,KAAJ,CAAU,EAAV,CAAN;IACH;;IACD,IAAIxB,KAAK,GAAG+E,IAAI,CAAC/E,KAAjB;;IACA,IAAIe,OAAO,CAACkC,KAAR,CAAcjD,KAAd,CAAJ,EAA0B;MACtB+E,IAAI,CAACO,IAAL,CAAUpD,OAAO,CAACuC,iBAAlB,EAAqCvC,OAArC;IACH,CAFD,MAGK,IAAI,CAAChB,QAAQ,CAAC+B,KAAT,CAAejD,KAAf,CAAL,EAA4B,CAC7B;IACH,CAFI,MAGA;MACD,IAAIuF,UAAU,GAAG5E,KAAK,CAAC6E,aAAN,CAAoBxF,KAApB,CAAjB,CADC,CAED;MACA;MACA;;MACA,IAAIkC,OAAO,CAACN,oBAAR,IACA5B,KAAK,CAACyF,QADN,IAEAF,UAAU,CAACG,OAAX,CAAmB,UAAnB,IAAiC,CAFrC,EAEwC;QACpCH,UAAU,CAACI,IAAX,CAAgB,UAAhB;MACH;;MACD,IAAIC,UAAU,GAAGL,UAAU,CAAC/C,MAA5B;MACA,IAAIqD,UAAU,GAAG,EAAjB;;MACA,KAAK,IAAI9C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG6C,UAApB,EAAgC,EAAE7C,CAAlC,EAAqC;QACjC,IAAI+C,SAAS,GAAGP,UAAU,CAACxC,CAAD,CAA1B;;QACA,IAAI,CAACzC,MAAM,CAACuB,IAAP,CAAY7B,KAAZ,EAAmB8F,SAAnB,CAAL,EAAoC;UAChC9F,KAAK,CAAC8F,SAAD,CAAL,GAAmBnF,KAAK,CAACoF,aAAN,CAAoB/F,KAApB,EAA2B8F,SAA3B,CAAnB;QACH;;QACDD,UAAU,CAACF,IAAX,CAAgBZ,IAAI,CAACV,GAAL,CAASyB,SAAT,CAAhB;MACH;;MACD,KAAK,IAAI/C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG6C,UAApB,EAAgC,EAAE7C,CAAlC,EAAqC;QACjCb,OAAO,CAACuC,iBAAR,CAA0BoB,UAAU,CAAC9C,CAAD,CAApC;MACH;IACJ;;IACD,OAAOgC,IAAI,CAAC/E,KAAZ;EACH;;EACDsD,GAAG,CAAC4B,cAAJ,GAAqB,UAAUH,IAAV,EAAgB;IACjC,IAAI,KAAKtD,qBAAL,CAA2Be,MAA3B,KAAsC,CAA1C,EAA6C;MACzC,OAAO,IAAI,KAAKV,OAAT,CAAiBiD,IAAjB,CAAP;IACH;;IACD,OAAO,KAAKtD,qBAAL,CAA2BuE,GAA3B,GAAiC1B,KAAjC,CAAuCS,IAAvC,CAAP;EACH,CALD;;EAMAzB,GAAG,CAAC8B,cAAJ,GAAqB,UAAUH,OAAV,EAAmB;IACpC,IAAI,EAAEA,OAAO,YAAY,KAAKnD,OAA1B,CAAJ,EAAwC;MACpC,MAAM,IAAIN,KAAJ,CAAU,EAAV,CAAN;IACH;;IACD,KAAKC,qBAAL,CAA2BkE,IAA3B,CAAgCV,OAAhC;;IACAA,OAAO,CAACgB,WAAR,GAAsB,IAAtB;EACH,CAND;;EAOA3C,GAAG,CAAC4C,aAAJ,GAAoB,YAAY;IAC5B,KAAKjE,eAAL,GAAuB,IAAvB;EACH,CAFD;;EAGAqB,GAAG,CAAC6C,iBAAJ,GAAwB,YAAY;IAChC,OAAO,KAAKlE,eAAZ;EACH,CAFD;;EAGA,SAASF,sBAAT,CAAgCG,OAAhC,EAAyC;IACrC,SAASJ,OAAT,CAAiBiD,IAAjB,EAAuB;MACnB,IAAI,EAAE,gBAAgBjD,OAAlB,CAAJ,EAAgC;QAC5B,MAAM,IAAIN,KAAJ,CAAU,EAAV,CAAN;MACH;;MACD,IAAI,EAAE,gBAAgBD,WAAlB,CAAJ,EAAoC;QAChC,MAAM,IAAIC,KAAJ,CAAU,EAAV,CAAN;MACH;;MACD,IAAI,EAAEuD,IAAI,YAAYjE,QAAlB,CAAJ,EAAiC;QAC7B,MAAM,IAAIU,KAAJ,CAAU,EAAV,CAAN;MACH;;MACD3B,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,SAA5B,EAAuC;QACnCE,KAAK,EAAEkC,OAD4B;QAEnCkE,QAAQ,EAAE,KAFyB;QAGnCC,UAAU,EAAE,IAHuB;QAInCC,YAAY,EAAE;MAJqB,CAAvC;MAMA,KAAKL,WAAL,GAAmBlB,IAAnB;MACA,KAAKwB,kBAAL,GAA0B,IAA1B;MACA1G,MAAM,CAAC2G,IAAP,CAAY,IAAZ;IACH;;IACD,IAAI,EAAEtE,OAAO,YAAYX,WAArB,CAAJ,EAAuC;MACnC,MAAM,IAAIC,KAAJ,CAAU,EAAV,CAAN;IACH,CAvBoC,CAwBrC;IACA;;;IACA,IAAIiF,EAAE,GAAG3E,OAAO,CAACvB,SAAR,GAAoBV,MAAM,CAACuC,MAAP,CAAcF,OAAd,CAA7B;IACAuE,EAAE,CAAClD,WAAH,GAAiBzB,OAAjB;IACA0B,MAAM,CAACiD,EAAD,EAAKC,yBAAL,CAAN;IACA,OAAO5E,OAAP;EACH,CA1P4B,CA2P7B;EACA;EACA;;;EACA,IAAI4E,yBAAyB,GAAG7G,MAAM,CAACuC,MAAP,CAAc,IAAd,CAAhC;;EACAsE,yBAAyB,CAACpC,KAA1B,GACI,SAASA,KAAT,CAAeS,IAAf,EAAqB;IACjB,IAAI,EAAE,gBAAgB,KAAKjD,OAAvB,CAAJ,EAAqC;MACjC,MAAM,IAAIN,KAAJ,CAAU,EAAV,CAAN;IACH;;IACD,IAAI,EAAEuD,IAAI,YAAYjE,QAAlB,CAAJ,EAAiC;MAC7B,MAAM,IAAIU,KAAJ,CAAU,EAAV,CAAN;IACH;;IACD,KAAKyE,WAAL,GAAmBlB,IAAnB;IACA,KAAKwB,kBAAL,GAA0B,IAA1B;IACA,OAAO,IAAP;EACH,CAXL;;EAYAG,yBAAyB,CAACvB,mBAA1B,GACI,SAASA,mBAAT,CAA6B9C,UAA7B,EAAyC;IACrC,IAAI,EAAE,gBAAgB,KAAKP,OAAvB,CAAJ,EAAqC;MACjC,MAAM,IAAIN,KAAJ,CAAU,EAAV,CAAN;IACH;;IACD,IAAI,EAAE,KAAKyE,WAAL,YAA4BnF,QAA9B,CAAJ,EAA6C;MACzC,MAAM,IAAIU,KAAJ,CAAU,EAAV,CAAN;IACH;;IACD,IAAImF,MAAM,GAAG,KAAKzE,OAAL,CAAaG,UAAb,EAAyBR,IAAzB,CAA8B,IAA9B,EAAoC,KAAKoE,WAAzC,CAAb;;IACA,IAAIU,MAAM,KAAK,KAAf,EAAsB;MAClB;MACA;MACA;MACA,KAAKJ,kBAAL,GAA0B,KAA1B;IACH,CALD,MAMK,IAAII,MAAM,KAAKrF,SAAf,EAA0B;MAC3B;MACA;MACA,KAAK2E,WAAL,GAAmB,KAAKA,WAAL,CAAiBW,OAAjB,CAAyBD,MAAzB,EAAiC,CAAjC,CAAnB;;MACA,IAAI,KAAKJ,kBAAT,EAA6B;QACzB;QACA;QACA,KAAKM,QAAL,CAAc,KAAKZ,WAAnB;MACH;IACJ;;IACD,IAAI,KAAKM,kBAAL,KAA4B,KAAhC,EAAuC;MACnC,MAAM,IAAI/E,KAAJ,CAAU,uDAAuDa,UAAjE,CAAN;IACH;;IACD,IAAI0C,IAAI,GAAG,KAAKkB,WAAhB;IACA,OAAOlB,IAAI,IAAIA,IAAI,CAAC/E,KAApB;EACH,CA9BL;;EA+BA0G,yBAAyB,CAACG,QAA1B,GACI,SAASA,QAAT,CAAkB9B,IAAlB,EAAwB+B,UAAxB,EAAoC;IAChC,IAAI,EAAE,gBAAgB,KAAKhF,OAAvB,CAAJ,EAAqC;MACjC,MAAM,IAAIN,KAAJ,CAAU,EAAV,CAAN;IACH;;IACD,IAAI,EAAEuD,IAAI,YAAYjE,QAAlB,CAAJ,EAAiC;MAC7B,MAAM,IAAIU,KAAJ,CAAU,EAAV,CAAN;IACH;;IACD,IAAI,EAAE,KAAKyE,WAAL,YAA4BnF,QAA9B,CAAJ,EAA6C;MACzC,MAAM,IAAIU,KAAJ,CAAU,EAAV,CAAN;IACH;;IACD,KAAK+E,kBAAL,GAA0B,KAA1B;IACA,OAAOlB,aAAa,CAACN,IAAD,EAAOxD,WAAW,CAAC2B,iBAAZ,CAA8B4D,UAAU,IAAI,KAAK5E,OAAjD,CAAP,CAApB;EACH,CAbL;;EAcAwE,yBAAyB,CAAChD,KAA1B,GACI,SAASA,KAAT,CAAeqB,IAAf,EAAqB+B,UAArB,EAAiC;IAC7B,IAAI,EAAE,gBAAgB,KAAKhF,OAAvB,CAAJ,EAAqC;MACjC,MAAM,IAAIN,KAAJ,CAAU,EAAV,CAAN;IACH;;IACD,IAAI,EAAEuD,IAAI,YAAYjE,QAAlB,CAAJ,EAAiC;MAC7B,MAAM,IAAIU,KAAJ,CAAU,EAAV,CAAN;IACH;;IACD,IAAI,EAAE,KAAKyE,WAAL,YAA4BnF,QAA9B,CAAJ,EAA6C;MACzC,MAAM,IAAIU,KAAJ,CAAU,EAAV,CAAN;IACH;;IACD,KAAK+E,kBAAL,GAA0B,KAA1B;IACA,OAAOhF,WAAW,CAAC2B,iBAAZ,CAA8B4D,UAAU,IAAI,KAAK5E,OAAjD,EAA0DuC,iBAA1D,CAA4EM,IAA5E,CAAP;EACH,CAbL;;EAcA2B,yBAAyB,CAACR,aAA1B,GAA0C,SAASA,aAAT,GAAyB;IAC/D,KAAKhE,OAAL,CAAagE,aAAb;EACH,CAFD;;EAGAQ,yBAAyB,CAAC/B,KAA1B,GAAkC,SAASA,KAAT,GAAiB;IAC/C,KAAK4B,kBAAL,GAA0B,KAA1B;IACA,KAAKrE,OAAL,CAAayC,KAAb;EACH,CAHD;;EAIA,OAAOpD,WAAP;AACH;;AACDxB,OAAO,CAACc,OAAR,GAAkBJ,iBAAlB;AACAsG,MAAM,CAAChH,OAAP,GAAiBA,OAAO,CAAC,SAAD,CAAxB"},"metadata":{},"sourceType":"script"}